
---
date: 2016-12-31T11:34:44+08:00
title: "为什么Go语言把类型放在后面？"
description: ""
disqus_identifier: 1485833684566087464
slug: "wei-shen-me--Go-yu-yan-ba-lei-xing-fang-zai-hou-mian-？"
source: "https://segmentfault.com/a/1190000000661789"
tags: 
- 语法 
- 数据类型 
- golang 
- c 
topics:
- 编程语言与开发
---

本文整理自知乎，原文作者 @林建入。

不是为了与众不同。而是为了更加清晰易懂。

Rob Pike 曾经在 Go
官方博客解释过这个问题（原文地址：<http://blog.golang.org/gos-declaration-syntax>），简略翻译如下（水平有限翻译的不对的地方见谅）：

引言
----

Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration
syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。

C 的语法
--------

首先，先看看 C 的语法。C
采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如：

    int x;

上面的代码声明了 `x` 变量，并且其类型为 `int`——即，表达式 `x` 为 `int`
类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明：

    int *p;
    int a[3];

指明了 `p` 是一个`int`类型的指针，因为 `*p` 的类型为 `int`。而 `a`
是一个 `int` 数组，因为 `a[3]` 的类型为
`int`（别管这里出现的索引值，它只是用于指明数组的长度）。

我们接下来看看函数声明的情况。C
的函数声明中关于参数的类型是写在括号外的，像下面这样：

    int main(argc, argv)
        int argc;
        char *argv[];
    { /* ... */ }

如前所述，我们可以看到 `main` 之所以是函数，是因为表达式
`main(argc, argv)` 返回 `int`。在现代记法中我们是这么写的：

    int main(int argc, char *argv[]) { /* ... */ }

尽管看起来有些不同，但是基本的结构是一样的。

总的来看，当类型比较简单时，C的语法显得很聪明。但是遗憾的是一旦类型开始复杂，C的这套语法很快就能让人迷糊了。著名的例子如函数指针，我们得按下面这样来写：

    int (*fp)(int a, int b);

在这儿，`fp` 之所以是一个指针是因为如果你写出 `(*fp)(a, b)`
这样的表达式将会调用一个函数，其返回 `int` 类型的值。如果当 `fp`
的某个参数本身又是一个函数，情况会怎样呢？

    int (*fp)(int (*ff)(int x, int y), int b)

这读起来可就点难了。

当然了，我们声明函数时是可以不写明参数的名称的，因此 `main`
函数可以声明为：

int main(int, char \*\[\])

回想一下，之前 `argv` 是下面这样的

    char *argv[]

你有没有发现你是从声明的「中间」去掉变量名而后构造出其变量类型的？尽管这不是很明显，但你声明某个
`char *[]` 类型的变量的时候，竟然需要把名字插入到变量类型的中间。\
我们再来看看，如果我们不命名 `fp` 的参数会怎样：

    int (*fp)(int (*)(int, int), int)

这东西难懂的地方可不仅仅是要记得参数名原本是放这中间的

    int (*)(int, int)

它更让人混淆的地方还在于甚至可能都搞不清这竟然是个函数指针声明。我们接着看看，如果返回值也是个函数指针类型又会怎么样

    int (*(*fp)(int (*)(int, int), int))(int, int)

这已经很难看出是关于 `fp` 的声明了。

你自己还可以构建出比这更复杂的例子，但这已经足以解释 C
的声明语法引入的某些复杂性了。\
还有一点需要指出，由于类型语法和声明语法是一样的，要解析中间带有类型的表达式可能会有些难度。这也就是为什么，C
在做类型转换的时候总是要把类型用括号括起来的原因，像这样

    (int)M_PI

Go 的语法
---------

非C家族的语言通常在声明时使用一种不同的类型语法。一般是名字先出现，然后常常跟着一个冒号。按照这样来写，我们上面所举的例子就会变成下面这样：

    x: int
    p: pointer to int
    a: array[3] of int

这样的声明即便有些冗长，当至少是清晰的——你只需从左向右读就行。Go
语言所采用的方案就是以此为基础的，但为了追求简洁性，Go
语言丢掉了冒号并去掉了部分关键词，成了下面这样：

    x int
    p *int
    a [3]int

在 `[3]int` 和表达式中 `a`
的用法没有直接的对应关系（我们在下一节会回过头来探讨指针的问题）。至此，你获得了代码清晰性方面的提升，但付出的代价是语法上需要区别对待。

下面我们来考虑函数的问题。虽然在 Go 语言里，`main`
函数实际上没有参数，但是我们先誊抄一下之前的 `main` 函数的声明：

    func main(argc int, argv *[]byte) int

粗略一看和 C 没什么不同，不过自左向右读的话还不错。

`main` 函数接受一个 `int` 和一个指针并返回一个 `int`。

如果此时把参数名去掉，它还是很清楚——因为参数名总在类型的前面，所以不会引起混淆。

    func main(int, *[]byte) int

这种自左向右风格的声明的一个价值在于，当类型变得更复杂时，它依然相对简单。下面是一个函数变量的声明（相当于
C 语言里的函数指针）

    f func(func(int,int) int, int) int

或者当它返回一个函数时：

    f func(func(int,int) int, int) func(int, int) int

上面的声明读起来还是很清晰，自左向右，而且究竟哪一个变量名是当前被声明的也容易看懂——因为变量名永远在首位。

类型语法和表达式语法带来的差别使得在 Go 语言里调用闭包也变得更简单：

    sum := func(a, b int) int { return a+b } (3, 4)

指针
----

指针有些例外。注意在数组 (array )和切片 (slice) 中，Go
的类型语法把方括号放在了类型的左边，但是在表达式语法中却又把方括号放到了右边：

    var a []int
    x = a[1]

类似的，Go 的指针沿用了 C 的 `*` 记法，但是我们写的时候也是声明时 `*`
在变量名右边，但在表达式中却又得把 `*` 放到左左边：

    var p *int
    x = *p

不能写成下面这样

    var p *int
    x = p*

因为后缀的 `*` 可能会和乘法运算混淆，也许我们可以改用 Pascal 的 `^`
标记，像这样

    var p ^int
    x = p^

我们也许还真的应该把 `*` 像上面这样改成 `^` （当然这么一改 xor
运算的符号也得改），因为在类型和表达式中的 `*`
前缀确实把好些事儿都搞得有点复杂，举个例子来说，虽然我们可以像下面这样写

    []int("hi")

但在转换时，如果类型是以 `*` 开头的，就得加上括号：

    (*int)(nil)

如果有一天我们愿意放弃用 `*`
作为指针语法的话，那么上面的括号就可以省略了。

可见，Go 的指针语法是和 C
相似的。但这种相似也意味着我们无法彻底避免在文法中有时为了避免类型和表达式的歧义需要补充括号的情况。

总而言之，尽管存在不足，但我们相信 Go 的类型语法要比 C
的容易懂。特别是当类型比较复杂时。

