
---
date: 2016-12-31T11:33:48+08:00
title: "用Golang写一个搜索引擎(0x06)---索引构建"
description: ""
disqus_identifier: 1485833628317743753
slug: "yong-Golangxie-yi-ge-sou-suo-yin-qing-(0x06)----suo-yin-gou-jian"
source: "https://segmentfault.com/a/1190000004970424"
tags: 
- 全量索引 
- 增量索引 
- 倒排索引 
- 搜索引擎 
- golang 
categories:
- 编程语言与开发
---

https://segmentfault.com/a/

不知不觉写到第七篇了，按这个节奏，估计得写到15到20篇左右才能写完，希望自己能坚持下去，之前写代码的时候很多东西并没有想得那么细致，现在每写一篇文章还要查一些资料，确保文章的准确性，也相当于自己复习了一下吧，呵呵。

先说一下，关于倒排文件，其实还有很多东西没有讲，到后面再统一补充一下吧，主要是倒排文件的压缩技术，这一部分因为目前的存储空间不管是硬盘还是内存都是很大的，所以压缩技术用得不是很多了。

今天我们来讲讲倒排索引的构建。

之前，我们了解到了，倒排索引在系统中是存成下图这个样子

上面的B+树是一个文件，下面的倒排链是一个文件，那么，如何来构建这两个文件呢，本章我会说说一般的常规构建方法，然后说一下我是怎么构建的。

一般情况下，搜索引擎默认会认为索引是不会有太大的变化的，所以把索引分为全量索引和增量索引两部分，全量索引一般是以天甚至是周，月为单位构建的，构建完了以后就导入到引擎中进行检索，而增量索引是实时的进入搜索引擎的，很多就是保存在内存中，搜索的时候分别从全量索引和增量索引中检索数据，然后把两部分数据合并起来返回给请求方，所以增量索引不是我们这一篇的主要内容，在最后我的索引构建部分我会说一下我的增量索引构建方式。现在先看看全量索引。

全量索引构建一般有以下两种方式

### 一次性构建索引

一种是一次性的构建索引，这种构建方法是全量扫描所有文档，然后把所有的索引存储到内存中，直到所有文档扫描完毕，索引在内存中就构建完了，这时再一次性的写入硬盘中。大概步骤如下：

-   初始化一个空map
    ，map的key用来保存term，map的value是一个链表，用来保存docid链

-   设置docid的值为0

-   读取一个文档内容，将文档编号设置成docid

-   对文档进行切词操作，得到这个文档的所有term(t1,t2,t3...)

-   将所有的&lt;term,docid&gt;键值对的term插入到map的key中，docid追加到map的value中

-   docid加1

-   如果还有文档未读取，返回第三步，否则继续

-   遍历map中的&lt;key,value&gt;，将value写入倒排文件中，并记录此value在文件中的偏移offset，然后将&lt;key,offset&gt;写入B+树中

-   索引构建完毕

用图来表示就是下面几个步骤

如果用伪代码来表示的话就是这样

    //初始化ivt的map 和 docid编号
    var ivt map[string][]int
    var docid int = 0
    //依次读取文件的每一行数据
    for content := range DocumentsFileContents{
      terms := segmenter.Cut(content) // 切词
      for _,term := range terms{
          if _,ok:=ivt[term];!ok{
             ivt[term]=[]int{docid}
          }else{
             ivt[term]=append(ivt[term],docid)
        }
        docid++
    }

    //初始化一棵B+树,字典
    bt:=InitBTree("./index.dic")
    //初始化一个倒排文件
    ivtFile := InitFile("./index.ivt")
    //依次遍历字典
    for k,v := range ivt{
      //将value追加到倒排文件中，并得到文件偏移[写文件]
      offset := ivtFile.Append(v)
      //将term和文件偏移写入到B+树中[写文件]
      bt.Add(term,offset)
    }

    ivtFile.Close()
    bt.Close()
      
    }

如此一来，倒排文件就构建好了，这里我直接使用了map这样的描述，只是为了让大家更加直观的了解到一个倒排文件的构建，在实际中可能不是用这种数据结构。

### 分批构建，依次合并

一次性构建的方式，由于是把所以文档都加载到内存，如果机器的内存空间不够大的话，会导致构建失败，所以一般情况下不采用那种形式，很多索引构建的方式都用这种分批构建，依次合并的方式，这种方式主要按以下方式进行

-   申请一块固定大小的内存空间，用来存放**字典数据**和**文档数据**

-   在固定内存中初始化一个可排序的字典（可以是树，也可以是跳跃表，也可以是链表，能排序就行）

-   设置docid的值为0

-   读取一个文档内容，将文档编号设置成docid

-   对文档进行切词操作，得到这个文档的所有term(t1,t2,t3...)

-   将term按顺序插入到**字典**中，并且在内存中生成多个个&lt;term,docid&gt;的键值对&lt;t1,docid&gt;,&lt;t2,docid&gt;，并且将这些键值对存入到内存的**文档数据**中，同时保证键值对按照term进行排序

-   docid加1

-   如果内存空间用完了，将文档数据写入到磁盘上，清空内存中的文档数据

-   如果还有文档未读取，返回第三步，否则继续

-   由于各个磁盘文件中的键值对是按照term的顺序排列的，通过多路归并算法将各个磁盘文件进行合并操作，合并的过程中生成每一个term的倒排链，追加的写一次倒排文件，并配合词典生成这个term的文件偏移，直到所有文件合并完成，词典也跟着构建完成了。

-   索引构建完毕

同样，我们用一个图来表示就是下面这个样子

如果用伪代码表示的话，就是下面这个样子，代码流程也很简单，结合上面的步骤和图仔细看看就能明白

    //初始化固定的内存空间，存放字典和数据
    dic := new DicMemory()
    data := new DataMemory()
    var docid int = 0
    //依次读取文件的每一行数据
    for content := range DocumentsFileContents{
      terms := segmenter.Cut(content) // 切词
      for _,term := range terms{
          //插入字典中
          dic.Add(term)
          //插入到数据文件中
          data.Add(term,docid)
          //如果data满了，写入磁盘并清空内存
          if data.IsFull() {
              data.WriteToDisk()
              data.Empty()
        }
        docid++
    }


    //初始化一个文件描述符数组
    idxFiles := make([]*Fd,0)

    //依次读取每一个磁盘文件
    for idxFile := range ReadFromDisk {
        //获取每一个磁盘文件的文件描述符,存到一个数组中
        idxFiles.Append(idxFile)
    }

    //配合词典进行多路归并，并将结果写入到一个新文件中
    ivtFile:=InitFile("./index.ivt")
    dic.SetFilename("./index.dic")
    //多路归并
    KWayMerge(idxFiles,ivtFile,dic)

    //构建完成
    ivtFile.Close()
    dic.Close()
      
    }

上面就是两种构建全量索引的方法，对于第二种方法，还有一种特殊情况，就是当内存中的词典也很巨大，将内存撑爆了怎么办，这是可以将词典也分步的写到磁盘，然后在进行词典的合并，这里就不说了，感兴趣的可以自己去查一查。

我上面说的这些和一些搜索引擎的书可能说的不太一样，但是基本思想应该差不多，为了让大家更直观的抓到本质，很多特殊一点的情况我并没有详细说明，毕竟这不是一篇纯理论的文章，如果大家真的感兴趣肯定可以找到很多办法来更深入的了解搜索引擎的。

关于上面提到的多路归并，是一个标准的外排序的方法，到处都能找到资料，这里就不详细展开了。

另外，在索引的构建过程中还有一些细节的东西，比如一般的索引构建都是两次扫描文档，第一次用来生成一些统计信息，也就是上一篇说的词的信息，比如TF，DF之类的，第二次扫描才开始真正的构建，这样的话，可以把term的相关性的计算放到构建索引的时候来进行，那么在检索的时候只需要进行排序而不用计算相关性了，可以极大提高检索的效率。

### 我的构建方法

最后，我来说说我是怎么构建索引的，由于我写的这个搜索引擎，是没有明确的区分全量和增量索引概念的，把这个决定权交到了上层的引擎层来决定，所以在底层构建索引的时候不存在全量增量的概念，所以采用了第一种和第二种方法结合的方式进行索引的构建。

-   首先设定一个阈值，比如10000篇文档，在这10000篇文档的范围内，按照第一种方式构建索引，生成一个字典文件和一个倒排文件，这一组文件叫做一个**段(segment)**

-   每10000篇文档生成一个**段(segment)**，直到所有文档构建完成，从而生成了多个段，并且在搜索引擎启动以后，增量数据也按这个方法进行构建，所以段会越来越多

-   每一个段就是索引的一部分，他有倒排索引的全部东西(词典，倒排表)，可以进行一次正常的检索操作，每次检索的时候依次搜索各个段，然后把结果合并起来就是最终结果了

-   如果段的数量过多，按照第二种方式的思想，对多个段的词典和倒排文件进行多路合并操作，由于词典是有序的，所以可以按照term的顺序进行归并操作，每次归并的时候把倒排全拉出来，然后生成一个新的词典和新的倒排文件，当合并完了以后把老的都删掉。

上面的合并操作策略完全交给上层的引擎层甚至业务层来完成，有些场景下增量索引少，那么第一次构建完索引以后就可以把各个段合并到一起，增量索引每隔一定的时间合并一次，有些场景下数据一直不停的进入系统中，那么可以通过一些策略，不停的在系统空闲时合并一部分索引，来保证检索的效率。

OK，上面就是索引构建的方法，到这一篇完成，倒排索引的数据结构，构建方式都说完了，但是还是有很多零碎的东西没有说，后面会统一的把一些没提及到的地方整理一篇文章说一下，接下来，我会用一到两篇的文章说一下正排索引，然后就可以跨到检索层去了。

最后，欢迎扫一扫关注我的公众号哈：）



