
---
date: 2016-12-31T11:33:43+08:00
title: "Go性能优化技巧5_10"
description: ""
disqus_identifier: 1485833623950730104
slug: "Go-xing-neng-you-hua-ji-qiao--5_10"
source: "https://segmentfault.com/a/1190000005040872"
tags: 
- golang 
categories:
- 编程语言与开发
---

https://segmentfault.com/a/

闭包（closure）也是很常见的编码模式，因它隐式携带上下文环境变量，因此可让算法代码变得更加简洁。

但任何 “便利” 和 “优雅”
的背后，往往都是更复杂的实现机制，无非是语法糖或编译器隐藏了相关细节。最终，这些都会变成额外成本在运行期由
CPU、runtime 负担。甚至因不合理使用，造成性能问题。

用几个代码片段看看可能的麻烦。

\

单次调用的性能差异有点大（不同环境结果会不同），但这会不会和匿名函数本身构建有关？

\

似乎是这样。可接下来的问题就更麻烦了。（代码仅作演示，并未保证逻辑一致）

首先，闭包引用原环境变量，导致 y 逃逸到堆上，这必然增加了 GC
扫描和回收对象的数量。

接下来，同样是因为闭包引用原对象，造成数据竞争（data race）。

可见，闭包未必总能将事情 “简单化”。在学习 Go
底层实现过程中，你会了解到，所有 “简单”
都是由编译器或运行时用一堆复杂过程堆出来的。

最新动态，请扫码关注\


