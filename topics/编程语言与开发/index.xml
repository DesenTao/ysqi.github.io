<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>编写地道的Go代码</title>
      <link>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:58 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</guid>
      <description>在阅读本文之前，我先推荐你阅读官方的 Effective Go文档，或者是中文翻译版: 高效Go编程，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。
最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。
本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。
注释 可以通过 /* …… */ 或者 // ……增加注释， //之后应该加一个空格。
如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。
 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /*Package net provides a portable interface for network I/O, includingTCP/IP, UDP, domain name resolution, and Unix domain sockets....... */ package net......  注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在godoc中容易查找。</description>
    </item>
    
    <item>
      <title>Gonet_http包</title>
      <link>https://yushuangqi.com/blog/2017/go-net_httpbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:57 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-net_httpbao.html</guid>
      <description>Go net/http包
Go Http客户端 get请求可以直接http.Get方法
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;log&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;bytes&amp;quot; ) func main() { resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;) if err != nil { // handle error log.Println(err) return } defer resp.Body.Close() headers := resp.Header for k, v := range headers { fmt.Printf(&amp;quot;k=%v, v=%v\n&amp;quot;, k, v) } fmt.Printf(&amp;quot;resp status %s,statusCode %d\n&amp;quot;, resp.Status, resp.StatusCode) fmt.Printf(&amp;quot;resp Proto %s\n&amp;quot;, resp.Proto) fmt.Printf(&amp;quot;resp content length %d\n&amp;quot;, resp.ContentLength) fmt.Printf(&amp;quot;resp transfer encoding %v\n&amp;quot;, resp.</description>
    </item>
    
    <item>
      <title>Golang学习摘录一:初识</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</guid>
      <description>1、Hello Word编写方式 package main import &amp;quot;fmt&amp;quot; func main (){ fmt.Printf(&amp;quot;Hello, world&amp;quot;) }  编译 go build helloworld.go
运行 ./helloworld
2、声明方式 1、普通方式 var a int = 15 var b bool = false 或 var a int var b bool a = 15 b = false 2、 :=会自动匹配类型，只能在函数内使用 a := 15 b := false 3、中括号的形式： var ( x int b bool ) 4、平行赋值 a,b := 20,16 #注意 :Go 的编译器对声明却未使用的变量在报错。 5、常量，只能是数字、字符串或布尔值 const( // 枚举的生成方式 a = iota // a为0 b = iota // b为1，改行的 “=iota”可省略 ) 如果需要,可以明确指定常量的类型: const ( a = 0 b string = &amp;quot;0&amp;quot; )  3、字符串 var s string = &amp;quot;hello&amp;quot; #Go中字符串是不可变的  如果想修改字符需要使用下面的方法</description>
    </item>
    
    <item>
      <title>Golang语言常用算法</title>
      <link>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</guid>
      <description>在学习golang语言，文档看的实在是乏味，就想着把常用的算法做个实现，边写变学习，想来效果还是不错的！
​1. 堆排序
package main import &amp;quot;fmt&amp;quot; func buildHeap(array []int, length int) { var i, j int; for i = 1; i &amp;lt; length; i = i + 1 { for j = i; j &amp;gt; 0 &amp;amp;&amp;amp; array[j] &amp;gt; array[(j-1)/2]; j = (j - 1)/2 { array[j], array[(j-1)/2] = array[(j-1)/2], array[j] } } } func heapSort(array []int, length int) { array[0], array[length - 1] = array[length - 1], array[0] if length &amp;lt;= 2 { return } i, j:= 0, 0 for { j = 2 * i + 1 if j + 1 &amp;lt; length - 1 { if array[j] &amp;lt; array[j + 1] { j = j + 1 } } else if j &amp;gt;= length -1 { break } array[i], array[j] = array[j], array[i] i = j } heapSort(array, length - 1) } func main() { primes := [6]int{3, 11, 5, 2, 13, 7} fmt.</description>
    </item>
    
    <item>
      <title>Golang学习摘录三:函数</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</guid>
      <description>函数定义 type mytype int // 新的类型 func (p mytype) funcname(q int) (r,s int) {return 0,0}  作用域 在 Go 中,定义在函数外的变量是全局的,那些定义在函数内部的变量,对于函数来说 是局部的。如果命名覆盖——一个局部变量与一个全局变量有相同的名字——在函数 执行的时候,局部变量将覆盖全局变量。
多值返回 func (file *File) Write(b []byte) (n int, err error)
Go得函数可以返回多个值
命名返回值 Go 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像 输入参数那样。如果对其命名,在函数开始时,它们会用其类型的零值初始化。如果 函数在不加参数的情况下执行了 return 语句,结果参数会返回。
例：
func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) &amp;gt; 0 &amp;amp;&amp;amp; err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:len(buf)] } return }  延迟代码defer 在 defer 后指定的 函数会在函数退出前调用。</description>
    </item>
    
    <item>
      <title>Golang学习摘录二:控制语句</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</guid>
      <description>if语句 i f x &amp;gt; 0 { // {是强制的,且必须和if在同一行 return y } else { return x }  if 和 switch 接受初始化语句,通常用于设置一个(局部)变量。
if err := Chmod(0664); err != nil { //nil 与 C 的 NULL 类似 fmt.Printf(err) //err 的作用域被限定在 if 内 return err }  goto语句 用 goto 跳转到一定是当前函数内定义的标签
func myfunc() { i := 0 Here: // 这行的第一个词,以分号结束作为标签,标签名区分大小写 println(i) i++ goto Here // 跳转 }  for语句 Go 的 for 循环有三种形式,只有其中的一种使用分号。</description>
    </item>
    
    <item>
      <title>Golang学习摘录七:并发</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</guid>
      <description>Go使用channel和goroutine开发并行程序。goroutine 是 Go并发能力的核心要素。
goroutine 是一个普通的函数，只是需要使用关键字 go 作为开头。
ready(&amp;quot;Tea&amp;quot;, 2) // 普通函数调用 go ready(&amp;quot;Tea&amp;quot;, 2) // ready() 作为 goroutine 运行  Go routine实践
func ready(w string, sec int) { time.Sleep(time.Duration(sec) * time.Second) fmt.Println(w,&amp;quot;is ready!&amp;quot;) } func main() { go ready(&amp;quot;Tea&amp;quot;, 2) go ready(&amp;quot;Coffee&amp;quot;, 1) fmt.Println(&amp;quot;I&#39;m waiting&amp;quot;) time.Sleep(5 * time.Second) } // 输出 I&#39;m waiting //立刻 Coffee is ready! //1秒后 Tea is ready! //2秒回  如果不等待goroutine的执行（例如移除第17行），程序会立刻终止，而任何正在执行的goroutine都会停止。为了修复使用channels机制来和goroutine通讯。可以通过channel发送或接受值。这些值只能是特定的类型:channel 类型。
注意，必须使用 make 创建 channel：
ci := make(chan int) //创建 channel ci 用于发送和接收整数 cs := make(chan string) //创建 channel cs 用于字符串 cf:=make(chan interface{})//channel cf 使用了空接口来满足各种类型  向 channel 发送或接收数据，是通过类似的操作符完 成的:&amp;lt;−.</description>
    </item>
    
    <item>
      <title>Golang学习摘录五:进阶</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</guid>
      <description>Go 有指针。然而却没有指针运算,因此它们更象是引用而不是你所知道的来自于 C 的指针。指针非常有用。在 Go 中调用函数的时候,得记得变量是值传递的。因此,为了修改一个传递入函数的值的效率和可能性,有了指针。
var p *int fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印nil var i int // 定义一个整型变量i p = &amp;amp;i // 使得p指向i fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印出来的内容类似0x7ff96b81c000a  内存分配 用new分配内存 内建函数 new 本质上说跟其他语言中的同名函数功能一样:new(T) 分配了零值填充 的 T 类型的内存空间,并且返回其地址,一个 *T 类型的值。用 Go 的术语说,它返回 了一个指针,指向新分配的类型 T 的零值。记住这点非常重要。
用make分配内存 内建函数 make(T, args) 与 new(T) 有着不同的功能。它只能创建 slice,map 和 channel,并且返回一个有初始值(非零)的 T 类型,而不是 *T。本质 来讲,导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。 例如,一个 slice,是一个包含指向数据(内部 array)的指针,长度和容量的三项描述 符;在这些项目被初始化之前,slice 为 nil。对于 slice,map 和 channel,make 初始 化了内部的数据结构,填充适当的值。</description>
    </item>
    
    <item>
      <title>Golang学习摘录六:接口</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</guid>
      <description>Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集合。
// 这段代码定义了具有一个字段和两个方法的结构类型s。 type S struct { i int } func (p *S) Get() int { return p.i } func (p *S) Put(v int) { p.i = v } // 定义接口 type I interface { Get() int Put(int) } // 对于接口I，S是合法的实现，因为它定义了 I 所需的两个方法。注意：即便是没有明 确定义 S 实现了 I，这也是正确的。 // Go 程序的特性接口值： func f(p I) {// 定义一个函数接受一个接口类型作为参数 fmt.Println(p.Get()) // p实现了接口I，必须有Get()方法 p.Put(1) // Put()方法是类似的 // 这里的变量p保存了接口类型的值。 } // 调用 var s S f(&amp;amp;s) // 因为S实现了I，可以调用f向其传递S类型的值的指针 // 获取 s 的地址,而不是 S 的值的原因,是因为在 s 的指针上定义了方法,参阅上面的 代码 5.</description>
    </item>
    
    <item>
      <title>Golang学习摘录四:包</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</guid>
      <description>包是函数和数据的集合。用 package 关键字定义一个包。文件名不需要与包名 一致。包名的约定是使用小写字符。Go 包可以由多个文件组成,但是使用相同的 package &amp;lt;name&amp;gt; 这一行。
package even func Even(i int) bool { return i%2==0 } func odd(i int) bool { return i%2==1 }  名称以大写字母起始的是可导出的，可以在包的外部调用。
共有函数的名称以大写字母开头。
私有函数的名称以小写字母开头。
package main import ( //导入下面的包 &amp;quot;event&amp;quot; //本地包even在这里导入 &amp;quot;fmt&amp;quot; ) func main(){ i := 5 fmt.Printf(&amp;quot;Is %d event? %v\n&amp;quot;, i,event.Even(i))// 调用even包中的函数。访问一个包中的函数的语法是&amp;lt;package&amp;gt;.Function()。 }  Go程序的命名规则：包名约定小写字母开头；方法名最好使用驼峰式名称，避免使用下划线，方法名应简洁清晰。
包的文档 每个包都应该有包注释,在 package 前的一个注释块。对于多文件包,包注释只需要 出现在一个文件前,任意一个文件都可以。包注释应当对包进行介绍,并提供相关于 包的整体信息。这会出现在 go doc 生成的关于包的页面上,并且相关的细节会一并 显示。
官方regexp包的例子：
 /* The regexp package implements a simple library for regular expressions.</description>
    </item>
    
    <item>
      <title>Goreflect包</title>
      <link>https://yushuangqi.com/blog/2017/go-reflectbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:53 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-reflectbao.html</guid>
      <description>Go reflect包
反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Type.
reflect 包中另一个重要的类型是 Value. 一个 reflect.Value 可以持有一个任意类型的值. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value. 和 reflect.TypeOf 类似, reflect.ValueOf 返回的结果也是对于具体的类型, 但是 reflect.Value 也可以持有一个接口值.
reflect.Type 类型 代码，
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;unsafe&amp;quot; ) // 嵌套结构体 type ss struct { a struct { int string } int string bool float64 } func (s ss) Method1(i int) string { return &amp;quot;结构体方法1&amp;quot; } func (s *ss) Method2(i int) string { return &amp;quot;结构体方法2&amp;quot; } var ( intValue = int(0) int8Value = int8(8) int16Value = int16(16) int32Value = int32(32) int64Value = int64(64) uIntValue = uint(0) uInt8Value = uint8(8) uInt16Value = uint16(16) uInt32Value = uint32(32) uInt64Value = uint64(64) byteValue = byte(0) runeValue = rune(0) uintptrValue = uintptr(0) boolValue = false stringValue = &amp;quot;&amp;quot; float32Value = float32(32) float64Value = float64(64) complex64Value = complex64(64) complex128Value = complex128(128) arrayValue = [5]string{} // 数组 sliceValue = []byte{0, 0, 0, 0, 0} // 切片 mapValue = map[string]int{} // 映射 chanValue = make(chan int, 2) // 通道 structValue = ss{ // 结构体 struct { int string }{10, &amp;quot;子结构体&amp;quot;}, 20, &amp;quot;结构体&amp;quot;, false, 64.</description>
    </item>
    
    <item>
      <title>Gobuild命令说明</title>
      <link>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</link>
      <pubDate>Wed, 22 Feb 2017 08:37:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</guid>
      <description>go help build
 构建编译由导入路径命名的包，以及它们的依赖关系，但它不会安装结果.
使用 go build [-o 输出名] [-i] [编译标记] [包名]  如果参数为***.go文件或文件列表，则编译为一个个单独的包。
当编译单个main包（文件），则生成可执行文件。
当编译单个或多个包非主包时，只构建编译包，但丢弃生成的对象（.a），仅用作检查包可以构建。
当编译包时，会自动忽略&amp;rsquo;_test.go&amp;rsquo;的测试文件。
参数 -o output 指定编译输出的名称，代替默认的包名。  -i install 安装作为目标的依赖关系的包(用于增量编译提速)。  以下 build 参数可用在 build, clean, get, install, list, run, test -a 完全编译，不理会-i产生的.a文件(文件会比不带-a的编译出来要大？) -n 仅打印输出build需要的命令，不执行build动作（少用）。 -p n 开多少核cpu来并行编译，默认为本机CPU核数（少用）。 -race 同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64. -msan 启用与内存消毒器的互操作。仅支持linux / amd64，并且只用Clang / LLVM作为主机C编译器（少用）。 -v 打印出被编译的包名（少用）. -work 打印临时工作目录的名称，并在退出时不删除它（少用）。 -x 同时打印输出执行的命令名（-n）（少用）. -asmflags &#39;flag list&#39; 传递每个go工具asm调用的参数（少用） -buildmode mode 编译模式（少用） &#39;go help buildmode&#39; -compiler name 使用的编译器 == runtime.</description>
    </item>
    
    <item>
      <title>从设计到实战:Go如何扛住100亿次请求</title>
      <link>https://yushuangqi.com/blog/2017/cong-she-ji-dao-shi-zhan-go-ru-he-gang-zhu-100yi-ci-qing-qiu.html</link>
      <pubDate>Wed, 22 Feb 2017 08:37:15 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/cong-she-ji-dao-shi-zhan-go-ru-he-gang-zhu-100yi-ci-qing-qiu.html</guid>
      <description>扛住100亿次请求？我们来试一试
作者：ppmsn2005#gmail.com
项目:https://github.com/xiaojiaqi/10billionhongbaos
wiki:https://github.com/xiaojiaqi/10billionhongbaos/wiki/扛住100亿次请求？我们来试一试
​1. 前言
前几天，偶然看到了 《扛住100亿次请求——如何做一个“有把握”的春晚红包系统”》（url）一文，看完以后，感慨良多，收益很多。正所谓他山之石，可以攻玉，虽然此文发表于2015年,我看到时已经是2016年末，但是其中的思想仍然是可以为很多后端设计借鉴，。同时作为一个工程师，看完以后又会思考，学习了这样的文章以后，是否能给自己的工作带来一些实际的经验呢？所谓纸上得来终觉浅，绝知此事要躬行，能否自己实践一下100亿次红包请求呢？否则读完以后脑子里能剩下的东西 不过就是100亿 1400万QPS整流 这样的字眼，剩下的文章将展示作者是如何以此过程为目标，在本地环境的模拟了此过程。
实现的目标: 单机支持100万连接，模拟了摇红包和发红包过程，单机峰值QPS 6万，平稳支持了业务。
 注：本文以及作者所有内容，仅代表个人理解和实践，过程和微信团队没有任何关系，真正的线上系统也不同，只是从一些技术点进行了实践，请读者进行区分。因作者水平有限，有任何问题都是作者的责任，有问题请联系 ppmsn2005#gmail.com. 全文内容 扛住100亿次请求？我们来试一试
​2. 背景知识
 QPS: Queries per second 每秒的请求数目
 PPS：Packets per second 每秒数据包数目
 摇红包：客户端发出一个摇红包的请求，如果系统有红包就会返回，用户获得红包
 发红包：产生一个红包里面含有一定金额，红包指定数个用户，每个用户会收到红包信息，用户可以发送拆红包的请求，获取其中的部分金额。
​3. 确定目标
 在一切系统开始以前，我们应该搞清楚我们的系统在完成以后，应该有一个什么样的负载能力。
3.1 用户总数:
 通过文章我们可以了解到接入服务器638台, 服务上限大概是14.3亿用户， 所以单机负载的用户上限大概是14.3亿/638台=228万用户/台。但是目前中国肯定不会有14亿用户同时在线，参考 http://qiye.qianzhan.com/show/detail/160818-b8d1c700.html 的说法，2016年Q2 微信用户大概是8亿，月活在5.4 亿左右。所以在2015年春节期间，虽然使用的用户会很多，但是同时在线肯定不到5.4亿。
3.2. 服务器数量：
 一共有638台服务器，按照正常运维设计，我相信所有服务器不会完全上线，会有一定的硬件冗余，来防止突发硬件故障。假设一共有600台接入服务器。
3.3 单机需要支持的负载数：
 每台服务器支持的用户数：5.4亿/600 = 90万。也就是平均单机支持90万用户。如果真实情况比90万更多，则模拟的情况可能会有偏差，但是我认为QPS在这个实验中更重要。
3.4. 单机峰值QPS：
 文章中明确表示为1400万QPS.这个数值是非常高的，但是因为有600台服务器存在，所以单机的QPS为 1400万/600= 约为2.3万QPS, 文章曾经提及系统可以支持4000万QPS，那么系统的QPS 至少要到4000万/600 = 约为 6.</description>
    </item>
    
    <item>
      <title>Go微服务实践</title>
      <link>https://yushuangqi.com/blog/2017/go-wei-fu-wu-shi-jian.html</link>
      <pubDate>Wed, 22 Feb 2017 08:37:14 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-wei-fu-wu-shi-jian.html</guid>
      <description>简介  近一两年来，微服务架构已经成为热门话题（microservices.io)，与传统的一体化应用架构相比，微服务架构在开发、测试、部署方面都有众多吸引人之处，越来越多没有历史包袱的新项目都启用微服务架构的模式来开发。
我们这个团队经过深入思考之后，决定在一起美这个APP的后端开发中，选择Go作为开发语言，采用微服务模式来实现，经过近半年的实践，形成了一些心得，简单总结后分享出来，希望能够给大家一些帮助。
框架选择 不同的团队在选择基础框架（库）时考虑的要素不同，我们团队更喜欢小而美的框架，尽可能不要让框架侵入业务，易于升级、维护和替换，所以我们更愿意选择Library而不是Framework。
在web方面，我们选择了negroni作为middleware库，采用性能不错的httprouter替换go标准库的mux，而没有用任何web相关的框架。
在微服务之间的rpc调用方面，为了将来的扩展性、跨语言调用等因素，我们没有直接用go标准库的rpc模块，而是采纳了google最新推出的grpc。但grpc本身属于比较重型的rpc框架，对业务代码有一定的侵入性，我们做了一系列的库（包括worpc、worc、wonaming等https://github.com/wothing）来屏蔽这些不必要的业务代码侵入，保持了业务代码本身的整洁。
微服务划分 在微服务体系中，如何切分微服务也是一个重要的话题，在我们的实践中，我们遵循了如下一些原则：
 逻辑独立、边界清晰的模块作为一个独立的微服务
 每个table只由一个微服务操作（包括插入、读取、更改、删除等）
 table之间不引入外键约束，id字段全部采用uuid
 将需要保持数据一致性的操作放在一个微服务中，避免跨服务带来的数据一致性难题
 微服务之间的通信，尽可能采用消息队列实现松耦合，当需要同步调用时再借助于rpc
 微服务独立部署，通过etcd实现服务的注册与发现
  总体架构  Gateway  Gateway是微服务对外提供服务的一个屏障，它的核心点在于：
 屏蔽微服务之间通过消息队列、rpc等通信方式，为Web页面和移动APP提供基于HTTP协议的RESTful API接口
 对每一个http业务请求进行必要的鉴权和数据完整性、合法性检查，以减少微服务的负担，让微服务的代码更纯粹
 微服务部署体系中，每个微服务可能会部署多个实例，Gateway还承担着在这些实例中进行负载均衡的功能
 进行必要的日志输出、监控打点等功能，对每一个来自于APP和页面的http请求，生成一个唯一的trace id，并将trace id传导到每一个后续的微服务中，以便后续的查错和性能调优
 Gateway的每一个http请求都是无状态的，采用JWT（Json Web Token）机制实现一个客户端的请求状态信息的传递
   服务的注册与发现wonaming  微服务体系中，服务的注册和发现对整体架构非常重要，尤其对于同步的rpc调用，每个服务有多少实例，每个实例的地址等，都需要有一个统一的管理。我们采用etcd保存服务信息，同时封装了wonaming作为微服务注册和发现的中间件，它的主要功能包括：
 服务在启动时，调用wonaming向etcd注册包含TTL的服务“索引”、
 注册后，服务与etcd保持定时心跳，当微服务主动退出或超时，服务解注册并“下线”
 在Gateway中，通过resolver进行服务发现，配合grpc提供的balancer实现负载均衡，resolver启动后会对etcd中的 /wonaming 目录进行监控，当有服务注册或者解注册时，动态维护可用服务清单。
     r := wonaming.NewResolver(name) b := grpc.RoundRobin&amp;reg; conn, err := grpc.</description>
    </item>
    
    <item>
      <title>深度学习第一课</title>
      <link>https://yushuangqi.com/blog/2017/shen-du-xue-xi-di-yi-ke.html</link>
      <pubDate>Tue, 21 Feb 2017 13:20:04 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shen-du-xue-xi-di-yi-ke.html</guid>
      <description>近几年深度学习的概念非常火，我们很幸运赶上并见证了这一波大潮的兴起。记得2012年之前提及深度学习，大部分人并不熟悉，而之后一段时间里，也有些人仍旧持怀疑的态度，觉得这一波浪潮或许与之前sparse coding类似，或许能持续火个两三年，但终究要被某个新技术新方法所取代，再后来，无论是学术界还是工业界，总有些研究者为自己没有在第一时间跟进这波浪潮感到后悔莫及。确实，从2012年AlexNet取得ImageNet的冠军开始，五年过去了，深度学习的方法仍旧占领着人工智能这片领域。
随着这波浪潮，有些人作为弄潮儿，兴起一波波巨浪，引领各个领域从传统方法到深度学习方法的转变，并希望能够通过了解其他领域的方法改进自己所从事的领域；有些人辛勤地工作，利用深度学习的方法为公司提高业绩，希望实时跟进并实现最新的技术；有些校园中的研究僧，一方面需要了解最新技术及其背后原理，另一方面还有发文章和找工作的压力；有些相关从业者，如编辑、记者，经常报道AI领域新闻，却从没有时间仔细研究深度学习；还有些非技术人员，总会在这些新闻后惊恐地询问“天网是否能在有生之年建成?”或是“AI对人类的威胁到了什么程度?”。
仅仅通过一节课程，或是一本书来解决以上所有问题明显是不可能的。鉴于国内机器学习资料还是偏少，而且大多是理论性质，并没有实践模块，我们从去年年底开始着手写一本深度学习相关的tutorial，并希望通过一章章真实的案例来带大家熟悉深度学习、掌握深度学习。这个tutorial中每一章内容都围绕着一个真实问题，从背景介绍到使用PaddlePaddle平台进行代码实验，完整地让大家了解整个问题如何用深度学习来解决，从此告别纸上谈兵。参加本次活动之前，没有想到这次报名人数之多。看了下报名群中的同学不乏一些高端用户，于是我知道本篇课程必然要要一些同学失望了，因为这一讲作为第一讲，只能考虑到大多数用户，设计成难度适中的课程，为大家提供一些深度学习最基本的概念，以便更轻松地入门深度学习。如果您是高端用户(能自己run起来深度学习模型或做过一些常识)，建议您可以直接移步tutorial自学，当然如果感兴趣，欢迎继续关注我们系列的后续课程。
首先，对这个系列的后续深度学习课程做一个预告。在这份tutorial中，我们将覆盖如下内容：
 新手入门 识别数字 图像分类 词向量 情感分析 文本序列标注 机器翻译 个性化推荐 图像自动生成  本节课程中，我们主要带大家了解深度学习，通过它的一些有用或有趣的应用了解深度学习的基本原理和工作方式。
一、深度学习是什么 传统的机器学习中，我们要为每种任务定义其特定的解决方案。对于图像，曾经人们耗费大量精力设计各种描述子进行图像特征描述；对于文本，单单一个机器翻译任务就动辄多个模型的设计：如词语对齐、分词或符号化（tokenization）、规则抽取、句法分析等，每一步的错误都会积累到下一步，导致整个翻译结果不可信，且要追查一个错误会非常复杂。 深度学习的优势，就是可以弥补以上问题，一方面减少了对大量手工特征的依赖，对于图像文本等领域可以直接从原数据进行建模；另一方面通过端到端的网络模型（即一个网络直接从输入到输出建模，而不需要中间步骤）减少了多步骤中错误累积的问题。
深度学习采用多层神经网络的方法，依赖大数据和强硬件。
 大数据
在这个数据爆发的时代，普遍的认知是，大数据并不是问题。但实际上也不完全是这样。从领域角度，图像的通用分类和语言模型的训练或许可以从搜索引擎中获取大量样本，但对于细粒度图像分类（如不同类型的花的分类）或是 专业领域的对话数据（如法律咨询类）的数据就比较稀缺；从应用方法角度，图像、文本和语音都方便获取，但如果希望进行有监督训练，就必须有对应的标记（label），如标明一段语音对应的人，或是一段语音对应的文本，这就是个大工程了。这就需要我们利用已有资源，最简单的方法比如可以先利用大量无标记数据学习数据的特征，就可以减少数据标注规模。
 强硬件
由于深度学习需要强计算处理能力，因此需要GPU显卡进行并行加速，拼硬件已经成为学界和工业界在研究深度学习网络时的一大共识。在2016年期间，英伟达和AMD的股票价格都实现了飞涨，如下图是GPU制造商英伟达(NVIDIA)公司今年的股价趋势。可以说这种跳跃式增长得益于GPU芯片在游戏、虚拟现实、自动驾驶、数据中心等各个高性能计算需求领域的应用。
GPU的每个显卡具有多个（通常是几十个）多处理器(Streaming Multiprocessors, SMs)，每个多处理器中有上百个CUDA核。一个多线程程序的一个kernel实例在一个SM上执行，一个kernel实例上的操作会分配到不同cuda核中独立执行。所以只要程序分配得当，GPU中的处理器越多执行越快。如Titan X(GM100)显卡拥有24个多处理器，每个多处理器拥有128个CUDA核，整个显卡有3072个CUDA核， 其相对16核Xeon E5 CPU处理器要加速5.3~6.7倍[1]，这对于实时性要求较高的应用意义非凡。
  二、深度学习的应用 深度学习可以涵盖很多应用范围，我们这里可以先以几个有意思的应用，给大家一个基本概念， 工业界常用的例子会在后续课程中详细地举例。
极简版无人车 无人车概念近几年很火，从传统领域到互联网企业都多少有这个方向的研究者。对于初步接触神经网络的同学，我们先引入一个小任务。如下图所示为一个可遥控小车在车道上的运行轨迹，小车上方搭载GoPro摄像头。图中蓝线表示垂直基准线，红线表示每一时刻小车应驶方向。我们的目标是，基于人为操控小车的行驶方向和当前图像数据，给出其驾驶方案。
这里，可以用神经网络指定网络的输入输出分别是当前图像和应走的方向，整体作为一个回归问题来处理，其中输入图像用多层卷积神经网络来解析。这里可能有朋友会说，其实我只需要用基本图像处理技术（比如二值化图像后再检测连通域）找出来左右两条车道，再向前方车道线中点位置方向走不就行了吗？确实是可以这么干的，我们这里只是为了说明深度学习的端到端训练，举例个最简版的无人车，有清晰的车道线，并且没有红绿灯、障碍物等干扰。实际情况中，需要考虑跟踪前车、车道保持、障碍物检测、红绿灯检测等多种情况，因此需要多模型的设计和集成。单就最简单情况下车道检测的这个事情来说， 确实可以仅通过图像处理+人工策略达成目的，也不需要什么训练数据，但这就要求程序员每遇到一个badcase都需要人工修改策略，这样等下一位程序员接手这段代码的时候，就只能呜呜呜了。
拍摄照片油画化 2015年的一篇文章[5]，将艺术家梵高和深度学习联系在了一起，文中实现了将艺术画style附体于日常拍摄照片，从而得到“艺术照”的效果。其做法是设计一个神经网络，定义该网络的损失函数为Diff(拍摄照片，生成作品) 与 Diff(艺术画，生成作品)这两个Diff的加权和。其中Diff表示两幅图片的差异。但如果通过每个像素的差异来计算这个Diff的话，显然不合理，对于拍摄照片和生成作品而言，像素值必然已经大变，而对于艺术画和生成作品而言，可能色调相似，但靠单个像素值去比就肯定是相差甚远了。所以我们其实想要的只是一个抽象的概念，如下图的例子，我们只需要生成的图包含“猫”，且画风和中间的艺术照相似。于是采用了神经网络的隐层作为度量他们Diff的空间。
图片转载自： http://phunter.farbox.com/post/mxnet-tutorial2
机器翻译 刚才的两个例子都是深度学习在图像中的应用，其在文本中同样意义重大。和图像不同的是，文本作为一个序列化信息，深度神经网络对这样数据的的处理和图像不太相同，但除此之外的基本思路就可以相互迁移了。比如已经了解了通过深度学习进行图像分类的方法，那么文本分类只是变化一下，将一短文本映射成特征向量从而进行分类，这可以通过将理解图片的卷积神经网络改为处理序列信息的循环神经网络完成。类似地，机器翻译（用计算机来进行不同语言之间的翻译）也可以通过类似的方法。以通过深度学习进行中译英为例，首先通过一个循环神经网络理解一句汉语（映射为文本语义信息，可以是一个向量，也可以是一个时序信息），称此过程为“编码”，再将这个文本语义信息通过另一个循环神经网络，每个时刻输出一个英语单词，称此过程为“解码”，通过这样的编码-解码结构即完成了机器翻译。我这里只是白话说出了机器翻译的大概思想，感兴趣的同学可以参考机器翻译一章的tutorial或追踪后续课程。
为你写诗 看完以上内容，如果想让你根据一个词创作一首诗，你想能怎么做呢？恐怕已经有同学想到了：用翻译的做法写诗。不错，机器翻译其实可以用到很多地方，只需要修改数据集就ok，如果我们想根据一个词，让机器“创作”一首诗，只需要将翻译模型的输入设置为这个词，而输出是诗句即可。不过，通常这么做是有问题的，因为这样做导致输入序列很短而输出很长，其间的依赖并不能充分发挥出来，硬将这样的两个序列绑在一起可能导致机器强硬地“背”下来如输入语料而没有真正理解语义。因此，有的工作中用短语生成第一句诗词，用第一句去生成第二句……；或者可以用前n-1句生成第n句诗词。感兴趣的同学可以自己试一下，也可以试用一下度秘里面写诗模块。
商品推荐 商品推荐是电商和新闻客户端们的关注热点，他们都关注用户兴趣的把控，其推荐系统的好坏往往会对用户留存和购买情况有较大影响。这里我们可以想见，最基本的推荐策略是爆款推荐（全民热点），和已浏览或是购买/收藏了的项目。对于大量用户没有过浏览记录的项目，传统推荐方法一般采用协同过滤，即推荐给用户相似用户的兴趣项，另一种方法是通过基于内容过滤推荐，即推荐给用户浏览项目的相似项，这其中就涉及到用户相似度和产品/项目相似度的获取。一方面，我们可以利用深度学习进行其相似度的建模，另一方面，我们还可以将用户特征和产品/项目特征映射到一个相同的空间进行特征比较，也就是将下图A（协同过滤）和B（基于内容过滤）策略改为C。
三、深度学习的缺陷 说过了神经网络的牛逼之处，我们再来看看它的一些缺陷，至少是目前难以解决的问题。
特斯拉事件 关注特斯拉的同学应该都有注意到，去年一位23岁的中国男青年，在驾驶特斯拉电动汽车沿京港澳高速河北邯郸段公路行驶时，前车躲避障碍物后，该男子躲闪不及撞上了道路清扫车，发生严重车祸导致死亡。
特斯拉官方并没有公布过其内部算法，我们只知道特斯拉的自动驾驶系统Autopolit中曾有以色列Mobileye公司提供的技术。Mobileye是一家基于视觉帮助减少交通事故的公司，其研发多年的高级驾驶辅助系统（ADAS）处于业内领先，主要基于单目摄像头传回的图像，通过深度神经网络进行车辆检测、车道识别等[3]。但Mobileye自己也表示曾经提醒过特斯拉公司，他们的这套系统只能起辅助作用， 并不完善，也不能完全保障车主。虽然特斯拉官方声明由于车主家属不愿提供更多信息，导致具体Autopolit错误原因无从定位，但原因或是因为中国独有的道路清扫车不曾出现在单目视觉的训练数据集，或是因为光照等特殊因素导致的图像质量问题，都说明无法仅通过视觉技术保障自动驾驶的安全性。我们不能将这起事故归结于是深度学习的缺陷，但在实际系统中， 我们目前确实难从一个端到端的系统中完全定位并解决问题，大家还可以看下面的例子进一步理解。
可解释性 在之前的“深度学习是什么”这一节中，我们讲到深度学习可以利用端到端的学习避免一些多步骤积累错误导致的问题，然而这其实也是一种缺陷。我们无从定位问题出在哪里。下面就以图像分类的一个badcase为例进行说明。
ImageNet竞赛2012年冠军工作AlexNet的作者Krizhevsky 曾提出，虽然AlexNet效果很棒，但为了最优化该数据集上的效果，不得不建立这样一个含有非常多参数的深度神经网络，而这样的网络非常容易过拟合。在15年的CVPR会议中，Anh Nguyen提出了一种生成样本的方法，该方法生成的样本可以“愚弄” 用于图像识别的深度神经网络[4]，如下图所示的8幅图下面标注的文字分别为ImageNet竞赛数据集上效果最好的网络对该图的识别结果（置信度高于99.6%）， 该网络将我们认为的这些波纹分别识别成了王企鹅、海星、棒球、电吉他、火车车厢、遥控器、孔雀、非洲灰鹦鹉。这种很容易“愚弄”神经网络的样本，被称为对抗样本。</description>
    </item>
    
  </channel>
</rss>