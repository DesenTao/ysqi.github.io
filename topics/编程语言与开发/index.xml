<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go协程与主线程强占运行</title>
      <link>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:49 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</guid>
      <description>最近在学习了go 语言 , 正好学习到了 协程这一块 ,遇到了困惑的地方.这个是go语言官方文档 . 在我的理解当中是,协程只能在主线程释放时间片后才会经过系统调度来运行协程,其实正确的也确实是这样的,但是我遇到了协程强占主线程的一个问题,经过帮助,现在已经了解.废话不多说,先看代码
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { go say(&amp;quot;world&amp;quot;) say(&amp;quot;hello&amp;quot;) /* fmt.Println(&amp;quot;---------------1&amp;quot;) a := []int{7, 2, 8, -9, 4, 0} fmt.Println(&amp;quot;===&amp;quot;, a[:len(a)/2]) c := make(chan int) go sum(a[:len(a)/2], c) go sum(a[len(a)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // receive from c fmt.Println(x, y, x+y) fmt.Println(&amp;quot;---------------2&amp;quot;) c2 := make(chan int, 2) c2 &amp;lt;- 1 c2 &amp;lt;- 2 fmt.Println(&amp;lt;-c2) fmt.Println(&amp;lt;-c2) fmt.Println(&amp;quot;---------------3&amp;quot;) c3 := make(chan int, 10) go fibonacci(cap(c3), c3) for i := range c3 { fmt.</description>
    </item>
    
    <item>
      <title>Gounsafe包</title>
      <link>https://yushuangqi.com/blog/2017/go-unsafebao.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:48 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-unsafebao.html</guid>
      <description>Go unsafe包
unsafe包概述 直到现在（Go1.7），unsafe包含以下资源：
三个函数：
// unsafe.Sizeof函数返回操作数在内存中的字节大小,参数可以是任意类型的表达式,但是它并不会对表达式进行求值. // 一个Sizeof函数调用是一个对应uintptr类型的常量表达式, // 因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量. func Sizeof(x ArbitraryType) uintptr //函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞. func Offsetof(x ArbitraryType) uintptr //unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数. func Alignof(x ArbitraryType) uintptr   内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 和一种类型：
type Pointer *ArbitraryType  这里，ArbitraryType不是一个真正的类型。官方导出这个类型只是出于完善文档的考虑，在其他的库和任何项目中都没有使用价值，除非程序员故意使用它。
 unsafe.Sizeof, Alignof 和 Offsetof  计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
 由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 一个结构体变量 x 以及其在64位机器上的典型的内存. 灰色区域是空洞.
var x struct { a bool b int16 c []int }  对结构体变量的三个字段调用unsafe包相关函数的计算结果如下，</description>
    </item>
    
    <item>
      <title>Go1_8httpgraceful体验</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:47 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</guid>
      <description>很高兴Go 1.8发布了，这是个值得庆祝的日子。
如何优雅的关闭http服务在Go Web开发中一直被提及和讨论的话题，今天Go 1.8的发布终于为我们带来了这个特性。
文档中是这样介绍的：
func (srv *Server) Shutdown(ctx context.Context) error  Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：
 首先关闭所有的监听
 然后关闭所有的空闲连接
 然后无限期等待连接处理完毕转为空闲，并关闭
 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误
  需要注意的是，Shutdown 并不尝试关闭或者等待 hijacked连接，如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。
其实，你只要调用 Shutdown 方法就好了。
简单示例：
// main.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;os/signal&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World, %v\n&amp;quot;, time.Now()) }) s := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: http.</description>
    </item>
    
    <item>
      <title>Go1_8正式发布</title>
      <link>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:46 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</guid>
      <description>今天Go团队很高兴地宣布Go 1.8发布了。你可以从下载页面获得1.8版本。在这个版本中，整个标准库有显着的性能改进和变化。
Go 1.7中为64位x86系统引入的编译器后端现在用于所有体系结构，在这些体系结构下可以看到显着的性能改进。例如，我们的基准程序所需的CPU时间在32位ARM系统上减少了20-30％。在此版本中，对于64位x86系统也有一些性能提升。编译器和链接器跑得更快。编译时间应该比Go 1.7缩短约15％。在这一领域还有更多的工作要做：希望未来版本的编译速度更快。
垃圾收集暂停应明显更短，通常在100微秒以下，通常低至10微秒。
HTTP服务器添加对HTTP/2 Push的支持，允许服务器向客户端推送。这对于消除网络延迟非常有用。 HTTP服务器还添加了对优雅停机的支持，允许服务器完成正在运行的请求之后关闭从而最小化停机时间。
context（添加到Go 1.7中的标准库）提供了取消和超时机制。 Go 1.8在更多的标准库中添加了对context的支持，包括database/sql和net包以及net/http包中的Server.Shutdown。
现在使用新添加的Slice函数使得对slice进行排序更简单。例如，要通过“名称”字段对结构体片段进行排序：
Go 1.8包括很多新增API，以及老API的改进和修复。 你可以在Go 1.8发行说明中查找完整的修改列表，以及有关上面列出内容的详细信息。
为了庆祝新版发布，世界各地的Go用户组都在本周举办发布会。 发布会已经成为Go社区的一个传统，所以如果你错过了这一次，当1.9发布时应该注意了。
感谢超过200个贡献者谁帮助了1.8版本的发布。</description>
    </item>
    
    <item>
      <title>go用slice模拟vector功能</title>
      <link>https://yushuangqi.com/blog/2017/go-yong-slicemo-ni-vectorgong-neng.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:46 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-yong-slicemo-ni-vectorgong-neng.html</guid>
      <description>appendVector ``` - 编程语言与开发 a = append(a, b&amp;hellip;)
 copy ==== ``` - 编程语言与开发 b = append([]T(nil), a...)  ``` - 编程语言与开发 b = make([]T, len(a)) copy(b, a)
 cut删除一段范围i\~j =================== ``` - 编程语言与开发 copy(a[i:], a[j:]) for k, n := len(a) - j + i, len(a); k &amp;lt; n; k++ { a[k] = nil //or the zero value of T } a = a[:len(a) - j + i]  delete删除指定i ``` - 编程语言与开发 copy(a[i:], a[i+1:] a[len(a] - 1] = nil //or zero value of T a = a[:len(a)-1]</description>
    </item>
    
    <item>
      <title>gogrpc安装</title>
      <link>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:45 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</guid>
      <description>Prerequisites Go version gRPC works with Go 1.5 or higher.
$ go version  For installation instructions, follow this guide: Getting Started - The Go Programming Language
Install gRPC Use the following command to install gRPC.
$ go get google.golang.org/grpc  Install Protocol Buffers v3 Install the protoc compiler that is used to generate gRPC service code. The simplest way to do this is to download pre-compiled binaries for your platform(protoc-&amp;lt;version&amp;gt;-&amp;lt;platform&amp;gt;.</description>
    </item>
    
    <item>
      <title>golangappend的并发问题</title>
      <link>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</guid>
      <description>先看一段代码
ackage main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var wg sync.WaitGroup s := make([]int, 0, 1000) for i := 0; i &amp;lt; 1000; i++ { v := i wg.Add(1) go func() { s = append(s, v) wg.Done() }() } wg.Wait() fmt.Printf(&amp;quot;%v\n&amp;quot;, len(s)) }  结果
第一次：928 第二次：945 第三次：986 ……  多运行几次你就会发现，slice长度并不是1000，而是不停的在变，为什么呢？
因为append并不是并发安全的。
我们举一个简单例子，比如，当A和B两个协程运行append的时候同时发现s[1]这个位置是空的，他们就都会把自己的值放在这个位置，这样他们两个的值就会覆盖，造成数据丢失。
那该怎么写？最简单的方式就是用锁，贴一个例子。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var ( wg sync.</description>
    </item>
    
    <item>
      <title>设计模式(golang)</title>
      <link>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</guid>
      <description>设计模式的六大原则 摘自 Java开发中的23种设计模式详解
 1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后 面的具体设计中我们会提到这点。
 2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何 基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受 到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。 实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽 象化的具体步骤的规范。—— From Baidu 百科
 3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
 4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出， 其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
 5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
 6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。
  实现代码 {#h1_1} https://github.com/BPing/golang_design_pattern/tree/master/pattern
 创建型 C 结构型 J 行为型 X   -AbstractFactory.go : 抽象工厂模式(C) -Adapter.go : 适配器模式(J) -Bridge.go : 桥接模式(J) -Builder.</description>
    </item>
    
    <item>
      <title>屌炸天的新版GoGC之twitch的GC优化之路</title>
      <link>https://yushuangqi.com/blog/2017/diao-zha-tian-de-xin-ban-go-gczhi-twitchde-gcyou-hua-zhi-lu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:43 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/diao-zha-tian-de-xin-ban-go-gczhi-twitchde-gcyou-hua-zhi-lu.html</guid>
      <description>此文翻译自：https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7
我们在Twitch使用Go研发了许多高并发的系统。它的简单性，安全性，性能和可读性使其成为解决我们遇到问题的一个很好的工具，我们向数百万用户提供实况视频和聊天服务。
但这不是另一篇关于Go对于我们有多么大作用的文章， 本文是关于我们在使用Go过程中碰到的限制以及我们如何克服这些限制的文章。
Go 1.4和Go 1.6之间Go runtime的改进使我们的垃圾收集（GC）暂停时间缩短了20倍，我们如何在Go 1.6的停顿之上进一步缩小 10 倍的暂停时间，以及如何向Go团队分享我们的案例，使得1.7中不使用我们手动方案的同时停顿时间又降低了10倍。
开始 我们的基于IRC的聊天系统最早是在2013年年底用Go写的，取代了以前的Python实现。使用Go 1.2的预发布版本，它能够在每个物理主机提供超过500,000并发用户，而无需特殊调整。有一组三个goroutine（Go的轻量级执行线程）为每个连接提供服务，程序在每个进程中拥有1,500,000个goroutine。即使有这么大的goroutine数量，我们在使用Go1.2的过程中碰见的唯一性能问题是GC暂停时间，执行GC将冻结我们的应用程序几十秒。
不仅每个GC暂停非常昂贵，GC每分钟运行几次。我们努力减少内存分配的数量和大小，以便将GC运行的频率降低，如果堆每两分钟只增长50％，就意味着分配数量足够低。虽然暂停时间减少，但每一次GC暂停都是破坏性的。
一旦Go 1.2 正式发布，GC暂停时间下降到“仅”几秒钟。我们将流量分散在更大数量的进程中，从而将停顿降低到更容易接受的范围。
随着Go版本增长，减少分配的工作会继续有益于我们的聊天服务器，但是分解聊天进程是一个特定范围的Go版本的解决方案。这样的解决方案经不起时间的考验，但对于为我们的用户提供良好的服务非常重要。分享我们的经验有助于为Go运行时创建持久的改进，从而使单个程序受益。
从2015年8月的Go 1.5开始，Go的垃圾收集器大多数时候是并发和增量的，这意味着在大部分阶段它不需要将应用程序完全停止。除了相对较短的标记和终止阶段，我们的程序可以继续运行，同时运行垃圾回收。升级到Go 1.5立即导致我们的聊天系统中的GC暂停时间的10倍缩小，在重负荷测试实例上的暂停时间从2秒缩短到约200ms。
Go 1.5 GC新纪元 虽然Go 1.5的延迟减少值得庆祝，但新GC的最大意义是它为进一步的增量改进奠定了基础。
Go 1.5的垃圾收集器仍然具有相同的两个主要阶段 -
标记阶段（GC确定哪些内存分配仍在使用），以及扫描阶段（其中未使用的内存已准备好重用） 但是每个阶段都被分成两个子阶段。首先，应用程序暂停，而前一个扫描阶段终止。然后，并发标记阶段在用户代码运行时查找正在使用的内存。最后，应用程序第二次暂停，标记阶段终止。之后，未使用的内存将被扫描，同时应用程序将执行其业务。
runtime的gctrace功能打印每个GC周期，包括每个阶段的持续时间。对于我们的聊天服务器，它表明大部分剩余的暂停时间在标记终止阶段，因此分析将集中在那里。
当然，我们需要更多关于GC在这些暂停期间究竟做了什么的细节。 Go核心包有CPU profiler，同时组合使用Linux的perf工具。使用perf允许使用更高的采样频率和在内核中花费的时间可视化。在内核中使用的监视器可以帮助我们调试缓慢的系统调用，并透明地完成虚拟内存管理。
下面的图片是我们的聊天服务器配置文件的一部分，运行go1.5.1。这是一个使用Brendan Gregg工具制作的火焰图，修剪后只包含在堆栈上具有runtime.gcMark函数的样本，这是Go 1.5在标记终止阶段花费的时间。
火焰图将堆栈深度显示为向上增长，并且将CPU时间表示为每个部分的宽度。 （颜色是无意义的，x轴上的排序也是无关紧要的 - 它只是字母顺序。）在图表的左边，我们可以看到runtime.gcMark在几乎所有的抽样堆栈中调用runtime.parfordo。向上我们看到大多数时间花在runtime.markroot调用runtime.scang，runtime.scanobject和runtime.shrinkstack。
runtime.scang函数用于重新扫描内存以帮助终止标记阶段。标记终止阶段背后的整个想法是完成扫描应用程序的内存。
接下来是runtime.scanobject。这个函数做了几件事情，但在Go 1.5的聊天服务器标记终止阶段运行的原因是实现finalizer。 为什么程序会使用这么多的finalizer，他们为什么会占用这么长GC暂停时间？。有问题的应用程序是一个聊天服务器，同时处理成千上万的用户。
Go的核心“net”软件包附加一个finalizer到每个TCP连接，以帮助控制文件描述符泄漏 并且由于每个用户都有自己的TCP连接，即使每个链接只有一个finalizer，加起来还是很可观。
这个问题似乎值得向Go runtime 团队报告。我们通过电子邮件交流，Go团队对如何诊断性能问题以及如何将它们提炼成最小测试用例的建议非常有帮助。对于Go 1.6，运行时团队将finalizer扫描移动到并发标记阶段，导致具有大量TCP连接的应用程序的暂停时间更短。结合发布中的所有其他改进，我们的聊天服务器在Go 1.6的暂停时间是在Go 1.5的一半左右，在测试实例上降低到大约100ms。
堆栈收缩 Go的并发使启动大量goroutine非常廉价。虽然使用10,000个操作系统线程的程序性能可能很差，但是这个数量的goroutine却很正常。一个区别是goroutine从非常小的堆栈开始 - 只有2kB - 根据需要增长，与其他地方常见的大型固定大小堆栈形成对比。
Go的函数调用前缀确保有足够的堆栈空间用于下一次调用，如果没有，则在允许调用继续之前，将goroutine的堆栈移动到更大的内存区域 - 根据需要重写指针。
因此对一个程序来说，为了支持他们做的最深的调用，其goroutine的堆栈将增长。垃圾收集器的一个职责是回收不再需要的堆栈内存。将goroutine堆栈移动到更适当大小的内存区域的任务由runtime.shrinkstack完成，在Go 1.5和1.6中，在标记终止期间完成。
上面的火焰图，在其样本的3/4左右显示runtime.shrinkstack。如果这项工作可以在应用程序运行时完成，它可以大大加快我们的聊天服务器和其他程序。
Go运行时的包docs解释如何禁用堆栈收缩。对于我们的聊天服务器，相对于浪费内存来说更短暂的暂停时间更容易接受。在禁用堆栈收缩的情况下，聊天服务器的暂停时间再次减少到30到70ms之间。
在保持聊天服务的结构和操作相对恒定的同时，我们忍受了Go 1.</description>
    </item>
    
    <item>
      <title>数据库不适合Docker及容器化的7大原因</title>
      <link>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:42 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</guid>
      <description>导读：所有的服务都开始了容器化升级，在一切皆容器的主流思想下，无状态的服务采用容器化已经是大势所趋，常常困扰架构师的一个问题是，数据库是否需要容器化，本文作者 Mikhail Chinkov 提出了自己否定观点，由高可用架构翻译。

如果我们观察 2017 年技术行业，容器和 Docker 依然将是最热门的流行语。我们开始在每个领域的 Docker 容器中打包开发的软件。从小型初创公司到巨大的微服务平台都在使用容器技术。从 CI 平台到 Raspberry Pi 。从数据库到……
数据库？您确定要将数据库放在容器中吗？
不幸的是，这不是虚构的场景。我看到许多快速增长的项目将数据持久化到容器中。并且将计算服务和数据服务放在同一台机器上。笔者希望有经验的人不会用这个解决方案。
下面是我的观点，数据库容器化从今天来看是非常不合理的。
数据库不适合容器化的7大原因 **
**
1. 数据不安全 
即使你要把 Docker 数据放在主机来存储 ，它依然不能保证不丢数据。 Docker volumes 的设计围绕 Union FS 镜像层提供持久存储，但它仍然缺乏保证。
使用当前的存储驱动程序，Docker 仍然存在不可靠的风险。 如果容器崩溃并数据库未正确关闭，则可能会损坏数据。

2. 运行数据库的环境需求 **
**
常看到 DBMS 容器和其他服务运行在同一主机上。 然而这些服务对硬件要求是非常不同的。
数据库（特别是关系型数据库）对 IO 的要求较高。 一般数据库引擎为了避免并发资源竞争而使用专用环境。如果将你的数据库放在容器中，那么将浪费你的项目的资源。 因为你需要为该实例配置大量额外的资源。 在公有云，当你需要 34G 内存时，你启动的实例却必须开 64G 内存。在实践中，这些资源并未完全使用。
怎么解决？ 您可以分层设计，并使用固定资源来启动不同层次的多个实例。 水平伸缩总是比垂直伸缩更好。 
3. 网络问题 **
**
要理解 Docker 网络，您必须对网络虚拟化有深入的了解。也必须准备应付好意外情况。你可能需要在没有支持或没有额外工具的情况下，进行 bug 修复。</description>
    </item>
    
    <item>
      <title>Go最新的dep详解</title>
      <link>https://yushuangqi.com/blog/2017/gozui-xin-de-depxiang-jie.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:41 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/gozui-xin-de-depxiang-jie.html</guid>
      <description>该文翻译自https://medium.com/i-can-haz-downtime/dep-101-c85e8ab6ed45#.hbngswi0e
我很高兴在过去几个月和几个其他gopher开发的一个原型依赖管理工具，名为dep。
dep是去年开始由Peter Bourgon组织的项目的一部分。由于我参与开发了一个“godep”，Go的OG依赖管理工具（继承自Keith Rarick），因此加入了dep项目的团队。
除了我自己和Peter，团队的其他成员是Jessie Frazelle，Andrew Gerrand和Sam Boyer。 Andrew是Google Go team的一员。 Jessie在Google工作，并参与过大型Go项目，如Docker和Kubernetes。 Sam维护gps。
该团队发布了一系列我们工作过程中的进展信息。到目前为止，各种其他工具作者和相关方也以不同的方式参与这一项目。
起初 假设我们正在使用github.com/gorilla/mux编写一个Web应用程序。 这里是一些代码，让我们开始：
package main import ( &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;github.com/gorilla/mux&amp;quot; ) func main() { r := mux.NewRouter() r.Handle(&amp;quot;/&amp;quot;, http.FileServer(http.Dir(&amp;quot;.&amp;quot;))) http.ListenAndServe(&amp;quot;:&amp;quot;+os.Getenv(&amp;quot;PORT&amp;quot;), r) }  在现有项目上第一次使用dep时，需要运行dep init。
dep init将在GOPATH中已经包含github.com/gorilla/mux，manifest.json文件将包括它。我先运行如下命令：
go get -u github.com/gorilla/mux  所以在我的\$GOPATH中github.com/gorilla/mux的分支是master。如果我的\$GOPATH中的版本匹配Semver tag（例如：v1.2.3），那么将使用该tag的名称。
dep可以跨越架构和go版本。我们可以将github.com/gorilla/mux与旧版本的Go（&amp;lt;1.7.0）的github.com/gorilla/context包结合使用。当我最后运行
go get -u github.com/gorilla/mux  的时候，我运行的是Go 1.7.5，所以github.com/gorilla/context包不在我的\$GOPATH。因为可能是编译项目所需的依赖，它会包含在lock.json文件中。在这种场景下，如果从属项目有一个semver兼容的release tag，dep会选择最新的版本。在这种情况下是github.com/gorilla/context的v1.1。
因为github.com/gorilla/mux不包含manifest.json文件，dep不知道github.com/gorilla/mux目前是否能与github.com/gorilla/context@v1.1配合使用。dep一般使用在依赖的manifest.json文件中找到的约束。
dep init包括所有依赖关系（包括递归依赖）以及在lock.json文件中使用的确切版本。
对于示例应用程序，这将创建以下两个文件：
lock.json
{ &amp;quot;memo&amp;quot;: &amp;quot;d741a3bed21fe6cae9d67c523b0a343859882b2f246f2a293e2676cfacd5a2ce&amp;quot;, &amp;quot;projects&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;github.</description>
    </item>
    
    <item>
      <title>优秀的 Go存储开源项目和库</title>
      <link>https://yushuangqi.com/blog/2017/you-xiu-de-go-cun-chu-kai-yuan-xiang-mu-he-ku.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:40 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/you-xiu-de-go-cun-chu-kai-yuan-xiang-mu-he-ku.html</guid>
      <description>今年谷歌家的 Go 编程语言流行度有着惊人的上升趋势，其发展也是越来越好，因此本文整理了一些优秀的 Go 存储相关开源项目和库，一起分享，一起学习。
存储服务器（Storage Server） Go 实现的存储服务器  minio - Minio 是一个与 Amazon S3 APIs 兼容的开源对象存储服务器，分布式存储方案 rclone - “用于云存储的 Rsync” - Google Drive, Amazon Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Cloudfile… camlistore - Camlistore 是你的个人存储系统：一种存储、同步、共享、建模和备份内容的方式 torus - CoreOS 的现代分布式存储系统 s3git - 云存储的 Git。用于数据的分布式版本控制系统 rook - 开放、云本地和通用的分布式存储  Key-Value 存储（Key-Value Store） Go 实现的 Key-Value 存储  etcd - 可靠的分布式 key-value 存储，用于分布式系统的最关键数据 go-cache - Go 语言实现的一个内存中的缓存框架，实现 Key-Value 的序列存储，适用于单台机器应用程序 biscuit - Biscuit 用于 AWS 基础架构建设时多区域 HA key-value 存储 diskv - 支持磁盘的 key-value 存储  文件系统（File System） Go 实现的文件系统  git-lfs - 用于大文件版本控制的 Git 扩展 seaweedfs - SeaweedFS 是一个用于小文件的简单且高度可扩展的分布式文件系统 fsnotify - Go 实现的跨平台文件系统监控库 goofys - Go 实现的高性能，POSIX-ish Amazon S3 文件系统 go-systemd - systemd 的 Go 语言绑定版（包括socket activation, journal, D-Bus, 和 unit files） gcsfuse - 用于与 Google 云存储交互的用户空间文件系统 svfs - 基于 Openstack 的虚拟文件系统  数据库（Database） Go 实现的数据库  BigCache - 用于千兆字节数据的高效 key/value 缓存 bolt - Go 实现的低层级的 key/value 数据库 buntdb - 一个 Go 实现的快速、可嵌入的 key/value 内存数据库，具有自定义索引和 geospatial 支持的功能 cache2go - key/value 内存缓存，支持基于超时的自动无效功能 cockroach - 一个可伸缩的、支持地理位置处理、支持事务处理的数据存储系统 couchcache - 由 Couchbase 服务器支持的 RESTful 缓存微服务 dgraph - 具有可扩展、分布式、低延迟和高吞吐量功能的图形数据库 eliasdb - 使用 REST API，短语搜索和类似 SQL 查询语言的无依赖性，支持事务处理的图形数据库 forestdb - Go bindings for ForestDB.</description>
    </item>
    
    <item>
      <title>Macgolang下载mgo</title>
      <link>https://yushuangqi.com/blog/2017/mac-golangxia-zai-mgo.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/mac-golangxia-zai-mgo.html</guid>
      <description>mgo是第三方提供的golang连接mongodb的库，使用如下命令，进行下载
go get labix.org/v2/mgo  会出错，说没有安装bzr，bzr是mgo使用的版本控制软件，全名 bazaar，可以在http://wiki.bazaar.canonical.com/Download下载各操作系统的版本。bzr安装好后，执行上述下载命令，可能还是会出错，错误如下
bzr: ERROR: Couldn&#39;t import bzrlib and dependencies. Please check the directory containing bzrlib is on your PYTHONPATH. Traceback (most recent call last): File &amp;quot;/usr/local/bin/bzr&amp;quot;, line 102, in &amp;lt;module&amp;gt; import bzrlib ImportError: No module named bzrlib  上网查了一下是因为bzr使用的是python2.6版本，使用python -V查看本机安装的2.7的版本，需要降版本。
进入/usr/local/bin/目录，使用vi或vim修改bzr文件，修改第一行：#!/usr/bin/python 为 #!/usr/bin/python2.6，保存退出。在使用前面的下载命令，成功下载mgo。由于网速问题，可能要多下几次。</description>
    </item>
    
    <item>
      <title>浅析GO语言中如何优雅地中断定时任务</title>
      <link>https://yushuangqi.com/blog/2017/jian-xi-goyu-yan-zhong-ru-he-you-ya-de-zhong-duan-ding-shi-ren-wu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:38 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jian-xi-goyu-yan-zhong-ru-he-you-ya-de-zhong-duan-ding-shi-ren-wu.html</guid>
      <description>问题描述 现在我们创建了一个定时器，能定时的去做某件事，并且在执行时间超时的时候，能把这个定时器关掉。例如需要收集一周的日志，创建一个定时任务去收集日志，每5秒钟执行一次，一周的时间过后需要停掉这个定时任务。
标准库Ticker 标准库提供里的Ticker类，主要功能是定时重复的去做某件事情，如果没有设定超时，它会一直执行下去。常见的写法如下：
t := time.NewTicker(3 * time.Second) timeout := time.After(10 * time.Second) go func() { for { &amp;lt;-t.C ... } }() &amp;lt;-timeout ...  注意到这个Ticker对象是无法关闭的，好的，你可能会发现Ticker类提供了Stop方法。但是我们看看如果你这样去关闭t的话，会出现什么情况。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func DoTickerWork(res chan interface{}, timeout &amp;lt;-chan time.Time) { t := time.NewTicker(3 * time.Second) go func() { defer close(res) i := 1 for { &amp;lt;-t.C fmt.Printf(&amp;quot;start %d th worker\n&amp;quot;, i) res &amp;lt;- i i++ } }() &amp;lt;-timeout t.</description>
    </item>
    
    <item>
      <title>CMDB发布平台:go发布管理</title>
      <link>https://yushuangqi.com/blog/2017/cmdbfa-bu-ping-tai-gofa-bu-guan-li.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:37 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/cmdbfa-bu-ping-tai-gofa-bu-guan-li.html</guid>
      <description>CMDB发布平台是ezbuy的一个发布管理平台，包含了go的发布，windows serices发布，iis发布，memcache管理，svn管理，资产信息管理操作。
随着公司的业务发展，公司go的服务有100多个单实例，如果多机部署计算，是成倍数增长的，而且每天更新发布的频率高，所以如果人为的去发布，会出现以下问题：
 开发人员每次update服务，都需要找运维人员发布 每次发布，没有版本信息记载，只有相应的版本号，即没有历史数据 重复工作量大，无技术可言，且容易人为发布错误 没有消息通知 开发人员各自在自己电脑上编译，然后提交到svn（环境不统一）  go现在的发布是每次jenkis自动编译通过后，自动上传到svn上，避免编译成mac os版本的go上传到svn，然后通过CMDB平台发布，发布涉及手动和自动发布两个操作：
 手动：开发人员手动通过CMDB平台发布 自动：编译好后，jenkis直接调用CMDB API自动发布到线上（持续CD）  综上问题，CMDB开发了go发布管理模块，模块里包含以下功能：
 部署 发布 更新go配置文件 重启go服务 版本回滚 go服务状态 go crontab发布更新 go cron job定时任务列表  [部署]： 线上运维人员可以通过运维平台直接部署一个新的go服务
go部署
[发布]： 开发人员有权限直接发布服务到线上，无需运维人员干预，且每次发布要填入相应的tower发布url，否则不给予发布
go发布

不管服务成功与否，CMDB会调用钉钉api，将发布结果发送到钉钉消息群，同时CMDB也会保存一份日志到数据库。
go发布消息
[更新go配置文件]： go配置文件我们会单独的将所有go实例的配置文件保存在一个svn库，这样的好处是，有版本控制，避免开发人员人为改动，且敏感信息只有相应权限的人才能查看，所以每次配置文件改表，直接相应有权限的人提交到svn，通过更新go配置文件下发的所有主机：
go下发配置文件
[版本回滚]： 线上运维同学可以通过CMDB平台回滚到相应的版本
[服务状态]： 开发人员可以实时查看go服务运行的状态
[go crontab更新]： 开发人员可以直接发布go的服务
[cron job列表]： 可以在CMDB平台查看所有的cron job和cron job上次执行的时间
最后，我们将会把go的配置文件统一线上线下环境一样，且不暴露敏感信息，敬请关注下一篇《如何利用consul-template保持线上线下配置文件一致》</description>
    </item>
    
  </channel>
</rss>