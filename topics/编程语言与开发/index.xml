<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>如何用Go实现一款类似滴滴优步的网络约车软件(含源码)</title>
      <link>https://yushuangqi.com/blog/2017/ru-he-yong-goshi-xian-yi-kuan-lei-shi-di-di-you-bu-de-wang-lao-yao-che-ruan-jian-han-yuan-ma-.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:25 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ru-he-yong-goshi-xian-yi-kuan-lei-shi-di-di-you-bu-de-wang-lao-yao-che-ruan-jian-han-yuan-ma-.html</guid>
      <description>导读：我们经常使用打车软件出行，也经常思考其架构设计。本文作者在所在国家也负责开发一款打车软件，并且开源了其中大部分代码，可以帮助我们更好了解网络约车软件的架构体系。本文由高可用架构翻译。


各位读者好，本文将给大家分享我们如何通过内存存储实现地图动画车效果。 我们公司也运营了一个类似 Uber 的软件 Namba Taxi，我们需要在客户端主屏幕上显示动画车。 这篇文章是关于功能如何完整实现的文章，主要目的不是介绍 Go 语言。
 开始 
这个故事始于2015年，我们的移动开发人员开发一款软件，工作主题是为出租车司机提供打车服务。 在应用程序中，动画汽车看起来像下面的图中动画那样 [1] 。


我们的第一个挑战是缺乏地图跟踪数据。我们每 15 秒获取一次位置数据。 我们不能简单减小上报间隔，因为当司机端程序上行数据时候，同时需要获取当前订单，下一个订单，以及一些警报功能（一个SOS按钮， 当司机按下它，其他司机就可以帮助他）。当我们减少更新间隔时，系统流量更大。 我们不确认我们是否能够扛住如此大的刷新。
 实现的第一步 
我们第一次的尝试比较简单：

 处理请求并保存坐标。
 创建另一个请求并为汽车设置动画。
  
显而易见，这样做存在一些问题，如大家在一些打车软件所见，我们不能正确地绘制汽车路线，汽车可能跑在田野，森林，湖泊和公寓上，用这种方法后效果看起来是这样的 [2]。


作为问题的解决方案，我们使用 OpenStreetMap Routeing Machine（OSRM）来规划线路并改进我们的算法，并使用相同的超时设置。

 发起请求。
 获取坐标。
 将保存的坐标发送到服务器。
 通过 OSRM 构建路线。
 返回数据到客户端。
  
通过线路规划体系，现在似乎可以工作了，但我们又面临单向道路的问题


例如，司机停留在红点的十字路口。 但他的设备位置准确性有问题，导致数据标记在十字路口的对面。 在客户端，我们获取这些坐标，保存并发送到后端，OSRM 建立一个合法的路线，并返回给应用程序。因为客户端移动得非常快，所以这种情况路线规划很可笑。</description>
    </item>
    
    <item>
      <title>插曲:关于递归</title>
      <link>https://yushuangqi.com/blog/2017/cha-qu-guan-yu-di-gui.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:25 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/cha-qu-guan-yu-di-gui.html</guid>
      <description>1 概述 循环与递归是算法中最常见的控制过程的方法，循环自不必说，只要学过计算机语言，必然都会讲这种控制结构；而对于递归，大家也能写得很漂亮（树算法中和图算法中使用递归的场景也特别多）。
递归的好处也显而易见，代码体积小，容易维护。然而，递归并不是万能钥匙，特别是当运行环境内存空间有限以及要求高性能的场景。下文首先介绍递归的运行原理，然后用实例说明递归的代价，接着讲解递归如何转换成循环及其限制，最后对本文进行总结。
2 递归的运行原理 这里的递归特指递归函数，递归函数在程序中执行的原理是什么（冯诺伊曼体系下）？这是认识递归函数执行效率的关键。下面我们以构建斐波那契数列为例，说明递归函数的执行过程。构建斐波那契数列的递归函数(golang实现)如下：
fun Fib(n int) int{ ret : = 0 if n == 0 || n == 1 { // 1 ret = 1 // 2 } ret = Fib(n - 1) + Fib(n - 2) // 3 return ret }
学过编译原理的童鞋都知道，函数是在栈（对，就是童鞋们在数据结构上学习的栈）上运行的，如果n=4，Fib(4)的原理示意如图1所示：
图1:fib(4)动态示意图
要求fib(4)，必须在栈上求Fib(3)（要求Fib(3),必须再为在栈上求Fib(2)和Fib(1)，要求Fib(2)，在栈上继续求fib(1)和Fib(0)）和Fib(2)（类似fib(3)的过程）。这样的递归算法，必须在栈上记录函内的局部变量、传递参数、返回地址（直到调用结束后回到哪）和上一栈帧的EBP和BP（恢复调用者栈），并且频繁出栈入栈是需要系统开销的，虽然单次入栈出栈开销不大，但是如果要求Fib(1000)这样的函数，恐怕一般的单机估计得跑几十分钟甚至半天了（在笔者的mac本上跑了几分钟都没出来，直接把进程杀了，不能忍）。
为了有个直观的感受，笔者特意做了一个简单的试验（见我的git），分别以递归和非递归求解Fib(10), Fib(20), Fib(30), Fib(40), Fib(50)的运行结果，如下图所示：
图2：递归和非递归试验结果

从运行结果可以看出，当n值较小时（&amp;lt;10）时，递归运行的时间少于非递归运行时间（原因应该是非递归分配slice需要占用相对较长的时间，这种写法有些弱智，其实只需要两个中间变量即可，类似于不用第三个变量实现两变量值交换的思路），当n&amp;gt;=20后，非递归运行时间远低于递归运行时间，n越大，非递归相对递归越高效。
当然，非递归高效运行也不是没有代价的，相比递归函数，编写代码的难度要更高并且更难维护。
3 递归转非递归 那如何将递归函数转换为非递归函数呢？是否所有的递归函数都能换成非递归函数？
首先必须弄清楚递归有哪些种类，递归有两种，一种是单向递归，类似于Fib(n)的这种是一种典型的单向递归（Fib(n)-&amp;gt;Fib(n-1)-&amp;gt;Fib(n-2)-&amp;gt;&amp;hellip;-&amp;gt;Fib(1)）；另一种的递归（不妨称其为交互递归，不一定准确）的形式为：F1(n) -&amp;gt; F2(n) -&amp;gt; F1(n-1) -&amp;gt; F2(n-1) -&amp;gt; &amp;hellip;</description>
    </item>
    
    <item>
      <title>为什么Go语言在中国格外的火</title>
      <link>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:23 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</guid>
      <description>go语言推出有几年了，似乎不温不火。但是在中国范围内，确实被关注的一塌糊涂。
这是2017年2月份TIOBE出的编程语言排名：
在拉勾网上搜索go的职位，结果有119个(2017年2月14日搜索结果)，似乎还没有那么火爆：
但是在中国，很多公司，很多程序员都在谈论go语言，也就是说在中国对于go的关注异常火爆。
根据谷歌搜索的统计，如下图： The graph above shows the searches for “golang” by country on Google Trends.
外国人专门写了一篇文章，来分析为什么go在中国如此火： ( 《Why is Golang popular in China?》)http://herman.asia/why-is-go-popular-in-china
下面是知乎的回复： 作者：匿名用户
链接：https://www.zhihu.com/question/30172794/answer/47122000
来源：知乎 著作权归作者所有，转载请联系作者获得授权。
这个“火”字看你怎么理解了。 Go在国内更火只是感觉上的。比如推文，以及谈论的相关话题较多而已(但能有nodejs多么？)，本身中国人口数量就多，按这个衡量的办法去看的话，swift在国内也比在国外火； 实际上Go在国外更火（这里的火是实际的使用情况），对比一下国内和国外使用Go的程度、数量，Go相关的技术大会举办的频率和数量就一目了然了。
Go在国内真正上被全栈使用的就七牛一家，但国外除了docker，coreOS还有很多初创企业。 国内比较有影响力的就一个beego框架，你看看国外的有多少。
去github上搜一下active的Go的project数量，看看Go在国外是不是没人用？我反正在github的trending里面几乎每天都能看到Go的project。hacker news上面有关Go的“xxx writen in Go”的炒作文也不要太多。 这个 dariubs/GoBooks · GitHub 是有人整理的Go相关的书籍，看看是不是国外的书籍比国内的少？8月份K&amp;amp;R中的K也要推出属于Go的圣经了。
另外老有人喜欢说：Google喜欢关闭产品，这玩意儿迟早死掉。可惜golang是开源项目，关不掉的，CloudFlare那个crypto的patch(Gerrit Code Review)以后可能会进Go的标准库，Godep已经成为事实上的包管理标准，这些都是社区自己搞出来的，和google一毛线关系没有。另外就是最近google自己一些主力产品或者平台在优先支持语言上，Go总是和java，c/c++，python一起名列其中，grpc就是一个例子等等。所以，觉得Go只是google的一个玩具的人，你的观点能不能站得住脚，自己掂量吧。
我的个人观点是： Go显示已经站住了脚跟(如果是2013年，我还是不敢说这种话的)，找到了属于自己的空间，但是比起那些主流的甚至nodeJS来说，还是使用的不够广泛。这个语言人为炒作也罢，一些人认为的google光环也罢，实际使用也罢，总之： 这个语言已经站住脚跟了，能用于并且已经用于生产环境了，接下来几年只会一直呈上升势头。
个人观点：
1 一些真正使用go语言的公司：
这些公司在高速发展的同时，Golang也因此在国内逐渐传播开来。在云计算时代，从国内Go 语言发展和应用来看，七牛算是国内第一家选 Go 语言做服务端的公司。早在2011年，当Go语法还没完全稳定下来的情况下，七牛就已经选择将Go作为存储服务端的主题语言。关于这点，七牛CEO许式伟谈到：编程哲学的重塑是 Go 语言独树一帜的根本原因，其它语言仍难以摆脱 OOP 或函数式编程的烙印，只有 Go 完全放弃了这些，对编程范式重新思考，对热门的面向对象编程提供极度简约但却完备的支持。Go 是互联网时代的C语言，不仅会制霸云计算，10 年内将会制霸整个 IT 领域。
2 在中国程序员眼中，谷歌出品必属精品 确实，在互联网世界，在开源世界，Google为我们贡献了太多太多。</description>
    </item>
    
    <item>
      <title>理解Go语言的nil</title>
      <link>https://yushuangqi.com/blog/2017/li-jie-goyu-yan-de-nil.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:22 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/li-jie-goyu-yan-de-nil.html</guid>
      <description>最近在油管上面看了一个视频：Understanding nil，挺有意思，这篇文章就对视频做一个归纳总结，代码示例都是来自于视频。
nil是什么 相信写过Golang的程序员对下面一段代码是非常非常熟悉的了：
if err != nil { // do something.... }  当出现不等于nil的时候，说明出现某些错误了，需要我们对这个错误进行一些处理，而如果等于nil说明运行正常。那什么是nil呢？查一下词典可以知道，nil的意思是无，或者是零值。零值，zero value，是不是有点熟悉？在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：
bool -&amp;gt; false numbers -&amp;gt; 0 string -&amp;gt; &amp;quot;&amp;quot; pointers -&amp;gt; nil slices -&amp;gt; nil maps -&amp;gt; nil channels -&amp;gt; nil functions -&amp;gt; nil interfaces -&amp;gt; nil  举个例子，当你定义了一个struct：
type Person struct { AgeYears int Name string Friends []Person } var p Person // Person{0, &amp;quot;&amp;quot;, nil}  变量p只声明但没有赋值，所以p的所有字段都有对应的零值。那么，这个nil到底是什么呢？Go的文档中说到，*nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值*，也就是预定义好的一个变量：
type Type int var nil Type  是不是有点惊讶？nil并不是Go的关键字之一，你甚至可以自己去改变nil的值：</description>
    </item>
    
    <item>
      <title>谢孟军:THESTATEOFGO</title>
      <link>https://yushuangqi.com/blog/2017/xie-meng-jun-the-state-of-go.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:22 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xie-meng-jun-the-state-of-go.html</guid>
      <description>本月 17 日，Go 1.8 版本火热发布。相较于以往的版本，Go 1.8 具体有哪些新的特性呢？想必这是不少 Gopher 们热切关注和讨论的问题。作为著名的Golang 布道者，Gopher China 社区创始人，谢孟军早在今年一月的 ECUG Con 上就对 Golang 做出了历史版本的回顾和 1.8 版本的分析，本文就是对他的演讲实录。 Gopher China 社区创始人，著名开源框架 beego 开发者，畅销图书《Go Web 编程》作者，同时有 bat、bee 等开源软件。国内 Go 发展的主要推动者之一。
谢孟军：大家好，我是来自 Apple 的工程师，目前主要在从事工业自动化系统的架构和研发，今天很高兴来到这里跟大家分享一下关于 Go 的一些东西。Go 是 Google 的语言，Go 语言已经出来 6 年了，从 1.0 版本到 1.8 版本，今天最主要是跟大家分享一下 Go 在 1.8 版本中带来了哪些新特性。
Go 回顾 2012 年 3 月 Go 1.0 版本发布，这是一个标志性的事件。很多语言发布出来之后再次升级都会有或多或少不兼容的体验，但是 Go 官方团队在发布 1.0 的时候发布申明，后续的版本保证百分之百向前兼容，他们也遵守了当时的承诺。1.0、1.1、1.2、1.3 一直到 1.7，你的代码如果是 1.0 时候写的，现在升级到 1.7，都可以正常编译。其他语言里面我们可能都会有这样的体验，升级了一个新版本之后，需要花很多时间把代码兼容到新升级的版本中。所以对于一个语言来说，特性稳定是非常重要的。 Go 语言基本上保持了半年发布一个版本的节奏： * 2013年的 5 月份发了 1.</description>
    </item>
    
    <item>
      <title>编写地道的Go代码</title>
      <link>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:58 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</guid>
      <description>在阅读本文之前，我先推荐你阅读官方的 Effective Go文档，或者是中文翻译版: 高效Go编程，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。
最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。
本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。
注释 可以通过 /* …… */ 或者 // ……增加注释， //之后应该加一个空格。
如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。
 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /*Package net provides a portable interface for network I/O, includingTCP/IP, UDP, domain name resolution, and Unix domain sockets....... */ package net......  注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在godoc中容易查找。</description>
    </item>
    
    <item>
      <title>Gonet_http包</title>
      <link>https://yushuangqi.com/blog/2017/go-net_httpbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:57 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-net_httpbao.html</guid>
      <description>Go net/http包
Go Http客户端 get请求可以直接http.Get方法
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;log&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;bytes&amp;quot; ) func main() { resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;) if err != nil { // handle error log.Println(err) return } defer resp.Body.Close() headers := resp.Header for k, v := range headers { fmt.Printf(&amp;quot;k=%v, v=%v\n&amp;quot;, k, v) } fmt.Printf(&amp;quot;resp status %s,statusCode %d\n&amp;quot;, resp.Status, resp.StatusCode) fmt.Printf(&amp;quot;resp Proto %s\n&amp;quot;, resp.Proto) fmt.Printf(&amp;quot;resp content length %d\n&amp;quot;, resp.ContentLength) fmt.Printf(&amp;quot;resp transfer encoding %v\n&amp;quot;, resp.</description>
    </item>
    
    <item>
      <title>Golang学习摘录一:初识</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</guid>
      <description>1、Hello Word编写方式 package main import &amp;quot;fmt&amp;quot; func main (){ fmt.Printf(&amp;quot;Hello, world&amp;quot;) }  编译 go build helloworld.go
运行 ./helloworld
2、声明方式 1、普通方式 var a int = 15 var b bool = false 或 var a int var b bool a = 15 b = false 2、 :=会自动匹配类型，只能在函数内使用 a := 15 b := false 3、中括号的形式： var ( x int b bool ) 4、平行赋值 a,b := 20,16 #注意 :Go 的编译器对声明却未使用的变量在报错。 5、常量，只能是数字、字符串或布尔值 const( // 枚举的生成方式 a = iota // a为0 b = iota // b为1，改行的 “=iota”可省略 ) 如果需要,可以明确指定常量的类型: const ( a = 0 b string = &amp;quot;0&amp;quot; )  3、字符串 var s string = &amp;quot;hello&amp;quot; #Go中字符串是不可变的  如果想修改字符需要使用下面的方法</description>
    </item>
    
    <item>
      <title>Golang语言常用算法</title>
      <link>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</guid>
      <description>在学习golang语言，文档看的实在是乏味，就想着把常用的算法做个实现，边写变学习，想来效果还是不错的！
​1. 堆排序
package main import &amp;quot;fmt&amp;quot; func buildHeap(array []int, length int) { var i, j int; for i = 1; i &amp;lt; length; i = i + 1 { for j = i; j &amp;gt; 0 &amp;amp;&amp;amp; array[j] &amp;gt; array[(j-1)/2]; j = (j - 1)/2 { array[j], array[(j-1)/2] = array[(j-1)/2], array[j] } } } func heapSort(array []int, length int) { array[0], array[length - 1] = array[length - 1], array[0] if length &amp;lt;= 2 { return } i, j:= 0, 0 for { j = 2 * i + 1 if j + 1 &amp;lt; length - 1 { if array[j] &amp;lt; array[j + 1] { j = j + 1 } } else if j &amp;gt;= length -1 { break } array[i], array[j] = array[j], array[i] i = j } heapSort(array, length - 1) } func main() { primes := [6]int{3, 11, 5, 2, 13, 7} fmt.</description>
    </item>
    
    <item>
      <title>Golang学习摘录三:函数</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</guid>
      <description>函数定义 type mytype int // 新的类型 func (p mytype) funcname(q int) (r,s int) {return 0,0}  作用域 在 Go 中,定义在函数外的变量是全局的,那些定义在函数内部的变量,对于函数来说 是局部的。如果命名覆盖——一个局部变量与一个全局变量有相同的名字——在函数 执行的时候,局部变量将覆盖全局变量。
多值返回 func (file *File) Write(b []byte) (n int, err error)
Go得函数可以返回多个值
命名返回值 Go 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像 输入参数那样。如果对其命名,在函数开始时,它们会用其类型的零值初始化。如果 函数在不加参数的情况下执行了 return 语句,结果参数会返回。
例：
func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) &amp;gt; 0 &amp;amp;&amp;amp; err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:len(buf)] } return }  延迟代码defer 在 defer 后指定的 函数会在函数退出前调用。</description>
    </item>
    
    <item>
      <title>Golang学习摘录二:控制语句</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</guid>
      <description>if语句 i f x &amp;gt; 0 { // {是强制的,且必须和if在同一行 return y } else { return x }  if 和 switch 接受初始化语句,通常用于设置一个(局部)变量。
if err := Chmod(0664); err != nil { //nil 与 C 的 NULL 类似 fmt.Printf(err) //err 的作用域被限定在 if 内 return err }  goto语句 用 goto 跳转到一定是当前函数内定义的标签
func myfunc() { i := 0 Here: // 这行的第一个词,以分号结束作为标签,标签名区分大小写 println(i) i++ goto Here // 跳转 }  for语句 Go 的 for 循环有三种形式,只有其中的一种使用分号。</description>
    </item>
    
    <item>
      <title>Golang学习摘录七:并发</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</guid>
      <description>Go使用channel和goroutine开发并行程序。goroutine 是 Go并发能力的核心要素。
goroutine 是一个普通的函数，只是需要使用关键字 go 作为开头。
ready(&amp;quot;Tea&amp;quot;, 2) // 普通函数调用 go ready(&amp;quot;Tea&amp;quot;, 2) // ready() 作为 goroutine 运行  Go routine实践
func ready(w string, sec int) { time.Sleep(time.Duration(sec) * time.Second) fmt.Println(w,&amp;quot;is ready!&amp;quot;) } func main() { go ready(&amp;quot;Tea&amp;quot;, 2) go ready(&amp;quot;Coffee&amp;quot;, 1) fmt.Println(&amp;quot;I&#39;m waiting&amp;quot;) time.Sleep(5 * time.Second) } // 输出 I&#39;m waiting //立刻 Coffee is ready! //1秒后 Tea is ready! //2秒回  如果不等待goroutine的执行（例如移除第17行），程序会立刻终止，而任何正在执行的goroutine都会停止。为了修复使用channels机制来和goroutine通讯。可以通过channel发送或接受值。这些值只能是特定的类型:channel 类型。
注意，必须使用 make 创建 channel：
ci := make(chan int) //创建 channel ci 用于发送和接收整数 cs := make(chan string) //创建 channel cs 用于字符串 cf:=make(chan interface{})//channel cf 使用了空接口来满足各种类型  向 channel 发送或接收数据，是通过类似的操作符完 成的:&amp;lt;−.</description>
    </item>
    
    <item>
      <title>Golang学习摘录五:进阶</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</guid>
      <description>Go 有指针。然而却没有指针运算,因此它们更象是引用而不是你所知道的来自于 C 的指针。指针非常有用。在 Go 中调用函数的时候,得记得变量是值传递的。因此,为了修改一个传递入函数的值的效率和可能性,有了指针。
var p *int fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印nil var i int // 定义一个整型变量i p = &amp;amp;i // 使得p指向i fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印出来的内容类似0x7ff96b81c000a  内存分配 用new分配内存 内建函数 new 本质上说跟其他语言中的同名函数功能一样:new(T) 分配了零值填充 的 T 类型的内存空间,并且返回其地址,一个 *T 类型的值。用 Go 的术语说,它返回 了一个指针,指向新分配的类型 T 的零值。记住这点非常重要。
用make分配内存 内建函数 make(T, args) 与 new(T) 有着不同的功能。它只能创建 slice,map 和 channel,并且返回一个有初始值(非零)的 T 类型,而不是 *T。本质 来讲,导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。 例如,一个 slice,是一个包含指向数据(内部 array)的指针,长度和容量的三项描述 符;在这些项目被初始化之前,slice 为 nil。对于 slice,map 和 channel,make 初始 化了内部的数据结构,填充适当的值。</description>
    </item>
    
    <item>
      <title>Golang学习摘录六:接口</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</guid>
      <description>Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集合。
// 这段代码定义了具有一个字段和两个方法的结构类型s。 type S struct { i int } func (p *S) Get() int { return p.i } func (p *S) Put(v int) { p.i = v } // 定义接口 type I interface { Get() int Put(int) } // 对于接口I，S是合法的实现，因为它定义了 I 所需的两个方法。注意：即便是没有明 确定义 S 实现了 I，这也是正确的。 // Go 程序的特性接口值： func f(p I) {// 定义一个函数接受一个接口类型作为参数 fmt.Println(p.Get()) // p实现了接口I，必须有Get()方法 p.Put(1) // Put()方法是类似的 // 这里的变量p保存了接口类型的值。 } // 调用 var s S f(&amp;amp;s) // 因为S实现了I，可以调用f向其传递S类型的值的指针 // 获取 s 的地址,而不是 S 的值的原因,是因为在 s 的指针上定义了方法,参阅上面的 代码 5.</description>
    </item>
    
    <item>
      <title>Golang学习摘录四:包</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</guid>
      <description>包是函数和数据的集合。用 package 关键字定义一个包。文件名不需要与包名 一致。包名的约定是使用小写字符。Go 包可以由多个文件组成,但是使用相同的 package &amp;lt;name&amp;gt; 这一行。
package even func Even(i int) bool { return i%2==0 } func odd(i int) bool { return i%2==1 }  名称以大写字母起始的是可导出的，可以在包的外部调用。
共有函数的名称以大写字母开头。
私有函数的名称以小写字母开头。
package main import ( //导入下面的包 &amp;quot;event&amp;quot; //本地包even在这里导入 &amp;quot;fmt&amp;quot; ) func main(){ i := 5 fmt.Printf(&amp;quot;Is %d event? %v\n&amp;quot;, i,event.Even(i))// 调用even包中的函数。访问一个包中的函数的语法是&amp;lt;package&amp;gt;.Function()。 }  Go程序的命名规则：包名约定小写字母开头；方法名最好使用驼峰式名称，避免使用下划线，方法名应简洁清晰。
包的文档 每个包都应该有包注释,在 package 前的一个注释块。对于多文件包,包注释只需要 出现在一个文件前,任意一个文件都可以。包注释应当对包进行介绍,并提供相关于 包的整体信息。这会出现在 go doc 生成的关于包的页面上,并且相关的细节会一并 显示。
官方regexp包的例子：
 /* The regexp package implements a simple library for regular expressions.</description>
    </item>
    
  </channel>
</rss>