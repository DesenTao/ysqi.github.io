<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程语言与开发 on 虞双齐的博客</title>
    <link>https://yushuangqi.com/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html</link>
    <description>在 虞双齐的博客上关于in 编程语言与开发 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 13 Jan 2018 08:53:44 +0800</lastBuildDate>
    <atom:link href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>理解以太坊Gas</title>
      <link>https://yushuangqi.com/blog/2018/what-is-gas-ethereum.html</link>
      <pubDate>Sat, 13 Jan 2018 08:53:44 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2018/what-is-gas-ethereum.html</guid>
      <description>背景介绍 以太坊是一个区块链网络，而Ether(ETH)是这个网络的助燃器。当你发送Token、执行合约、转移ETH或者在此区块上干其他的。你必须为此计算而支出，此支出是通过 Gas计算，最终将gas以ETH支付。
需要注意的是，无论交易成功与否，你都需为此支付手续费。即使交易失败，可矿工还是得为此交易进行校验和计算，你占用使用了计算资源所以必须和成功的交易一样，为此支付手续费。
你可在 etherscan.io 上查看交易手续费（gas limit * gas price）的情况，在钱包中你是无法选择多少交易费的，因为实际交易费是矿工根据计算得出的，并记录在包含此交易的区块中。
概要 当你听到gas时，是在讨论两个东西：
 Gas Limit Gas Price  交易费计算就是Gas Limit*Gas Price。大家说“Gas”时，一般所值得是“Gas Limit”
你可以把gas limit看成是汽车所需多少升燃油。把gas price看成是燃油单价。
 对于汽车，每升(unit)汽油 ￥6.46 （price） 对于以太坊,每gas( unit) 是 20 GWEI (price)  继续想，就是：
 10升汽油就是 ￥64.6 21000 个 gas 就是 20*21000 GWEI= 420000 GWEI= 0.00042 ETH  也就是说本次交易手续为 0.00042 Ether。
发送Token一般需要 ~50000 gas 到 ~100000 gas ,因此交易手续费增加到 0.001 ETH - 0.002 ETH。
其中以太坊ETH到GWEI的转换关系是，这些多是以太币的计算单位：
 Kwei(Babbage) = 10^{3} Wei Mwei(Lovelace) = 10^{6} Wei Gwei(Shannon) = 10^{9} Wei Microether(Szabo) = 10^{12} Wei Milliether(Finney) = 10^{15} Wei Ether = 10^{18} Wei  Gas Gas 是以太坊中一种特定的命名，表示执行一个操作所需要的多少计算工作。 比如要执行一次加密Keccak256将消耗30gas。在以太坊中每个操作动作都有对应的gas。更多内容可查看What is gas (StackExchange)。</description>
    </item>
    
    <item>
      <title>理解与计算比特币难度值Difficulty</title>
      <link>https://yushuangqi.com/blog/2017/understand-bitcoin-difficulty.html</link>
      <pubDate>Mon, 25 Dec 2017 07:29:55 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/understand-bitcoin-difficulty.html</guid>
      <description>挖矿实际就是在暴力猜谜，而要猜多少次，全凭全网共识的一个难度值。只有猜出一个数字能使得区块的哈希符合难度，才算答对谜题。
那么这个猜谜游戏由于越来越多人的加入，势必会更快猜出。所以为了维持一个恒定的游戏时间(两周)，每次游戏难度均会根据上次游戏的用时而重新计算。
游戏越来越难，如何抢在别人前面猜出呢？所以开启了抱团团战模式（矿池）加入游戏，使得解谜速度更快也更难。速度与难度总是此消彼长。 这也是为何在2014，2015年后难度值呈几何级数式增长。当然也因解谜的设备（矿机）更新换代越来越快。
比特币难度值Difficulty 难度值在区块中并不记录，仅仅是为了人类直观感受解题难度而演变出的一个浮点数。公式如下： $$ diffculty = \dfrac{difficulty\_1\_target }{ currentTarget} $$
此处的 difficulty_1_target 为一个常数，非常大的一个数字。表示矿池挖矿最大难度。目标值越小，区块生成难度越大。
难度值如何存储在区块中的 在区块中存储的是Target，但是将Target经类似于浮点数的一种压缩表示法，字段为bits。例如，如果区块bits记录为0x1b0404cb，那么他表示的十六进制的Target值为：
0x0404cb * 2**(8*(0x1b - 3)) = 0x00000000000404CB000000000000000000000000000000000000000000000000 在计算时，后面3个字节0x0404cb作为底，前面1字节0x1b表示次方数。具体压缩过程如下：
 将数字转换为256进制数 如果第一位数字大于127(0x7f),则前面添加0 压缩结果中的第一位存放该256进制数的位数 后面三个数存放该256进制数的前三位，如果不足三位，则后面补零  例如，将数字1000压缩，先转换为256进制数
1000 = 0x03 * 256 + 0xe8 * 1 那么是由两个数字构成：
03 e8 第一个数未超过0x7f,则不需填0，但长度两位低于三位，在后面补零，最终表示为：0x0203e800 。
有比如数字 2^(256-32)-1,转换为256进制为：
ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff 第一位已经超过0x7f,前面添加零：</description>
    </item>
    
    <item>
      <title>解析比特币区块</title>
      <link>https://yushuangqi.com/blog/2017/decode-bitcoin-blockchain-with-go.html</link>
      <pubDate>Tue, 12 Dec 2017 06:55:15 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/decode-bitcoin-blockchain-with-go.html</guid>
      <description>在解析前，需要准备比特币区块数据。可在安装比特币QT客户端后，到指定目录下获取。注意不需要全部同步完成，只需要开启同步后，有第一个区块数据即可。文件路径，分别是：
 Mac: $HOME/Library/Application Support/Bitcoin/blocks/blkXXXX.dat Windows: %APPDATA%/Bitcoin/blocks/blkXXXX.dat  通过Go代码的方式，一步一步讲解比特币区块的解析逻辑。
下图是比特币区块数据结构，主要由区块头和交易清单组成。    项 name 字节 用途     神奇数 magic 4 固定为0xD9B4BEF9,作为区块间的分隔符   区块大小 block_size 4 记录当前区块的大小   区块头信息 header 80 记录当前区块的头部信息   交易总数 tx_count 1-9 当前区块所含记录数   交易清单 tx_list * 记录当前区块交易细节    其中，神奇数固定为0xD9B4BEF9，作为区块的分隔标识符。而比特币的交易数据是以128Mb为上限记录在dat文件中的。利用此神奇数和区块大小，可将区块数据读取。
先打开文件blk00001.bat
f, err := os.Open(name) if err != nil { log.Fatal(err) } defer f.Close()  再按分隔符读取区块数据：</description>
    </item>
    
    <item>
      <title>程序员该掌握区块链技术</title>
      <link>https://yushuangqi.com/blog/2017/developer-need-known-blockchain.html</link>
      <pubDate>Sun, 05 Nov 2017 08:24:33 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/developer-need-known-blockchain.html</guid>
      <description>周日，深圳的天气特别适合写文字。所以动笔给程序员们写写区块链，这是一篇动员的积极的文章，区块链会改变你们的思维模式，去实现以往的不可能。 也请你行动起来，花两个小时了解区块链的原理，你会被其巧妙的运作方式所折服，拜倒在中本聪的石榴裙下。
区块链是什么？ &amp;gt;区块链（Blockchain）是由节点参与的分布式数据库系统，它的特点是不可更改，不可伪造，也可以将其理解为账簿系统(ledger)。它是比特币的一个重要概念，完整比特币区块链的副本，记录了其代币（token）的每一笔交易。通过这些信息，我们可以找到每一个地址，在历史上任何一点所拥有的价值。
 区块链是由一串使用密码学方法产生的数据块组成的，每一个区块都包含了上一个区块的哈希值（hash），从创始区块（genesis block）开始连接到当前区块，形成块链。每一个区块都确保按照时间顺序在上一个区块之后产生，否则前一个区块的哈希值是未知的。这些特征使得比特币的双花非常困难。区块链是比特币的核心创新。
 下图是比特币下半年行情，2017年是爆发年，国内9月底一个比特币暴跌到1.6万，而国庆后不久突破4万。
谈论区块链，最好的代表是比特币。这里谈及比特币不是鼓励你去炒币，而是方便说明区块链技术的重要性。
为何程序员应该去了解区块链呢？我将从三个角度聊聊我的看法。
区块链的价值 首先是真正意义的“去中心化”。
中心化对程序员不陌生，怕单机故障所以要搞备机，又分热备，冷备等。为了突破性能瓶颈，又搞分布式，一直在追求去中心化。
哪怕现在互联网让世界平坦，但现在又趋向于中心化。Facebook左右美国总统大选，百度搜索让你进莆田医院，微信不让你逛淘宝。实际我们还是离不开中心化。而区块链技术不一样，会像移动互联一样，改变生活方式。一个任何个体都无法干涉运行的系统，没有国界，24小时运转，永不宕机。
区块链带来的是真正意义上的去中心化，世界更加平坦。
其次是可信任和存在性证明。
当前各种产品设计，系统架构都在考虑不可靠、不可信任问题。分布式要解决一致性问题、证券交易记录归档20年，以方便合规检查、域名需要由域名服务商维护拥有者、产品证书需要时间戳服务器支持等等。
在互联网中没有谁能相信谁，特别是大范围的信任。而区块链技术却巧妙的解决此问题，比特币利用POW工作量证明算法让所有矿工花大量精力竞争解决一道数学难题，解题后其他矿工却可秒级验证其正确性。这就在不可信任的环境中，轻易的验证某一答案，从而确认对方的正确性，不信任环境提供可信任。
另一方面在解题的过程中，派生出另一个价值：存在性证明。区块链技术中是使用密码学知识解决数学难题，一个核心要素是时间戳。解出难题，公布答案的同时，便同时证明了某一事物在某一时间发生的真实性。
而区块链中环环相扣，任何人都难以在去中心化的环境中，篡改数据。除非你能得到全网51%以上同盟军。区块产生时间越长、就越难以篡改，新区块会将强旧区块的不可篡改强度，最终趋向不可篡改。
谁都无法篡改，给可信任提供重要依据，同时给存在性提供可靠证明。利用区块链技术思考产品设计，将是一种新的思维逻辑。
改变金融格局 区块链技术诞生于比特币，比特币是当下区块链最成功的项目。一种无人可敢于的数字货币，不会通货膨胀，不受政府控制。中本聪的初衷也是想改变全球金融模式，不受国家或地区影响，实现资产的安全性和隐秘性。所以区块链首当其冲的是金融领域的实践。
为何中国要禁止比特币，却要发布自己的数字货币，还要不遗余力的推动区块链技术研究。比特币就是区块链平台上一杀手级应用，野蛮成长，必引火烧身。 不管是什么币，只要是基于区块链技术的数字货币，必将改变现有金融格局。有人高兴，有人紧张。区块链技术是无中介的，这使得资金流动更加顺畅。无国界货币，宇宙币。
这都是有利于老百姓的，你的资产不会因国家政治动荡而一夜变白纸，也不会随意贬值，更加无法阻碍你投资全球的折腾。也能极大的缩短资金转移速度，当下跨国转账周期有一个星期，且手续费极高。这在区块链数字货币中，不会存在。
对金融格局的变化时，各国态度的不一致，各国政府必然是需控制本国法定货币地位，这毕竟是政府的命根子。但持乐观态度还积极参与比特币，一般都是小国。因为小国都没有自己的货币，自己的命挂在别人的腰间。所以他们是非常欢迎比特币。所以大概的情况是，大国要消灭比特币，而小国要支持顶起比特币。最终金融格局是，大国没法消灭比特币，还越打击越顽强。只能是监管安抚，可以在本国做小弟，但不能取代我做大哥。
程序员是天然的跟随者 实际也是如此，比特币一直在极客间盛行，美味无比。金融从业者都很难看懂为何比特币那么火，还越打击越坚强。我认为最重要的一点是，每次高调打击，实际是在提高比特币的知名度。大量新的人员开始去了解比特币，而从中不乏好奇心强的程序员。
程序员比普通人的优势是能深入代码层看懂原理，无需金融知识背书，花一天时间便可了解其原理。会发现区块链技术真他妈是天才创意，以最简单粗暴的方式解决了程序员曾遇到过的各种难题。
当程序员能看到区块链技术的价值，能清楚比特币的前景时，必然会成为区块链的跟随者，宣传者。区块链技术应用也会愈加普及，程序员艺术性创造生活。为何华尔街的大佬批判比特币，而交易员却大肆参与比特币交易。肤浅的看是交易员有计算机背景，能看得更加深入，能清楚区块链背后所能代表的实际意义。
引发新的技术革命 如前所说，去中心化、可信任、可证明存在性。必然引起新一轮技术革命。现在我们花大量时间在解决网络的不安全、不稳定、不健壮等系列问题，而当下却横空跳出了区块链技术，一种糅合了现有成熟技术的组合，却天马行空般的解决了网络难题。
有了这份药方，什么病都能治。活跃在产品一线、创业一线的朋友，在看懂区块链后，将给你带来巨大的认知性挑战，以前不可能的现在可成为可能。区块链技术给你现在所困惑的问题提供了一扇新的窗户，新的思维模式。
从此你不需要证明你妈是你妈，世界趋向真实的平坦。而对程序员来说，关注业务本身的实现才是你该花时间做的事情，借助区块链去实现曾经的不可能！
错过了移动互联网，云计算。而当下热火的大数据、人工智能已在进行时。唯独区块链技术还在调研尝试中，程序员不入红海谁入红海。
那么程序员如何开始了解区块链技术，这里我把我的学习路线图给你知乎-比特币是什么，从此区块链大军中多了一个你！</description>
    </item>
    
    <item>
      <title>Docker使用问题集</title>
      <link>https://yushuangqi.com/blog/2017/use-docker-question-answer.html</link>
      <pubDate>Wed, 11 Oct 2017 07:11:07 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/use-docker-question-answer.html</guid>
      <description>接触Docker时间不长，折腾不少。实际上Docker还是蛮简单的，基于Go开发，容器化资源。
第一次创建镜像过程中遇到些问题，我在这里记录，希望能帮助到别人和自己。
国内如何加速拉取Docker镜像 通过 Docker 镜像加速，国内能够快速访问最流行的 Docker 镜像。国内用户现在将会享受到更快的下载速度和更强的稳定性，从而能够更敏捷地开发和交付 Docker 化应用。
 Docker官方提供的加速器 DaoClund提供的加速器，需注册 Aliyun 提供的加速器，需注册，适合在阿里云购买的服务器使用。  Docker-runc not installed on system CentOS通过命令安装Docker时，并没有安装完整。一般在重新安装Docker后出现该问题。 只运行某镜像时，出现如下错误信息：
docker run docker.io/ysqi/gotestreport /usr/bin/docker-current: Error response from daemon: shim error: docker-runc not installed on system. 咋回事？原本好好的怎么就出问题了？原来是命令卸载Docker并没有卸载干净，导致重装或更新Docker后出问题。
这个在红帽上有一个Issue：https://access.redhat.com/solutions/2876431 有说明此问题，暂时只能是新建一个link到最终版本：
cd /usr/libexec/docker/ ls -all sudo ln -s docker-runc-current docker-runc  Jenkins: Can&amp;rsquo;t connect to Docker daemon 当Jenkins的Pipeline基于Docker运行时，提示此错误信息：
 Cannot connect to the Docker daemon. Is the docker daemon running on this host?</description>
    </item>
    
    <item>
      <title>区块链比特币学习路线与资源</title>
      <link>https://yushuangqi.com/blog/2017/qukuailian-bitebi-xuexi-luxian-ziyuan.html</link>
      <pubDate>Mon, 18 Sep 2017 12:02:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/qukuailian-bitebi-xuexi-luxian-ziyuan.html</guid>
      <description>小编研究比特币一段时间，入门不易，没有学习线路图。故将小编学习比特币和区块链的学习路线和相关资源整理提供给大家，值得收藏。 注意：某些网站也许得翻墙。
比特币-基础篇 比特币实际是一个去中心化的共识网络，可看作在云端的账簿，但此云是任意一人都可加入的环境，一帮子人共同维护一个账本。 比特币他爹是中本聪，2008年中本聪在邮件组中抛出了一份点对点的电子现金交易系统白皮书，同时他也着手开始技术实现。从比特币白皮书：一种点对点的电子现金系统开始了解比特币技术与原理。文中所谈及比特币术语在比特币官网有简介。
技术小白不要看直接看白皮书，学习任何技术应该从官网开始，而比特币官网所提供的中文资料对小白来说完全够用。到官网看关于比特币的常见问题。可直接看莱特币矿池创始人江卓尔关于“比特币是什么&amp;ldquo;的知乎回答(赞超11K，收藏超24K)。
比特币引入一重量级角色：挖矿，比特币是被矿工算出来的， 什么是挖矿？小白先看巴比特CEO的一篇文章：什么是比特币挖矿，不过瘾则看技术文章比特币挖矿原理。
比特币劈荆斩刺，从2008年论文，到2009年1月比特币网络上线，再到2017年连中国大妈开始入场，跌宕起伏。在批评怀疑中壮大，关于比特币的看法各有不同，可从几篇文章中了解一二：美银美林详解比特币六大优缺点、区块链信息越来越大怎么办、8年后，你还买得起一个比特币吗、如何看待比特币、如何看待2017年9月监管管当局决定关闭中国境内虚拟货币交易所关闭、百度搜索“如何看待比特币”。
比特币-进阶 上面仅仅是一些基本概念，但中本聪所设计的比特币是基于P2P对等网络技术和密码学原理。对于技术控，强烈建议程序员了解比特币背后的原理，先从一个故事感性比特币的原理及运作机制，再看白话版解释比特币原理，另外提供张信息图了解比特币工作原理。最后从从技术上了解比特币，推荐给开发人员的三份信息：动手写项目上深入浅出比特币、比特币是如何运行的、再动手写个Demo50 行 Python 代码构建一个区块链。
小白们不急，这样有一份万向区块链实验室提供动画视频讲解什么是区块链的共识机制。而各位程序猿们，写代码前先了解下比特币的三大技术基石：密码学、p2p网络和共识机制。先浅谈比特币共识机制，而比特币一笔交易需1小时后才能稳定，为提高交易速度，而一帮不安分的人提出了闪电网络以满足及时支付。需要一小时稳定的原因是因为比特币中的存储为区块+链的模式，而每10分钟才生成一个区块，每区块最多1M，如何让一个区块包含更多的交易，如何加快交易确认速度便是2013年来一直想解决的问题，那什么方案嗯？不同利益方能接收的方案各不相同，而一直拉锯这扩容之争。先来一发5分钟读懂区块链扩容之争，争论之久，足已写本比特币扩容简史。
扩容意味修改代码，认同方升级程序即可，而反对方也许就不升级了。那问题来了，会出现分叉吗？先搞懂区块链的硬分叉和软分叉，也许扩容边会导致分叉，来看看吃瓜群众的各路看法：【比特币扩容与分叉】比特币将顺利扩容还是走向分裂。
比特币不是120%的完美，催生了不少改进版的比特币，俗称竞争币(莱特币、以太坊等)。那么如何让不同币直接进行价值置换呢？2014年一篇关于论文首次提出侧链的概念，中文版比特币侧链白皮书见：百度百科，但更推荐看英文版白皮书。
比特币-交易 看到比特币的美好，手痒想亲自动手试试？在2017年09月18日1个比特币价格￥21,500。我穷，我买不起一个币呀！不担心，至少可以买0.00000001个比特币的。如何进行交易呢？先看官网的推荐，可选择交易所进行，后续小编再另外写文章分享如何进行比特币交易。
说完比特币，在说神奇的区块链技术。
区块链-基础 一直在谈比特币，实际很多内容便涉及区块链。中本聪为涉及安全可信任的比特币而提出了一种由多想技术组合而成的新技术”区块链“，巴比特对什么是区块链的解释非常到位，而一位区块链新生意见领袖暴走恭亲王龚明也提供了不一样的见解。
虽然区块链源于比特币，但区块链的应用不止于此。出现了更多的改进版加强版比特币，具体看看区块链发展史&amp;gt;。区块链技术会如何发展？看看虎嗅网这篇译文区块链的真相。
区块链-深入理解 程序猿有必要深入了解区块链技术！有必要！有必要！有必要！
比特币和区块链是信息技术发展的产物，而只有懂编程的人员才能深入代码层了解区块链了解比特币。当深入了解时，才能发现比特币的美！
当发现其中的美，及时你不懂经济学也能看到因为比特币而发生的金融变革。也许比特币会被替代，但后续任何形式的数字货币必将基于区块链技术。互联网技术带来的是信息革命，区块链技术将带来金融革命。
如果你深入了解区块链，便会认同我的观点。不是比特币解决了中心问题、信任问题而应是区块链技术赋予了比特币特性。基于成熟的现有技术和加入巧妙的Pow共识算法而形成了区块链技术。其中技术点包括密码学、分布式共识和p2p网络通信技术。
1、密码学
区块链技术中利用哈希算法中的非对称加密算法-椭圆曲线密码学(ECC)作为基础，实现内容的不可篡改保证其安全性。这里ECC实际是一种非对称加密算法，知乎好友这里有用通俗易懂的话来解释非对称加密，当然非对称加密算法有多种，如RSA，知名博主阮一峰老师有讲解RSA算法原理两篇。
非对称加密是在对称加密算法上进行改进的，一篇白话解释对称加密算法vs非对称加密算法。常见的对称加密算法有DES、AES、RC4等。
一群密码朋克研究贡献各类密码学知识，而自70年代到如今百花齐放的分布式系统中一致性问题的发展和演化，却给区块链技术可远行的翅膀。
2、分布式一致性共识
分布式系统如何保持一致性，贯穿整个分布式发展史，而在在1982年Leslie Lamport与另外两人提出了一个著名的问题：拜占庭将军问题，描述的是如何达成进攻一致性，延伸到分布式领域，是了不起的共识问题讨论，如何在分布式系统达成共识？
自1982年后，不少科学家提出了拜占庭问题的不同解法，Lamport也于1998年发表该问题的第一个算法论文Paxos,阿里团队贡献了中译版论文。 Lamport在2011年重新整理，重新发布该论文，题为Leaderless Byzantine Paxos，而他觉得同行无法接受他的幽默感，于是有用容易接受的方法重新表述了一遍，题为Paxos Made Simple。到底啥是Paxos,请看知乎回答：如何浅显易懂地解说Paxos算法，有梯子的可看维基百科。
因为Paxos算法过于复杂，直到2014年斯坦福两位博士生围绕此发表博士学位论文提出了Raft算法，力求得到一个正常智商的大学生都能看懂，且工程上也容易实现的分布式系统一致性算法为目标。InfoQ有一篇高质量Raft论文中译版内容。这里再提供一份动画版演示Raft算法流程。
分布式的一致性难以解决，在仅50年的研究中发展出三个观点成为分布式的三项重要定理：FLP不可能性原理，篇二、事务处理中的ACID原则以及CAP原理。关于分布式可再看看分布式系统原理：困难与不可能性。
分布式处理如此困难，而比特币设计者中本聪却巧妙地提出了另一种解法，漂亮至极。在比特币中使用Pow工作量证明算法简化拜占庭问题模型。Pow是实现零工作量证明的，即证明者在不向验证者提供任何有用的信息的前提下，使验证者相信某个论断是正确的。每个将军基于工作量证明，解决一个难度适当的Hash难题，每个难题有足够的难度，仅当在所有的将军同时工作时，平均10Mins会找到一个难题的答案（solution）。当一个将军找到问题的答案，它会把这个答案连同攻击计划在网络中广播。一旦收到Solution，每个将军调整难题为在广播中收到的攻击时间，攻击计划。
然而Pow需要不断消耗CPU资源、电能以求快速找到答案。2012年开发者Sunny King 首次提出了Pos（权益证明）概念，Pos相对于POW是种完全不一样的机制，Pos不需要大量的算力来维持网络安全，只是需要每个参与者打开自己的钱包在线增加网络权重，同时获取相应的奖励，也就是Pos机制本身所说的利息。
后面不安分的社区，又提出了改进版的Pos，名为DPOS(委托权益证明)。
3、p2p网络
在去中心化的比特币系统中，全网各个节点通讯是基于p2p点对点对等网络。不存在中心节点，每个节点同时担任客户端和服务端角色。
从此比特币无国界，活生生的一只打不死的小强。
资源集合 官网告诉你比特币入门，看完此文，必然清楚如何开始比特币交易，同时另一个网站可以不基于交易所也看在市场上直接买入别人的比特币，类似于58同城的二手交易。
电子书：  《精通比特币》 《区块链技术指南》  中文比特币资讯网站与论坛 国内比特币发展迅速，有几个做得不错的资讯网站推荐给大家。 + 巴比特,国内早先的比特币内容制作者，所提报的内容值得一看。力建。 + 比特币中文网,纯粹的比特币资讯网站 + 搜搜比特网，同样是比特币资讯网站，当流量量非常高。
当然还有很多，但关注前面几个网站完全够用。
查看行情 想关注比特币行情？现在没有特别推荐，也行国内将无法查看行情，也行你得翻墙！</description>
    </item>
    
    <item>
      <title>Mac下搭建以太坊私有链</title>
      <link>https://yushuangqi.com/blog/2017/setup-ethereum-private-network-on-mac.html</link>
      <pubDate>Sat, 09 Sep 2017 10:22:26 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/setup-ethereum-private-network-on-mac.html</guid>
      <description>在熟悉了解以太坊Ethereum时，为加快测试和掌握。在本机搭建私有链环境是必须的。 小编摸索一段时间，总算了解到以太坊的总体运行环境。下面以go-ethereum和以太坊钱包为例，详细步骤记录如何在Mac下搭建以太坊私有链运行环境。
配置前环境准备 安装以太坊客户端 实际以太坊运行有多个不同语言实现的客户端，是多样的。可为不同用户选择他们所熟悉的客户端。
   客户端 开发语言 开发者     go-ethereum Go 以太坊基金会   Parity Rust Ethcore   cpp-ethereum C++ 以太坊基金会   pyethapp Python 以太坊基金会   ethereumjs-lib Javascript 以太坊基金会   Ethereum(J) Java ether camp   ruby-ethereum Ruby 国人Xie Jan   ethereumH Haskell BlockApps    因为以太坊客户端以 go-ethereum 为主，故搭建私有链也使用该客户端。
 Mac OS X上安装说明 Windows 上安装说明  在Mac上安装细节如下： 在使用brew前，需自行安装brew软件管理工具(http://brew.</description>
    </item>
    
    <item>
      <title>Golang Generate命令说明与使用</title>
      <link>https://yushuangqi.com/blog/2017/go-command-generate.html</link>
      <pubDate>Mon, 14 Aug 2017 18:52:10 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-command-generate.html</guid>
      <description>前期有专门利用go generate自动生成Go代码，今日在查看Go源代码时发现有大量使用此命令已生成各类代码。故在此特写文章说明generate命令的神奇之处。
命令诉求 通用计算有一特性——图灵完备。是一个计算机程序能编写一个计算机程序。既能写程序的程序。按规则定义描述内容，则可以根据描述生成程序代码。10年时刚做项目便以增删改查为主，代码生成器生成代码那是杠杠的。
通过定义便可高效生成代码，无需手工编码。如当定义一个枚举后，为了打印友好内容，我们经常手工定义String方法。
type Status int const ( Offline Status = iota Online Disable Deleted ) var statusText = []string{&amp;#34;Offline&amp;#34;, &amp;#34;Online&amp;#34;, &amp;#34;Desable&amp;#34;, &amp;#34;Deleted&amp;#34;} func (s Status) String() string { v := int(s) if v &amp;lt; 0 || v &amp;gt; len(statusText) { return fmt.Sprintf(&amp;#34;Status(%d)&amp;#34;, s) } return statusText[v] } 当遇到枚举调整时，则必须要再同步修改statusText，而此事常容被忽视。
Generate命令说明 早在Go1.4版本实现，所以你现在可以看到Go源码中大量含有的该命令使用。
如：在unicode包中生产Unicode表，为encoding/gob创建有效的编解码方法，在time包中创建时区数据等等
go generate用于一键式批量执行任何命令，创建或更新Go文件或者输出结果。
Generate 命令和其他go build、go get、go test等没半毛钱关系。需特定执行，命令如下：
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.</description>
    </item>
    
    <item>
      <title>Go读取通达信历史日线数据</title>
      <link>https://yushuangqi.com/blog/2017/go-du-qu-tong-da-xin-li-shi-ri-xian-shu-ju.html</link>
      <pubDate>Wed, 26 Jul 2017 10:32:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-du-qu-tong-da-xin-li-shi-ri-xian-shu-ju.html</guid>
      <description>突然间想使用Go从通达信读取A股历史行情信息，其实也蛮简单的。从通达信获取数据难点在于分析数据结构，而读取则各类语言分分钟搞定。
准备工作  下载安装通达信,通达信官网 下载历史行情数据  下载操作路径：系统-&amp;gt;盘后数据下载
下载后数据按股票市场分别存放：
 上海交易所：{通达信安装目录}\vipdoc\sh\lday\*.day 深圳交易所：{通达信安装目录}\vipdoc\sz\lday\*.day  通达信历史日线数据文件格式 每只股票一个day文件，如：sh000001.day。文件中每一天数据总共32字节。其中每32字节数据格式如下：
   数据含义 数据类型 数据长度 举例 单位     日期 Integer 4 20170703    开盘价 Integer 4 2476 当前值/100,元   最高价 Integer 4 2520 当前值 /100,元   最低价 Integer 4 2436 当前值 / 100,元   收盘价 Integer 4 2457 当前值 / 100,元   成交金额 single 4 1317335898 元   成交量 Integer 4 45293799 股   保留 Integer 4      注意，因为价格均是两位小数，故文件中的价格放大100倍，以便按数字存储。</description>
    </item>
    
    <item>
      <title>Go面试题答案与解析</title>
      <link>https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html</link>
      <pubDate>Thu, 20 Jul 2017 12:58:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html</guid>
      <description>昨天AstaXie发布GoCN每日新闻(2017-07-19)含一篇Go面试题。阅读和评论量挺高，是测试面试者对Go本身基础概念理解掌握程度，以及Go实战经验。这也是在Go中容易遇到的坑，我也曾遇到过。于是快马加鞭，抢在原作者前发布Go面试题答案和解析说明，供大家参考。如有错误请指出，谢谢。
1、写出下面代码输出内容。 package main import ( &amp;#34;fmt&amp;#34; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(&amp;#34;打印前&amp;#34;) }() defer func() { fmt.Println(&amp;#34;打印中&amp;#34;) }() defer func() { fmt.Println(&amp;#34;打印后&amp;#34;) }() panic(&amp;#34;触发异常&amp;#34;) }  在线运行
答： 输出内容为：
打印后 打印中 打印前 panic: 触发异常 解析：
考察对defer的理解，defer函数属延迟执行，延迟到调用者函数执行 return 命令前被执行。多个defer之间按LIFO先进后出顺序执行。
故考题中，在Panic触发时结束函数运行，在return前先依次打印:打印后、打印中、打印前 。最后由runtime运行时抛出打印panic异常信息。
需要注意的是，函数的return value 不是原子操作.而是在编译器中分解为两部分：返回值赋值 和 return 。而defer刚好被插入到末尾的return前执行。故可以在derfer函数中修改返回值。如下示例：
package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(doubleScore(0)) //0 	fmt.Println(doubleScore(20.0)) //40 	fmt.</description>
    </item>
    
    <item>
      <title>gRPC服务发现&amp;amp;负载均衡</title>
      <link>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</guid>
      <description>gRPC服务发现&amp;amp;负载均衡  构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：
 1、集中式LB（Proxy Model） 在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：
 单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；
 服务消费方、提供方之间增加了一级，有一定性能开销。
  2、进程内LB（Balancing-aware Client） 针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：
 开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；
 另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。
  3、独立 LB 进程（External Load Balancing Service） 该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。
不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。 该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。
gRPC服务发现及负载均衡实现 gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。
其基本实现原理：
 服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。
 客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。
 负载均衡策略为每个服务器地址创建一个子通道（channel）。
 当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。
  根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：
1）命名解析实现：resolver.go
package etcdv3 import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; etcd3 &amp;quot;github.com/coreos/etcd/clientv3&amp;quot; &amp;quot;google.golang.org/grpc/naming&amp;quot; ) // resolver is the implementaion of grpc.naming.Resolver type resolver struct { serviceName string // service name to resolve } // NewResolver return resolver with service name func NewResolver(serviceName string) *resolver { return &amp;amp;resolver{serviceName: serviceName} } // Resolve to resolve the service from etcd, target is the dial address of etcd // target example: &amp;quot;http://127.</description>
    </item>
    
    <item>
      <title>Caddy新兴的web服务器caddy</title>
      <link>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</guid>
      <description>caddy 是一个像 Apache, nginx, 或 lighttpd 的web服务器。
你要问nginx已经很好了，为什么要用caddy呢? 我觉得caddy最大的特点是用起来简单，
然后呢，它还有下面这些开箱即用的特性:
 HTTP/2 全自动支持HTTP/2协议，无需任何配置。
 Auto HTTPS Caddy 使用 Let&amp;rsquo;s Encrypt 让你的站点全自动变成全站HTTPS，无需任何配置。当然你想使用自己的证书也是可以的。
 Multi-core 因为caddy是golang写的，所以当然可以合理使用多核啦。
 IPv6 完全支持IPv6环境.
 WebSockets Caddy 对WebSockets有很好的支持.
 Markdown 自动把md转成 HTML ，当然，我后续要给大家介绍更强大的hugo来干这个事情.
 Logging Caddy 对log格式的定义很容易，更好的满足你日志收集的需求。
 Easy Deployment 得益于go的特性，caddy只是一个小小的二进制文件，没有依赖，很好部署。
  那么在什么场景下适合尝试使用caddy呢，我推荐从以下场景开始：
 作为静态页面的webserver
 转发 fastcgi 请求到 php-fpm 服务，比如替换apache或nginx作为wordpress的server
 反向代理，管理多个站点
 微服务的 API gateway ，我会专门写一篇文章。
 有些在nginx上难以开发的需求，为caddy写插件太方便了。
  入门 安装caddy  下载 caddy</description>
    </item>
    
    <item>
      <title>redigo连接池代码分析</title>
      <link>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</guid>
      <description>结构体分析 type Pool struct { // 用来创建redis连接的方法 Dial func() (Conn, error) // 如果设置了给func,那么每次p.Get()的时候都会调用改方法来验证连接的可用性 TestOnBorrow func(c Conn, t time.Time) error // 定义连接池中最大连接数（超过这个数会关闭老的链接，总会保持这个数） MaxIdle int // 当前连接池中可用的链接数. MaxActive int // 定义链接的超时时间，每次p.Get()的时候会检测这个连接是否超时（超时会关闭，并释放可用连接数）. IdleTimeout time.Duration // 当可用连接数为0是，那么当wait=true,那么当调用p.Get()时，会阻塞等待，否则，返回nil. Wait bool // 读写锁控制. mu sync.Mutex // 用来条件控制，这里主要是当链接被关闭时，提醒在等待的进程可以使用了，或者可以自行创建了 cond *sync.Cond // 当前连接池是否已经关闭 closed bool // 当前可用的链接数 active int // 链接存储在一个栈中. idle list.List }  连接池关闭方法 func (p *Pool) Close() error { p.mu.Lock() // 获取连接池所有链接栈 idle := p.</description>
    </item>
    
    <item>
      <title>ngrok从服务端跟踪所有HTTP请求并回放</title>
      <link>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</link>
      <pubDate>Wed, 24 May 2017 09:17:34 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</guid>
      <description>客户端工程师：“xxx 接口坏了，我的程序都没动过”，后端经常会收到这样的质问，但是我们现在如何重现这个问题？有以下几种情况：
一、后端测试了一下发现没有问题
“我这里测试了是好的啊”，就只能让客户端工程师再操作一遍，亲眼看到错误之后就肯定是有问题了，就得去找问题，这时候这台手机，以及这台手机里面的数据都非常重要，因为这些数据可以让 Bug 重现。
二、测试了也有问题
这时候后端就去修改程序了，但是每一次的测试是否有问题都需要在客户端中操作，有时候的操作非常的复杂，在这上面花的时间会比较多。最后使了各种神通才终于找到问题，原来是这个用户的某某数据有异常才会出现这种情况。
以上这种情况屡见不鲜，最麻烦的点就在于，每次都要以出现 Bug 的相同参数去请求，有时候你知道这些请求的参数，可以把它们放到 Postman 这种工具里面，但大部分时候你并不知道它对应的参数 (token)
如果我们可以在服务端跟踪所有的请求：接口地址，Header，Body，后端返回的 Header、Body，这样我们就能查到对应的请求参数和返回值，可以直接填到 Postman 里面，要是还能一键重新请求就好了，因为我们不想修改请求的参数，只是想再以相同的参数请求一遍，这样我们来调试对应的程序。
正好以前用过 ngrok，发现它有一个非常好的 debug 界面，可以达到以上的要求，但现在不需要它的内网穿透功能，于是只能自己写一个程序，只包含以下功能：
 记录接口所有的 Request 和 Response
 可以一键重新请求某个 Request
  基本工作原理
HTTP 客户端 Boast Web 服务器 | GET http://localhost:8080/ | 记录请求并进行反向代理 | Response 200 OK | ---------------------------&amp;gt; | --------------------------&amp;gt; | ------┐ | | | | | | 记录返回信息并转发给客户端 | &amp;lt;----┘ | &amp;lt;--------------------------- | &amp;lt;-------------------------- | ┌----------------------------------------------------------------------------┐ | url: http://localhost:8081 | | ---------------------------------------------------------------------------| | All Transactions ┌ - - - - - - - - - - - - - - - - - - - - - - - ┐ | | ---------------------- | time: 10 hours ago Client: 127.</description>
    </item>
    
    <item>
      <title>协作式go程</title>
      <link>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:33 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</guid>
      <description>协作式go程 为什么要协作式go程 考虑如下开发框架，一组网络接收goroutine接收网络包，解包，然后将逻辑包推送到消息队列，由一个单一的逻辑处理goroutine负责从队列中提取逻辑包并处理(这样主处理逻辑中基本上不用考虑多线程竞争的锁问题了)。
如果逻辑包的处理涉及到调用可能会阻塞的函数调用怎么办，如果在处理函数中直接调用这样的函数将导致逻辑处理goroutine被阻塞，无法继续处理队列中被排队的数据包，这将严重降低服务的处理能力。
一种方式是启动一个新的go程去执行阻塞调用，并注册回调函数，当阻塞调用返回后将回调闭包重新push到消息对列中，由逻辑处理goroutine继续处理后续逻辑。但我本人不大喜欢在逻辑处理上使用回调的方式(node的callback hell)。我希望可以线性的编写逻辑代码。
为了实现这个目的，我需要一个类似lua的单线程协作式coroutine调度机制，单线程让使用者不用担心数据竞争,协作式可以让coroutine在执行异步调用前将执行权交出去，等异步结果返回后再将执行权切换回来，线性的执行后续代码。
但是，goroutine天生就是多线程调度执行的，有办法实现这个目标吗？答案是肯定的。
我们可以实现一个逻辑上的单线程，从全局上看，只有唯一一个goroutine可以执行逻辑处理代码。核心思想就是由调度器从任务队列中提取任务，挑选一个空闲的goroutine,将其唤醒并让自己阻塞，当goroutine需要阻塞时就唤醒调度器并将自己阻塞。这样全局上就只有唯一的goroutine在执行逻辑代码。
下面是一个使用示例：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; &amp;quot;coop-go&amp;quot; ) func main() { count := int32(0) var p *coop.CoopScheduler p = coop.NewCoopScheduler(func (e interface{}){ count++ if count &amp;gt;= 30000000 { p.Close() return } //调用阻塞函数 p.Call(func () { time.Sleep(time.Millisecond * time.Duration(10)) }) //继续投递任务 p.PostEvent(1) }) for i := 0; i &amp;lt; 10000; i++ { //投递任务 p.PostEvent(1) } p.Start() fmt.Printf(&amp;quot;scheduler stop,total taskCount:%d\n&amp;quot;,c2) }  首先用一个任务处理函数作为参数创建调度器。然后向调度器投递任务触发处理循环，最后启动处理。</description>
    </item>
    
  </channel>
</rss>