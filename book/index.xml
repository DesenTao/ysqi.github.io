<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Book-rsses on 虞双齐的博客</title>
    <link>https://yushuangqi.com/book.xml</link>
    <description>在 虞双齐的博客上关于in Book-rsses 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Fri, 04 Mar 2016 13:17:33 +0800</lastBuildDate>
    <atom:link href="/book.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GobyExample中文版</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/go-example-zh.html</link>
      <pubDate>Fri, 04 Mar 2016 13:17:33 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/go-example-zh.html</guid>
      <description>此章节收录自 Go by Example 中文 开源项目，虽然作者已提供访问环境，但是对于示例代码还是无法适合于墙内用户在线运行Go。
感谢@mmcgrana 编写 | everyx中文翻译。</description>
    </item>
    
    <item>
      <title>Go示例大全-信号</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/signals.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:38 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/signals.html</guid>
      <description>有时候，我们希望 Go 能智能的处理 Unix 信号。例如，我们希望当服务器接收到一个 SIGTERM 信号时能够自动关机，或者一个命令行工具在接收到一个 SIGINT 信号时停止处理输入信息。这里讲的就就是在 Go 中如何通过通道来处理信号。
Go 通过向一个通道发送 os.Signal 值来进行信号通知。我们将创建一个通道来接收这些通知（同时还创建一个用于在程序可以结束时进行通知的通道）。
signal.Notify 注册这个给定的通道用于接收特定信号。
这个 Go 协程执行一个阻塞的信号接收操作。当它得到一个值时，它将打印这个值，然后通知程序可以退出。
程序将在这里进行等待，直到它得到了期望的信号（也就是上面的 Go 协程发送的 done 值）然后退出。
package main import &amp;quot;fmt&amp;quot; import &amp;quot;os&amp;quot; import &amp;quot;os/signal&amp;quot; import &amp;quot;syscall&amp;quot; func main() { sigs := make(chan os.Signal, 1) done := make(chan bool, 1) signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM) go func() { sig := &amp;lt;-sigs fmt.Println() fmt.Println(sig) done &amp;lt;- true }() fmt.Println(&amp;quot;awaiting signal&amp;quot;) &amp;lt;-done fmt.Println(&amp;quot;exiting&amp;quot;) }  </description>
    </item>
    
    <item>
      <title>Go示例大全-退出</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/exit.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:38 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/exit.html</guid>
      <description>使用 os.Exit 来立即进行带给定状态的退出。
当使用 os.Exit 时 defer 将不会 执行，所以这里的 fmt.Println将永远不会被调用。
退出并且退出状态为 3。
注意，不像例如 C 语言，Go 不使用在 main 中返回一个整数来指明退出状态。如果你想以非零状态退出，那么你就要使用 os.Exit。
package main import &amp;quot;fmt&amp;quot; import &amp;quot;os&amp;quot; func main() { defer fmt.Println(&amp;quot;!&amp;quot;) os.Exit(3) }  </description>
    </item>
    
    <item>
      <title>Go示例大全-执行进程</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/execing-processes.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:37 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/execing-processes.html</guid>
      <description>在前面的例子中，我们了解了生成外部进程的知识，当我们需要访问外部进程时时需要这样做，但是有时候，我们只想用其他的（也许是非 Go 程序）来完全替代当前的 Go 进程。这时候，我们可以使用经典的 exec方法的 Go 实现。
在我们的例子中，我们将执行 ls 命令。Go 需要提供我们需要执行的可执行文件的绝对路径，所以我们将使用exec.LookPath 来得到它（大概是 /bin/ls）。
Exec 需要的参数是切片的形式的（不是放在一起的一个大字符串）。我们给 ls 一些基本的参数。注意，第一个参数需要是程序名。
Exec 同样需要使用环境变量。这里我们仅提供当前的环境变量。
这里是 os.Exec 调用。如果这个调用成功，那么我们的进程将在这里被替换成 /bin/ls -a -l -h 进程。如果存在错误，那么我们将会得到一个返回值。
package main import &amp;quot;syscall&amp;quot; import &amp;quot;os&amp;quot; import &amp;quot;os/exec&amp;quot; func main() { binary, lookErr := exec.LookPath(&amp;quot;ls&amp;quot;) if lookErr != nil { panic(lookErr) } args := []string{&amp;quot;ls&amp;quot;, &amp;quot;-a&amp;quot;, &amp;quot;-l&amp;quot;, &amp;quot;-h&amp;quot;} env := os.Environ() execErr := syscall.Exec(binary, args, env) if execErr != nil { panic(execErr) } }  </description>
    </item>
    
    <item>
      <title>Go示例大全-生成进程</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/spawning-processes.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:37 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/spawning-processes.html</guid>
      <description>有时，我们的 Go 程序需要生成其他的，非 Go 进程。例如，这个网站的语法高亮是通过在 Go 程序中生成一个 pygmentize来实现的。让我们看一些关于 Go 生成进程的例子。
我们将从一个简单的命令开始，没有参数或者输入，仅打印一些信息到标准输出流。exec.Command 函数帮助我们创建一个表示这个外部进程的对象。
.Output 是另一个帮助我们处理运行一个命令的常见情况的函数，它等待命令运行完成，并收集命令的输出。如果没有出错，dateOut 将获取到日期信息的字节。
下面我们将看看一个稍复杂的例子，我们将从外部进程的stdin 输入数据并从 stdout 收集结果。
这里我们明确的获取输入/输出管道，运行这个进程，写入一些输入信息，读取输出的结果，最后等待程序运行结束。
上面的例子中，我们忽略了错误检测，但是你可以使用if err != nil 的方式来进行错误检查，我们也只收集StdoutPipe 的结果，但是你可以使用相同的方法收集StderrPipe 的结果。
注意，当我们需要提供一个明确的命令和参数数组来生成命令，和能够只需要提供一行命令行字符串相比，你想使用通过一个字符串生成一个完整的命令，那么你可以使用 bash命令的 -c 选项：
package main import &amp;quot;fmt&amp;quot; import &amp;quot;io/ioutil&amp;quot; import &amp;quot;os/exec&amp;quot; func main() { dateCmd := exec.Command(&amp;quot;date&amp;quot;) dateOut, err := dateCmd.Output() if err != nil { panic(err) } fmt.Println(&amp;quot;&amp;gt; date&amp;quot;) fmt.Println(string(dateOut)) grepCmd := exec.Command(&amp;quot;grep&amp;quot;, &amp;quot;hello&amp;quot;) grepIn, _ := grepCmd.StdinPipe() grepOut, _ := grepCmd.</description>
    </item>
    
    <item>
      <title>Go示例大全-命令行参数</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/command-line-arguments.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/command-line-arguments.html</guid>
      <description>命令行参数是指定程序运行参数的一个常见方式。例如，go run hello.go，程序 go 使用了 run 和 hello.go 两个参数。
os.Args 提供原始命令行参数访问功能。注意，切片中的第一个参数是该程序的路径，并且 os.Args[1:]保存所有程序的的参数。
你可以使用标准的索引位置方式取得单个参数的值。
package main import &amp;quot;os&amp;quot; import &amp;quot;fmt&amp;quot; func main() { argsWithProg := os.Args argsWithoutProg := os.Args[1:] arg := os.Args[3] fmt.Println(argsWithProg) fmt.Println(argsWithoutProg) fmt.Println(arg) }  </description>
    </item>
    
    <item>
      <title>Go示例大全-命令行标志</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/command-line-flags.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/command-line-flags.html</guid>
      <description>命令行标志是命令行程序指定选项的常用方式。例如，在 wc -l 中，这个 -l 就是一个命令行标志。
Go 提供了一个 flag 包，支持基本的命令行标志解析。我们将用这个包来实现我们的命令行程序示例。
基本的标记声明仅支持字符串、整数和布尔值选项。这里我们声明一个默认值为 &amp;quot;foo&amp;quot; 的字符串标志 word并带有一个简短的描述。这里的 flag.String 函数返回一个字符串指针（不是一个字符串值），在下面我们会看到是如何使用这个指针的。
使用和声明 word 标志相同的方法来声明 numb 和 fork 标志。
用程序中已有的参数来声明一个标志也是可以的。注意在标志声明函数中需要使用该参数的指针。
所有标志都声明完成以后，调用 flag.Parse() 来执行命令行解析。
这里我们将仅输出解析的选项以及后面的位置参数。注意，我们需要使用类似 *wordPtr 这样的语法来对指针解引用，从而得到选项的实际值。
package main import &amp;quot;flag&amp;quot; import &amp;quot;fmt&amp;quot; func main() { wordPtr := flag.String(&amp;quot;word&amp;quot;, &amp;quot;foo&amp;quot;, &amp;quot;a string&amp;quot;) numbPtr := flag.Int(&amp;quot;numb&amp;quot;, 42, &amp;quot;an int&amp;quot;) boolPtr := flag.Bool(&amp;quot;fork&amp;quot;, false, &amp;quot;a bool&amp;quot;) var svar string flag.StringVar(&amp;amp;svar, &amp;quot;svar&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;a string var&amp;quot;) flag.Parse() fmt.Println(&amp;quot;word:&amp;quot;, *wordPtr) fmt.Println(&amp;quot;numb:&amp;quot;, *numbPtr) fmt.</description>
    </item>
    
    <item>
      <title>Go示例大全-环境变量</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/environment-variables.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/environment-variables.html</guid>
      <description>环境变量是一个在为 Unix 程序传递配置信息的普遍方式。让我们来看看如何设置，获取并列举环境变量。
使用 os.Setenv 来设置一个键值队。使用 os.Getenv获取一个键对应的值。如果键不存在，将会返回一个空字符串。
使用 os.Environ 来列出所有环境变量键值队。这个函数会返回一个 KEY=value 形式的字符串切片。你可以使用strings.Split 来得到键和值。这里我们打印所有的键。
package main import &amp;quot;os&amp;quot; import &amp;quot;strings&amp;quot; import &amp;quot;fmt&amp;quot; func main() { os.Setenv(&amp;quot;FOO&amp;quot;, &amp;quot;1&amp;quot;) fmt.Println(&amp;quot;FOO:&amp;quot;, os.Getenv(&amp;quot;FOO&amp;quot;)) fmt.Println(&amp;quot;BAR:&amp;quot;, os.Getenv(&amp;quot;BAR&amp;quot;)) fmt.Println() for _, e := range os.Environ() { pair := strings.Split(e, &amp;quot;=&amp;quot;) fmt.Println(pair[0]) } }  </description>
    </item>
    
    <item>
      <title>Go示例大全-行过滤器</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/line-filters.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/line-filters.html</guid>
      <description>一个行过滤器 在读取标准输入流的输入，处理该输入，然后将得到一些的结果输出到标准输出的程序中是常见的一个功能。grep 和 sed 是常见的行过滤器。
这里是一个使用 Go 编写的行过滤器示例，它将所有的输入文字转化为大写的版本。你可以使用这个模式来写一个你自己的 Go行过滤器。
对 os.Stdin 使用一个带缓冲的 scanner，让我们可以直接使用方便的 Scan 方法来直接读取一行，每次调用该方法可以让 scanner 读取下一行。
Text 返回当前的 token，现在是输入的下一行。
写出大写的行。
检查 Scan 的错误。文件结束符是可以接受的，并且不会被 Scan 当作一个错误。
 package main import ( &amp;quot;bufio&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;os&amp;quot; &amp;quot;strings&amp;quot; ) func main() { scanner := bufio.NewScanner(os.Stdin) for scanner.Scan() { ucl := strings.ToUpper(scanner.Text()) fmt.Println(ucl) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, &amp;quot;error:&amp;quot;, err) os.Exit(1) } }  </description>
    </item>
    
    <item>
      <title>Go示例大全-写文件</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/writing-files.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/writing-files.html</guid>
      <description>Go 写文件和我们前面看过的读操作有着相似的方式。
开始，这里是展示如写入一个字符串（或者只是一些字节）到一个文件。
对于更细粒度的写入，先打开一个文件。
打开文件后，习惯立即使用 defer 调用文件的 Close操作。
你可以写入你想写入的字节切片
WriteString 也是可用的。
调用 Sync 来将缓冲区的信息写入磁盘。
bufio 提供了和我们前面看到的带缓冲的读取器一样的带缓冲的写入器。
使用 Flush 来确保所有缓存的操作已写入底层写入器。
package main import ( &amp;quot;bufio&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;os&amp;quot; ) func check(e error) { if e != nil { panic(e) } } func main() { d1 := []byte(&amp;quot;hello\ngo\n&amp;quot;) err := ioutil.WriteFile(&amp;quot;/tmp/dat1&amp;quot;, d1, 0644) check(err) f, err := os.Create(&amp;quot;/tmp/dat2&amp;quot;) check(err) defer f.Close() d2 := []byte{115, 111, 109, 101, 10} n2, err := f.Write(d2) check(err) fmt.</description>
    </item>
    
    <item>
      <title>Go示例大全-读文件</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/reading-files.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/reading-files.html</guid>
      <description>读写文件在很多程序中都是必须的基本任务。首先我们看看一些读文件的例子。
读取文件需要经常进行错误检查，这个帮助方法可以精简下面的错误检查过程。
也许大部分基本的文件读取任务是将文件内容读取到内存中。
你经常会想对于一个文件是怎么读并且读取到哪一部分进行更多的控制。对于这个任务，从使用 os.Open打开一个文件获取一个 os.File 值开始。
从文件开始位置读取一些字节。这里最多读取 5 个字节，并且这也是我们实际读取的字节数。
你也可以 Seek 到一个文件中已知的位置并从这个位置开始进行读取。
io 包提供了一些可以帮助我们进行文件读取的函数。例如，上面的读取可以使用 ReadAtLeast 得到一个更健壮的实现。
没有内置的回转支持，但是使用 Seek(0, 0) 实现。
bufio 包实现了带缓冲的读取，这不仅对有很多小的读取操作的能提升性能，也提供了很多附加的读取函数。
任务结束后要关闭这个文件（通常这个操作应该在 Open操作后立即使用 defer 来完成）。
package main import ( &amp;quot;bufio&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;io&amp;quot; &amp;quot;io/ioutil&amp;quot; &amp;quot;os&amp;quot; ) func check(e error) { if e != nil { panic(e) } } func main() { dat, err := ioutil.ReadFile(&amp;quot;/tmp/dat&amp;quot;) check(err) fmt.Print(string(dat)) f, err := os.Open(&amp;quot;/tmp/dat&amp;quot;) check(err) b1 := make([]byte, 5) n1, err := f.</description>
    </item>
    
    <item>
      <title>Go示例大全-Base64编码</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/base64-encoding.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:34 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/base64-encoding.html</guid>
      <description>Go 提供内建的 base64 编解码支持。
这个语法引入了 encoding/base64 包并使用名称 b64代替默认的 base64。这样可以节省点空间。
这是将要编解码的字符串。
Go 同时支持标准的和 URL 兼容的 base64 格式。编码需要使用 []byte 类型的参数，所以要将字符串转成此类型。
解码可能会返回错误，如果不确定输入信息格式是否正确，那么，你就需要进行错误检查了。
使用 URL 兼容的 base64 格式进行编解码。
package main import b64 &amp;quot;encoding/base64&amp;quot; import &amp;quot;fmt&amp;quot; func main() { data := &amp;quot;abc123!?$*&amp;amp;()&amp;#39;-=@~&amp;quot; sEnc := b64.StdEncoding.EncodeToString([]byte(data)) fmt.Println(sEnc) sDec, _ := b64.StdEncoding.DecodeString(sEnc) fmt.Println(string(sDec)) fmt.Println() uEnc := b64.URLEncoding.EncodeToString([]byte(data)) fmt.Println(uEnc) uDec, _ := b64.URLEncoding.DecodeString(uEnc) fmt.Println(string(uDec)) }  </description>
    </item>
    
    <item>
      <title>Go示例大全-SHA1散列</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/sha1-hashes.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:34 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/sha1-hashes.html</guid>
      <description>SHA1 散列经常用生成二进制文件或者文本块的短标识。例如，git 版本控制系统大量的使用 SHA1 来标识受版本控制的文件和目录。这里是 Go中如何进行 SHA1 散列计算的例子。
Go 在多个 crypto/* 包中实现了一系列散列函数。
产生一个散列值得方式是 sha1.New()，sha1.Write(bytes)，然后 sha1.Sum([]byte{})。这里我们从一个新的散列开始。
写入要处理的字节。如果是一个字符串，需要使用[]byte(s) 来强制转换成字节数组。
这个用来得到最终的散列值的字符切片。Sum 的参数可以用来都现有的字符切片追加额外的字节切片：一般不需要要。
SHA1 值经常以 16 进制输出，例如在 git commit 中。使用%x 来将散列结果格式化为 16 进制字符串。
package main import &amp;quot;crypto/sha1&amp;quot; import &amp;quot;fmt&amp;quot; func main() { s := &amp;quot;sha1 this string&amp;quot; h := sha1.New() h.Write([]byte(s)) bs := h.Sum(nil) fmt.Println(s) fmt.Printf(&amp;quot;%x\n&amp;quot;, bs) }  </description>
    </item>
    
    <item>
      <title>Go示例大全-URL解析</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/url-parsing.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:34 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/url-parsing.html</guid>
      <description>URL 提供了一个统一资源定位方式。这里了解一下 Go 中是如何解析 URL 的。
我们将解析这个 URL 示例，它包含了一个 scheme，认证信息，主机名，端口，路径，查询参数和片段。
解析这个 URL 并确保解析没有出错。
直接访问 scheme。
User 包含了所有的认证信息，这里调用 Username和 Password 来获取独立值。
Host 同时包括主机名和端口信息，如过端口存在的话，使用 strings.Split() 从 Host 中手动提取端口。
这里我们提出路径和查询片段信息。
要得到字符串中的 k=v 这种格式的查询参数，可以使用 RawQuery 函数。你也可以将查询参数解析为一个map。已解析的查询参数 map 以查询字符串为键，对应值字符串切片为值，所以如何只想得到一个键对应的第一个值，将索引位置设置为 [0] 就行了。
package main import &amp;quot;fmt&amp;quot; import &amp;quot;net/url&amp;quot; import &amp;quot;strings&amp;quot; func main() { s := &amp;quot;postgres://user:pass@host.com:5432/path?k=v#f&amp;quot; u, err := url.Parse(s) if err != nil { panic(err) } fmt.Println(u.Scheme) fmt.Println(u.User) fmt.Println(u.User.Username()) p, _ := u.User.Password() fmt.Println(p) fmt.Println(u.Host) h := strings.</description>
    </item>
    
    <item>
      <title>Go示例大全-数字解析</title>
      <link>https://yushuangqi.com/book/goexamplelib/gobyexample/number-parsing.html</link>
      <pubDate>Fri, 04 Mar 2016 13:13:33 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/book/goexamplelib/gobyexample/number-parsing.html</guid>
      <description>从字符串中解析数字在很多程序中是一个基础常见的任务，在Go 中是这样处理的。
内置的 strconv 包提供了数字解析功能。
使用 ParseFloat 解析浮点数，这里的 64 表示表示解析的数的位数。
在使用 ParseInt 解析整形数时，例子中的参数 0 表示自动推断字符串所表示的数字的进制。64 表示返回的整形数是以 64 位存储的。
ParseInt 会自动识别出十六进制数。
ParseUint 也是可用的。
Atoi 是一个基础的 10 进制整型数转换函数。
在输入错误时，解析函数会返回一个错误。
package main import &amp;quot;strconv&amp;quot; import &amp;quot;fmt&amp;quot; func main() { f, _ := strconv.ParseFloat(&amp;quot;1.234&amp;quot;, 64) fmt.Println(f) i, _ := strconv.ParseInt(&amp;quot;123&amp;quot;, 0, 64) fmt.Println(i) d, _ := strconv.ParseInt(&amp;quot;0x1c8&amp;quot;, 0, 64) fmt.Println(d) u, _ := strconv.ParseUint(&amp;quot;789&amp;quot;, 0, 64) fmt.Println(u) k, _ := strconv.Atoi(&amp;quot;135&amp;quot;) fmt.Println(k) _, e := strconv.</description>
    </item>
    
  </channel>
</rss>