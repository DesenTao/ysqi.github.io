<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>哈希表 on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8.html</link>
    <description>在 虞双齐的博客上关于in 哈希表 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:33:49 +0800</lastBuildDate>
    <atom:link href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用Golang写一个搜索引擎(0x03)---跳跃表哈希表</title>
      <link>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing-0x03----tiao-yue-biao-ha-xi-biao.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:49 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing-0x03----tiao-yue-biao-ha-xi-biao.html.html</guid>
      <description>前面已经说了倒排索引的基本原理了，原理非常简单，也很好理解，关键是如何设计第二个倒排表，倒排表的第二列也很好设计，第一列就是关键了，为了满足快速查找的性能，设计第一列的结构，我们需要满足以下两个条件。
 查找非常快，能在极短的时间内找到我们需要的关键词所在的位置。
 添加关键词也需要比较快，能保证输入文档的时候尽可能的快。
  除了上面两个条件以外，还有一些加分项：
 如果能尽可能少的使用内存，那肯定是好的
 如果能顺序的遍历整个列，也肯定比较好
  为了满足能查找，能添加，我们首先想到的是顺序表，也就是链表了，链表的话，添加不成问题，关键是查找的复杂度是O(n)，这还能忍？所以链表第一个不考虑了。不过有一个链表的变种，我们是可以考虑一下，那就是跳跃表。
跳跃表(SkipList) 什么是跳跃表呢？跳跃表也叫跳表，我们可以把它看成是链表的一个变种，是一个多层顺序链表的并联结构的表，维基百科的定义是
 是一种随机化数据结构，基于并联的链表，其效率可比拟于二叉查找树（对于大多数操作需要O(log n)平均时间）
 我们通过一个图来看一下跳跃表(图片来源)
很明显，最底层是一个顺序表，然后在1，3，4，6，9节点上出现了第二层的链表，然后继续在1，4，6节点上面出现了第三层链表，这样构建出来的三层链表查询效率比一层的就高了，一般情况下，跳表的构建方式是按照概率来决定是否需要为这个节点增加一层，这里在层 *i* 中的元素按某个固定的概率 *p* (通常为0.5或0.25)出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现，而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）在 O(log1/*p* n) 个列表中出现。
查找元素的时候，起步于头元素和顶层列表，并沿着每个链表搜索，直到到达小于或着等于目标的最后一个元素。通过跟踪起自目标直到到达在更高列表中出现的元素的反向查找路径，在每个链表中预期的步数显而易见是 1/*p*。所以查找的总体代价是 O((log1/*p* n) / p)，当*p* 是常数时是 O(log n)。通过选择不同 *p* 值，就可以在查找代价和存储代价之间作出权衡。
比如还是上面那个图，我们要查找7这个元素，需要遍历1—&amp;gt;4—&amp;gt;6—&amp;gt;7，比一层链表效率高不少吧
在实现跳表的时候，虽然一般是用概率来决定是否需要增加当前节点的层级，但是实际中可以具体问题具体分析，比如我们知道底层链表大概有多长，那么我们每格10个元素增加一个层级，那么这样的跳表的存储空间我们大概也能估算出来，平均查询时间我们也能估算出来。
跳跃表是一个非常有用的数据结构，并且实现起来也比较容易，链表大家都知道实现，那么跳跃表就是一组链表啦，只是增加和删除的时候需要操作多个链表而已。
我的项目中暂时没有使用跳跃表，后续有需求的时候再加上吧，所以大家看不到代码了。让你失望了。呵呵。
一般跳跃表可以和hash配合起来使用，因为hash有桶，占用的内存较大，如果将hash值存在跳跃表中，用mmap把跳跃表加载到内存中，那么既节省了内存，又有一个较好的查询速度，而且实现起来还挺简单。
跳跃表用来实现搜索引擎的自增长类型的主键也比较合适，首先在搜索引擎中，主键的查找并不是那么频繁，一般查询都是通过关键字查询的，对主键来说，对查询速度要求并不是特别高，只有在修改主键的时候需要进行查询，其次自增长的主键一般情况下插入操作直接在链表后面append就可以了，不用进行查询，所以插入的时候也比较快。
哈希表 处理跳跃表，哈希表也是一个实现方式，哈希表是根据关键字（Key value）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做哈希表，也叫散列表。
哈希是大数据技术的基础，大家应该都有了解了，这里就不深度展开了，算法导论有一章已经讲得非常清楚了，这里说说我觉得比较有意思的一个哈希的东西。
哈希表的核心是哈希算法，一个好的哈希算法可以让碰撞产生得更少，查找速度越接近于O(1)，所以一个好的哈希算法非常重要。
哈希算法很多，说都说不完，不同的算法适应不同的场景，我知道的，传说中有一个哈希算法，来自魔兽世界（！！！！为了部落！！！！），号称暴雪哈希，该算法产生的哈希值完全无法预测，被称为&amp;ldquo;One-Way Hash&amp;rdquo;( A one-way hash is a an algorithm that is constructed in such a way that deriving the original string (set of strings, actually) is virtually impossible)。</description>
    </item>
    
  </channel>
</rss>