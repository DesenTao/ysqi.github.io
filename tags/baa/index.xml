<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/baa.xml</link>
    <description>在 虞双齐的博客上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <atom:link href="/tags/baa.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Baa框架中的依赖注入(DI)是个什么鬼？</title>
      <link>https://yushuangqi.com/blog/2016/baakuang-jia-zhong-de-yi-lai-zhu-ru-dishi-ge-shen-me-gui-.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:28 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/baakuang-jia-zhong-de-yi-lai-zhu-ru-dishi-ge-shen-me-gui-.html</guid>
      <description>我最早接触的Go WEB框架是beego，很强大的一个框架，也是很多人的首选，就是因为太（bu）强（gou）大（ling）了(huo)，后来尝试了Macaron（martini）。Macaron的设计是众多框架的主流思想，路由、中间件、HTTP上下文，然后自己实现了一些常用的中间件（PS. 有一些中间件代码来自beego）。Macaron的思想中，可以通过m.Map()注入任意类型，然后在Context中通过反射获取这个类型，初试很爽，并为他的设计称赞。
在用PHP的时候有个框架 Phalcon他的设计中核心是 Dependency Injection/Service Location，看起来很复杂，简单来说就是把类似log,db,cache,metadata等服务注册到DI中，使用的时候从DI取出来。Phalcon的使用姿势中就是先初始化一个APP，然后各种注册DI，然后RUN，伪代码如下：
&amp;lt;?php $di = new \Phalcon\DI\FactoryDefault(); $di-&amp;gt;set(&#39;router&#39;, new MyRouter()); $di-&amp;gt;set(&#39;logger&#39;, function () { return new LoggerFile(&#39;../apps/logs/error.log&#39;); }); $di-&amp;gt;set(&#39;db&#39;, function () { return new PdoMysql( array( &amp;quot;host&amp;quot; =&amp;gt; &amp;quot;localhost&amp;quot;, &amp;quot;username&amp;quot; =&amp;gt; &amp;quot;root&amp;quot;, &amp;quot;password&amp;quot; =&amp;gt; &amp;quot;secret&amp;quot;, &amp;quot;dbname&amp;quot; =&amp;gt; &amp;quot;blog&amp;quot; ) ); }); $di-&amp;gt;set(&#39;db2&#39;, ...); $di-&amp;gt;set(&#39;mongo&#39;, new \MongoClient()); // Create an application $application = new \Phalcon\Mvc\Application($di); // Handle the request echo $application-&amp;gt;handle()-&amp;gt;getContent();  上面的初始化，就是各种set，当然他支持set的类型比较丰富，还支持lazyload等，使用的方式也比较简单：
&amp;lt;?php $di = new \Phalcon\DI\FactoryDefault(); $db = $di-&amp;gt;get(&#39;db&#39;); $mongo = $di-&amp;gt;get(&#39;mongo&#39;); $mongo-&amp;gt;selectCollection(&#39;xxx&#39;);  总结下来，就是 set/get，set就是设置一个服务（注入），get就是取出这个服务来使用，当然php不像Go是静态语言，他不需要做类型断言。</description>
    </item>
    
    <item>
      <title>从Baa开发中总结Go语言性能渐进优化</title>
      <link>https://yushuangqi.com/blog/2016/cong-baakai-fa-zhong-zong-jie-goyu-yan-xing-neng-jian-jin-you-hua.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:28 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/cong-baakai-fa-zhong-zong-jie-goyu-yan-xing-neng-jian-jin-you-hua.html</guid>
      <description>在Go生态已经有很多WEB框架，但感觉没有一个符合我们的想法，我们想要一个简洁高效的核心框架，提供路由，context，中间件和依赖注入，而且拒绝使用正则和反射，于是我们开始构建Baa框架。一开始使用最简单的通俗写法实现了第一版的功能，基本可用，但是性能烂到爆，优化之路漫漫开启。
 最好的文章应该是每一步都加上优化前后的benchmark对比结果，给读者以最直观的感受。我先BS一下自己，因为我懒了，没有再回头一步步去对比这个结果图。
 拒绝正则和反射 这是我们做这个框架时的一个基本原则，整个实现中没有使用过regexp、reflect包。这是我们对性能追求的基础。带来的另一个收益是，没有魔法，都是非常容易理解的实现，让整个框架变得简单。
使用sync.Pool重用对象 在我上次翻译的文章CockroachDB GC优化总结中介绍过这些方法，在《Go语言圣经》中作者也介绍了这个方法，使用 sync.Pool 可以在一次GC之间重用对象，避免对象的频繁创建和内存分配。我们在追求性能的过程中，要尽可能减少甚至达到内存零分配，这是一个最重要的用法。
在Baa中有如下代码片段：
b.pool = sync.Pool{ New: func() interface{} { return newContext(nil, nil, b) }, }  使用的时候：
c := b.pool.Get().(*Context) c.reset(w, r)  使用完：
b.pool.Put(c)  使用array优化slice slice的本质就是就是一个可变长度的array，根据存储的容量会动态的重新分配内存迁移数据。如果长度不断变化，会导致不断的重新分配内存，在特定场景下，如果我们可以使用一个定长的array来优化内存分配。
var nameArr [1024]string pNames := nameArr[0:0] pNames = append(pNames, &amp;quot;val&amp;quot;)  pNames 是一个slice，但数据操作总是在array nameArr上完成，在整个使用过程中不会重新分配内存。
 上面的伪代码，在Baa中已经不存在了，Baa改用了下面的技巧来取代定长的array。
 slice也能重用 slice的重用，其实和上面的利用array优化基本一致，就是初始分配一个较大的容量，尽可能在使用的过程中都不会超出容量，当然也不用担心，万一不够用了，会自动扩容，只不过会进行一次内存分配。
在Baa中有如下代码片段：
// newContext create a http context func newContext(w http.ResponseWriter, r *http.Request, b *Baa) *Context { c := new(Context) c.</description>
    </item>
    
  </channel>
</rss>