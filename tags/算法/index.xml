<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Go语言技术独立咨询顾问</title>
    <link>https://yushuangqi.com/tags/%E7%AE%97%E6%B3%95.xml</link>
    <description>在 虞双齐Go语言技术独立咨询顾问上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/%E7%AE%97%E6%B3%95.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LRU算法</title>
      <link>https://yushuangqi.com/blog/2016/lru-suan-fa.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:05 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/lru-suan-fa.html</guid>
      <description>LRU 最近最少使用算法，LRU算法主要用于缓存淘汰。主要目的就是把最近最少使用的数据移除内存，以加载其他数据。
原理 添加元素时，放到链表头 缓存命中，将元素移动到链表头 缓存满了之后，将链表尾的元素删除  LRU算法实现  可以用一个双向链表保存数据 使用hash实现O(1)的访问  groupcache中LRU算法实现（Go语言）
https://github.com/golang/groupcache/blob/master/lru/lru.go
源码简单注释：
package lru import &amp;quot;container/list&amp;quot; // Cache 结构体，定义lru cache 不是线程安全的 type Cache struct { // 数目限制，0是无限制 MaxEntries int // 删除时, 可以添加可选的回调函数 OnEvicted func(key Key, value interface{}) ll *list.List // 使用链表保存数据 cache map[interface{}]*list.Element // map } // Key 是任何可以比较的值 http://golang.org/ref/spec#Comparison_operators type Key interface{} type entry struct { key Key value interface{} } // 创建新的cache 对象 func New(maxEntries int) *Cache { return &amp;amp;Cache{ MaxEntries: maxEntries, ll: list.</description>
    </item>
    
    <item>
      <title>golang实现快速排序</title>
      <link>https://yushuangqi.com/blog/2016/golangshi-xian-kuai-su-pai-xu.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:43 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/golangshi-xian-kuai-su-pai-xu.html</guid>
      <description>快速排序的原理就不介绍了。在网上看到一个有趣的视频，大家可以看看，非常详细且有趣。
快速排序视频
代码：https://play.golang.org/p/Fw5gtzrPj0
package main import ( &amp;quot;fmt&amp;quot; ) func main() { var sortArray = []int{3, 41, 24, 76, 11, 45, 3, 3, 64, 21, 69, 19, 36} fmt.Println(sortArray) qsort(sortArray, 0, len(sortArray)-1) fmt.Println(sortArray) } func qsort(array []int, low, high int) { if low &amp;lt; high { m := partition(array, low, high) // fmt.Println(m) qsort(array, low, m-1) qsort(array, m+1, high) } } func partition(array []int, low, high int) int { key := array[low] tmpLow := low tmpHigh := high for { //查找小于等于key的元素，该元素的位置一定是tmpLow到high之间，因为array[tmpLow]及左边元素小于等于key，不会越界 for array[tmpHigh] &amp;gt; key { tmpHigh-- } //找到大于key的元素，该元素的位置一定是low到tmpHigh+1之间。因为array[tmpHigh+1]必定大于key for array[tmpLow] &amp;lt;= key &amp;amp;&amp;amp; tmpLow &amp;lt; tmpHigh { tmpLow++ } if tmpLow &amp;gt;= tmpHigh { break } // swap(array[tmpLow], array[tmpHigh]) array[tmpLow], array[tmpHigh] = array[tmpHigh], array[tmpLow] fmt.</description>
    </item>
    
    <item>
      <title>[leetcode]FindMinimuminRotatedSortedArrayII</title>
      <link>https://yushuangqi.com/blog/2016/leetcode-find-minimum-in-rotated-sorted-array-ii.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/leetcode-find-minimum-in-rotated-sorted-array-ii.html</guid>
      <description>code：https://play.golang.org/p/luj1fdu03F
problem: https://oj.leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;math/rand&amp;quot; &amp;quot;sort&amp;quot; &amp;quot;time&amp;quot; ) //rotate数组方法一 func rotateArray1(a []int, pos int) { if pos &amp;lt; 0 { return } lenA := len(a) pos = pos % lenA tmpArray := make([]int, pos) for i := 0; i &amp;lt; pos; i++ { tmpArray[i] = a[i] } for i := pos; i &amp;lt; lenA; i++ { a[i-pos] = a[i] } for i := 0; i &amp;lt; pos; i++ { a[lenA-pos+i] = tmpArray[i] } } //rotate数组方法2 func rotateArray2(a []int, pos int) { if pos &amp;lt; 0 { return } lenA := len(a) pos = pos % lenA reverseArray(a[:pos]) reverseArray(a[pos:]) reverseArray(a) } //reverse数组，反转 func reverseArray(a []int) { for i, j := 0, len(a)-1; i &amp;lt; j; i, j = i+1, j-1 { a[i], a[j] = a[j], a[i] } } func main() { len := 20 a := make([]int, len) seedNum := 0 rand.</description>
    </item>
    
    <item>
      <title>[leetcode]wordsearch</title>
      <link>https://yushuangqi.com/blog/2016/leetcode-wordsearch.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:38 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/leetcode-wordsearch.html</guid>
      <description>problem: https://oj.leetcode.com/problems/word-search/
代码：https://play.golang.org/p/d5wP691Pbg
package main import ( &amp;quot;fmt&amp;quot; ) func main() { arr := [][]byte{ {&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;E&#39;}, {&#39;S&#39;, &#39;F&#39;, &#39;C&#39;, &#39;S&#39;}, {&#39;A&#39;, &#39;D&#39;, &#39;E&#39;, &#39;E&#39;}, } //word := []byte(&amp;quot;ABCESC&amp;quot;) word := []byte(&amp;quot;SFCE&amp;quot;) arrI, arrJ, ok := FindFirstCharPositions(arr, word[0]) if ok { fmt.Printf(&amp;quot;%d, %d\n&amp;quot;, arrI, arrJ) } fmt.Println(DFSTraverse(arr, word, arrI, arrJ)) } func DFSTraverse(arr [][]byte, word []byte, arrI []int, arrJ []int) (ret bool) { //初始化visited函数 lenArr := len(arr) visited := make([][]bool, lenArr) for i := 0; i &amp;lt; lenArr; i++ { visited[i] = make([]bool, len(arr[i])) } lenArrI := len(arrI) //lenArrJ := len(arrJ) for i := 0; i &amp;lt; lenArrI; i++ { //fmt.</description>
    </item>
    
    <item>
      <title>[leetcode]wordladderii</title>
      <link>https://yushuangqi.com/blog/2016/leetcode-wordladder-ii.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:37 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/leetcode-wordladder-ii.html</guid>
      <description>problem: https://oj.leetcode.com/problems/word-ladder-ii/
代码：https://play.golang.org/p/qdmadQUcEC
package main import ( &amp;quot;fmt&amp;quot; ) func main() { start := &amp;quot;hit&amp;quot; end := &amp;quot;cog&amp;quot; dict := []string{&amp;quot;hot&amp;quot;, &amp;quot;dot&amp;quot;, &amp;quot;dog&amp;quot;, &amp;quot;lot&amp;quot;, &amp;quot;log&amp;quot;} dict = append(dict, start, end) mapAdjacency := createAdjacencyGraph(dict, start, end) findLadders(mapAdjacency, start, end) } func findLadders(mapAdjacency map[string][]string, start, end string) { visited := make(map[string]int, len(mapAdjacency)) visited[start] = 1 queue := make([]string, len(mapAdjacency)) queue = append(queue, start) mapParent := make(map[string][]string, len(mapAdjacency)) bfs(mapAdjacency, visited, queue, mapParent, start, end) stack := []string{} stack = append(stack, end) printShortestPath(mapParent, stack, start, end) } func printShortestPath(mapParent map[string][]string, stack []string, start, end string) { if end == start { printStack(stack) return } for _, v := range mapParent[end] { stack = append(stack, v) printShortestPath(mapParent, stack, start, v) stack = stack[:len(stack)-1] } } func printStack(stack []string) { lenStack := len(stack) for i := lenStack - 1; i &amp;gt;= 0; i-- { fmt.</description>
    </item>
    
    <item>
      <title>xstrings:Go语言字符串库的补完</title>
      <link>https://yushuangqi.com/blog/2016/xstringsgo-yu-yan-zi-fu-chuan-ku-de-bu-wan.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:36 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/xstringsgo-yu-yan-zi-fu-chuan-ku-de-bu-wan.html</guid>
      <description>项目地址：https://github.com/huandu/xstrings
xstrings 是一个很简单的 Go 语言库，简单说就是提供了一些标准库 strings 没提供但依然很有用的字符串算法。每个字符串算法都对效率进行了优化，所有函数都可以做到不超过 O(n) 的复杂度，并且尽量节省内存使用，仅在需要分配内存的时候分配。
现在实现的算法几乎都是其他语言（主要是 Python/Ruby/PHP/Perl）标准库里提供的算法，用 Go 重新实现一遍。未来也许我还会继续加入更多的方法，不过我不希望这个库成为一个算法大杂烩，因此仅仅会考虑那些特别有名且语言无关的函数。
Go 的 strings 操作字符串的时候都是以 rune 为单位进行，但 string 类型却只能以 byte 为单位进行下标访问，要想使用 rune 就得用 []rune(str) 进行转换（有额外内存分配）或者 utf8. DecodeRuneInString(str) 一个个解码。为了和标准库保持高度统一，xstrings 也完全以 rune 为单位操作字符串，这使得算法的实现难度比其他语言稍高一点，不过总之都搞定了，这种有一点挑战的感觉很不错。٩( &amp;lsquo;ω&amp;rsquo; )و
做这个项目有两方面原因。
一方面是因为 Go 的 strings 自带算法实在太少，其他语言里面一些特别有趣的字符串算法，比如 Ruby 的 String#succ/String#tr 在 Go 里面都没有，网上甚至都搜不到有人实现过，所以干脆自己来实现一个。
另一方面则是因为 Go 语言的命名风格比较另类，或者说没有什么历史包袱，在其他语言都被 C 语言遗毒深深困扰的时候，Go 采用了一种小清新的风格命名函数，读起来很舒服，只是从其他语言过来的人要想凭感觉找到某特定函数时会略微有些纠结，比如谁能想到 stricmp 在 Go 里面竟然叫做 EqualFold 呢。所以我就干脆写一个函数对应表，把 Go 的 strings 函数和其他语言类似函数对应起来，也许有朝一日能够帮到些许新晋 Go 开发者吧。</description>
    </item>
    
  </channel>
</rss>