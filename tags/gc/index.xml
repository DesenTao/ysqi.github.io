<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Gc on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/gc.html</link>
    <description>在 虞双齐的博客上关于in Gc 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:34:05 +0800</lastBuildDate>
    <atom:link href="/tags/gc.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[译]CockroachDBGC优化总结</title>
      <link>https://yushuangqi.com/blog/2016/yi--cockroachdb-gcyou-hua-zong-jie.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:05 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yi--cockroachdb-gcyou-hua-zong-jie.html.html</guid>
      <description>几周前我们分享了一个帖子讲述我们为什么选择Go语言编写CockroachDB，我们收到一些问题，询问我们是如何解决Go语言的一些已知问题，特别是关于性能、GC和死锁的问题。
本文中我们将分享几个非常有用的优化技巧用以改善许多常见的GC性能问题（接下来还将覆盖一些有趣的死锁问题）。我们将重点分享如何通过嵌套结构体、使用 sync.Pool、和复用后端数组减少内存分配和降低GC开销。
减少内存分配和GC优化 将Go与其他语言（比如java）区别开来的是Go语言能让你管理内存布局。通过GO语言，你可以合并碎片，而其他垃圾集合语言不能。
让我们看看CockroachDB中从磁盘读取数据并解码的一小段代码：
metaKey := mvccEncodeMetaKey(key) var meta MVCCMetadata if err := db.GetProto(metaKey, &amp;amp;meta); err != nil { // Handle err } ... valueKey := makeEncodeValueKey(meta) var value MVCCValue if err := db.GetProto(valueKey, &amp;amp;value); err != nil { // Handle err }  为了读取数据，我们执行了4次内存分配：MVCCMetadata结构体、MVCCValue结构体和metaKey、valueKey。在Go语言中我们可以通过合并结构体和预分配空间给Key把内存分配减少为1次。
type getBuffer struct { meta MVCCMetadata value MVCCValue key [1024]byte } var buf getBuffer metaKey := mvccEncodeKey(buf.key[:0], key) if err := db.GetProto(metaKey, &amp;amp;buf.</description>
    </item>
    
    <item>
      <title>GC垃圾回收机制:浅析与理解</title>
      <link>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:29 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html.html</guid>
      <description>GC垃圾回收机制： 浅析与理解 对垃圾回收进行分析前，我们先来了解一些基本概念
基本概念  内存管理：内存管理对于编程语言至关重要。汇编允许你操作所有东西，或者说要求你必须全权处理所有细节更合适。C 语言中虽然标准库函数提供一些内存管理支持，但是对于之前调用 malloc 申请的内存，还是依赖于你亲自 free 掉。从C++、Python、Swift 和 Java 开始，才在不同程度上支持内存管理。
 内存压缩：对内存碎片进行压缩。（和win10的那个“内存压缩”不太一样啦）
 win10内存压缩：物理内存已经见底，将一部分不常使用的内存数据打包压缩起来，等到有程序需要访问那些数据的时候，再解压缩出来。
 引用与指针：
 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
 不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
 引用只是某块内存的别名。
 实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用” 这东西？
答案是“用适当的工具做恰如其分的工作”。比如说，某人需要一份证明，本来在文件上盖 上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。（什么情况下，就用什么对策）
 为什么还要说“只有指针，没有引用是一个重要改变？”？
答案是虽然引用在某些情况下好用，但他也会导致致命错误。如下：
char *pc = 0; // 设置指针为空值 char&amp;amp; rc = *pc; // 让引用指向空值   这是非常有害的，毫无疑问。结果将是不确定的（编译器能产生一些输出，导致任何事情都有可能发生），应该躲开写出这样代码的人除非他们同意改正错误。如果你担心这样的代码会出现在你的软件里，那么你最好完全避免使用引用，要不然就去让更优秀的程序员去做。
 最后上附图，帮助理解
  堆（heap）和栈（stack）
 平常说的“堆栈”其实是栈。
 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。
 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控 制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
  程序的栈结构
 程序的地址空间布局： 程序运行靠四个东西：代码、栈、堆、数据段。代码段主要存放的就是可执行文件(通常可执行文件内，含有以二进制编码的微处理器指令，也因此可执行文件有时称为二进制文件)中的代码；数据段存放的就是程序中全局变量和静态变量；堆中是程序的动态内存区域，当程序使用malloc或new得到的内存是来自堆的；栈中维护的是函数调用的上下文，离开了栈就不可能实现函数的调用。</description>
    </item>
    
    <item>
      <title>从Baa开发中总结Go语言性能渐进优化</title>
      <link>https://yushuangqi.com/blog/2016/cong-baakai-fa-zhong-zong-jie-goyu-yan-xing-neng-jian-jin-you-hua.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:28 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/cong-baakai-fa-zhong-zong-jie-goyu-yan-xing-neng-jian-jin-you-hua.html.html</guid>
      <description>在Go生态已经有很多WEB框架，但感觉没有一个符合我们的想法，我们想要一个简洁高效的核心框架，提供路由，context，中间件和依赖注入，而且拒绝使用正则和反射，于是我们开始构建Baa框架。一开始使用最简单的通俗写法实现了第一版的功能，基本可用，但是性能烂到爆，优化之路漫漫开启。
 最好的文章应该是每一步都加上优化前后的benchmark对比结果，给读者以最直观的感受。我先BS一下自己，因为我懒了，没有再回头一步步去对比这个结果图。
 拒绝正则和反射 这是我们做这个框架时的一个基本原则，整个实现中没有使用过regexp、reflect包。这是我们对性能追求的基础。带来的另一个收益是，没有魔法，都是非常容易理解的实现，让整个框架变得简单。
使用sync.Pool重用对象 在我上次翻译的文章CockroachDB GC优化总结中介绍过这些方法，在《Go语言圣经》中作者也介绍了这个方法，使用 sync.Pool 可以在一次GC之间重用对象，避免对象的频繁创建和内存分配。我们在追求性能的过程中，要尽可能减少甚至达到内存零分配，这是一个最重要的用法。
在Baa中有如下代码片段：
b.pool = sync.Pool{ New: func() interface{} { return newContext(nil, nil, b) }, }  使用的时候：
c := b.pool.Get().(*Context) c.reset(w, r)  使用完：
b.pool.Put(c)  使用array优化slice slice的本质就是就是一个可变长度的array，根据存储的容量会动态的重新分配内存迁移数据。如果长度不断变化，会导致不断的重新分配内存，在特定场景下，如果我们可以使用一个定长的array来优化内存分配。
var nameArr [1024]string pNames := nameArr[0:0] pNames = append(pNames, &amp;quot;val&amp;quot;)  pNames 是一个slice，但数据操作总是在array nameArr上完成，在整个使用过程中不会重新分配内存。
 上面的伪代码，在Baa中已经不存在了，Baa改用了下面的技巧来取代定长的array。
 slice也能重用 slice的重用，其实和上面的利用array优化基本一致，就是初始分配一个较大的容量，尽可能在使用的过程中都不会超出容量，当然也不用担心，万一不够用了，会自动扩容，只不过会进行一次内存分配。
在Baa中有如下代码片段：
// newContext create a http context func newContext(w http.ResponseWriter, r *http.Request, b *Baa) *Context { c := new(Context) c.</description>
    </item>
    
  </channel>
</rss>