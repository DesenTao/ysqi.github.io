<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/c.html</link>
    <description>在 虞双齐的博客上关于in C 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:34:44 +0800</lastBuildDate>
    <atom:link href="/tags/c.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>为什么Go语言把类型放在后面？</title>
      <link>https://yushuangqi.com/blog/2016/wei-shen-me--go-yu-yan-ba-lei-xing-fang-zai-hou-mian-.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:44 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/wei-shen-me--go-yu-yan-ba-lei-xing-fang-zai-hou-mian-.html.html</guid>
      <description>本文整理自知乎，原文作者 @林建入。
不是为了与众不同。而是为了更加清晰易懂。
Rob Pike 曾经在 Go 官方博客解释过这个问题（原文地址：http://blog.golang.org/gos-declaration-syntax），简略翻译如下（水平有限翻译的不对的地方见谅）：
引言 Go语言新人常常会很疑惑为什么这门语言的声明语法（declaration syntax）会和传统的C家族语言不同。在这篇博文里，我们会进行一个比较，并做出解答。
C 的语法 首先，先看看 C 的语法。C 采用了一种聪明而不同寻常的声明语法。声明变量时，只需写出一个带有目标变量名的表达式，然后在表达式里指明该表达式本身的类型即可。比如：
int x;  上面的代码声明了 x 变量，并且其类型为 int——即，表达式 x 为 int 类型。一般而言，为了指明新变量的类型，我们得写出一个表达式，其中含有我们要声明的变量，这个表达式运算的结果值属于某种基本类型，我们把这种基本类型写到表达式的左边。所以，下述声明：
int *p; int a[3];  指明了 p 是一个int类型的指针，因为 *p 的类型为 int。而 a 是一个 int 数组，因为 a[3] 的类型为 int（别管这里出现的索引值，它只是用于指明数组的长度）。
我们接下来看看函数声明的情况。C 的函数声明中关于参数的类型是写在括号外的，像下面这样：
int main(argc, argv) int argc; char *argv[]; { /* ... */ }  如前所述，我们可以看到 main 之所以是函数，是因为表达式 main(argc, argv) 返回 int。在现代记法中我们是这么写的：
int main(int argc, char *argv[]) { /* .</description>
    </item>
    
    <item>
      <title>GC垃圾回收机制:浅析与理解</title>
      <link>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:29 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html.html</guid>
      <description>GC垃圾回收机制： 浅析与理解 对垃圾回收进行分析前，我们先来了解一些基本概念
基本概念  内存管理：内存管理对于编程语言至关重要。汇编允许你操作所有东西，或者说要求你必须全权处理所有细节更合适。C 语言中虽然标准库函数提供一些内存管理支持，但是对于之前调用 malloc 申请的内存，还是依赖于你亲自 free 掉。从C++、Python、Swift 和 Java 开始，才在不同程度上支持内存管理。
 内存压缩：对内存碎片进行压缩。（和win10的那个“内存压缩”不太一样啦）
 win10内存压缩：物理内存已经见底，将一部分不常使用的内存数据打包压缩起来，等到有程序需要访问那些数据的时候，再解压缩出来。
 引用与指针：
 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
 不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
 引用只是某块内存的别名。
 实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用” 这东西？
答案是“用适当的工具做恰如其分的工作”。比如说，某人需要一份证明，本来在文件上盖 上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。（什么情况下，就用什么对策）
 为什么还要说“只有指针，没有引用是一个重要改变？”？
答案是虽然引用在某些情况下好用，但他也会导致致命错误。如下：
char *pc = 0; // 设置指针为空值 char&amp;amp; rc = *pc; // 让引用指向空值   这是非常有害的，毫无疑问。结果将是不确定的（编译器能产生一些输出，导致任何事情都有可能发生），应该躲开写出这样代码的人除非他们同意改正错误。如果你担心这样的代码会出现在你的软件里，那么你最好完全避免使用引用，要不然就去让更优秀的程序员去做。
 最后上附图，帮助理解
  堆（heap）和栈（stack）
 平常说的“堆栈”其实是栈。
 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。
 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控 制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
  程序的栈结构
 程序的地址空间布局： 程序运行靠四个东西：代码、栈、堆、数据段。代码段主要存放的就是可执行文件(通常可执行文件内，含有以二进制编码的微处理器指令，也因此可执行文件有时称为二进制文件)中的代码；数据段存放的就是程序中全局变量和静态变量；堆中是程序的动态内存区域，当程序使用malloc或new得到的内存是来自堆的；栈中维护的是函数调用的上下文，离开了栈就不可能实现函数的调用。</description>
    </item>
    
    <item>
      <title>用go实现跨平台Autoit_AutoHotkey和按键精灵功能示例代码</title>
      <link>https://yushuangqi.com/blog/2016/yong-goshi-xian-kua-ping-tai-autoit_autohotkeyhe-an-jian-jing-ling-gong-neng-shi-li-dai-ma.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:32:50 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yong-goshi-xian-kua-ping-tai-autoit_autohotkeyhe-an-jian-jing-ling-gong-neng-shi-li-dai-ma.html.html</guid>
      <description>Robotgo v0.40.0对鼠标键盘操作进行了大幅度的完善,由于跨平台切换测试麻烦(合并几个平台的代码到对比上传代码都浪费了不少时间)和C代码生产效率与Go和JavaScript不在一个级别上,没有支持窗口和进程对应窗口的选择以及窗口Bounds,将在下一个版本完善,键盘操作可能在某些输入法上有些问题请切换到系统输入法(目前优先完成窗口句柄的问题,后面会解决该问题).
项目地址:https://github.com/go-vgo/rob&amp;hellip;
下面整理本机测试部分的代码,将会在以后版本陆续完善,并附上注释(请看清代码再运行):
package main import ( . &amp;quot;fmt&amp;quot; &amp;quot;github.com/go-vgo/robotgo&amp;quot; ) func main() { //键盘控制 robotgo.TypeString(&amp;quot;Hello World&amp;quot;)//输入Hello World robotgo.KeyTap(&amp;quot;enter&amp;quot;)//按下enter键 robotgo.KeyTap(&amp;quot;a&amp;quot;, &amp;quot;control&amp;quot;) robotgo.KeyTap(&amp;quot;h&amp;quot;, &amp;quot;command&amp;quot;) //隐藏窗口 robotgo.KeyTap(&amp;quot;i&amp;quot;, &amp;quot;alt&amp;quot;, &amp;quot;command&amp;quot;) //按下&amp;quot;i&amp;quot;, &amp;quot;alt&amp;quot;, &amp;quot;command&amp;quot;组合键 arr := []string{&amp;quot;alt&amp;quot;, &amp;quot;command&amp;quot;} robotgo.KeyTap(&amp;quot;i&amp;quot;, arr) //按下&amp;quot;i&amp;quot;, &amp;quot;alt&amp;quot;, &amp;quot;command&amp;quot;组合键 robotgo.KeyTap(&amp;quot;w&amp;quot;, &amp;quot;command&amp;quot;) //关闭窗口 robotgo.KeyTap(&amp;quot;m&amp;quot;, &amp;quot;command&amp;quot;) //最小化窗口 robotgo.KeyTap(&amp;quot;f1&amp;quot;, &amp;quot;control&amp;quot;) robotgo.KeyTap(&amp;quot;a&amp;quot;, &amp;quot;control&amp;quot;) robotgo.KeyToggle(&amp;quot;a&amp;quot;, &amp;quot;down&amp;quot;)//切换a键 robotgo.KeyToggle(&amp;quot;a&amp;quot;, &amp;quot;down&amp;quot;, &amp;quot;alt&amp;quot;) robotgo.KeyToggle(&amp;quot;a&amp;quot;, &amp;quot;down&amp;quot;, &amp;quot;alt&amp;quot;, &amp;quot;command&amp;quot;) robotgo.KeyToggle(&amp;quot;enter&amp;quot;, &amp;quot;down&amp;quot;) robotgo.TypeString(&amp;quot;en&amp;quot;) //鼠标控制 robotgo.MoveMouse(100, 200)//移动鼠标到100, 200位置 robotgo.MouseClick()//鼠标左键单击 robotgo.MouseClick(&amp;quot;right&amp;quot;, false) //右键单击 robotgo.</description>
    </item>
    
  </channel>
</rss>