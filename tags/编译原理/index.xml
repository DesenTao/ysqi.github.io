<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>极客虞双齐</title>
    <link>https://yushuangqi.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.xml</link>
    <description>在 极客虞双齐上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go1_8rc3源代码学习:token</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-token.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:15 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-token.html</guid>
      <description>https://segmentfault.com/a/
前言 token package 包含了 golang 词法分析相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/token
token.go 源代码中的注释很赞！
Token type Token is the set of lexical tokens of the Go programming language
type Token int  tokens The list of tokens（token ids）
const ( // Special tokens ILLEGAL Token = iota EOF COMMENT literal_begin ... literal_end operator_beg ... operator_end keyword_beg ... keyword_end )  使用 const 定义了 Go 语言 tokens，这里有一个地方值得学习：使用 xxx_beg 和 xxx_end 这一对伪 token 作为不同的 token group 分界，方便快速判断 token 类型，比如判断 token id 是否是一个关键字</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:scanner</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-scanner.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:14 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-scanner.html</guid>
      <description>https://segmentfault.com/a/
前言 scanner package 包含了 golang 词法分析器相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/scanner
example_test.go example_test.go 包含了一个使用 scanner 包的示例方法，该方法对 Euler 公式进行词法扫描
func ExampleScanner_Scan() { // src is the input that we want to tokenize. src := []byte(&amp;quot;cos(x) + 1i*sin(x) // Euler&amp;quot;) // Initialize the scanner. var s scanner.Scanner fset := token.NewFileSet() // positions are relative to fset file := fset.AddFile(&amp;quot;&amp;quot;, fset.Base(), len(src)) // register input &amp;quot;file&amp;quot; s.Init(file, src, nil /* no error handler */, scanner.ScanComments) // Repeated calls to Scan yield the token sequence found in the input.</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:parser</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-parser.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:13 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-parser.html</guid>
      <description>https://segmentfault.com/a/
前言 parser package 包含了 golang 语法分析相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/parser
之前大概看了点 PHP 和 Ruby 的源代码，感叹 go 确实如宣传的一样，简洁如 C，parser.go 代码总共 几千行（Ruby 语法规则定义文件有 1w 多行），使用递归下降语法分析方法（感觉 go 语言的语法规则很适合递归下降）
example_test.go parser package 里面也有一个示例 example_test.go，如何使用 parser
func ExampleParseFile() { fset := token.NewFileSet() // positions are relative to fset // Parse the file containing this very example // but stop after processing the imports. f, err := parser.ParseFile(fset, &amp;quot;example_test.go&amp;quot;, nil, parser.ImportsOnly) if err != nil { fmt.Println(err) return } // Print the imports from the file&#39;s AST.</description>
    </item>
    
    <item>
      <title>MiniJava语言编译器的Golang实现。</title>
      <link>https://yushuangqi.com/blog/2016/minijavayu-yan-bian-yi-qi-de-golangshi-xian-.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:18 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/minijavayu-yan-bian-yi-qi-de-golangshi-xian-.html</guid>
      <description> Dog-comp Abstract 文章介绍一个编译器的实现流程。源语言选用MiniJava. MiniJava是一个面向对象语言，支持继承，对象创建等面向对象的特性。具体语法参考Tiger book 附录。
Dog-comp是一个用golang实现的minijava编译器，目前可以将minijava翻译成c。dog-comp包括前端的lexer，parser，type-checking，codegen，后端还有基于minijava-AST的优化，基于控制流图的优化。为了满足minijava面向对象的特性，Dog-comp还带有一个runtime，实现了一个垃圾收集器。Dog-comp可以作为学习编译器和语言优化的一个小工具。
lexer 虽然目前已经有了词法分析器的生成器，但是Dog-comp使用了转移图(TDA)算法手工实现lexer。
parser Dog-comp的parser使用LL(1)。在Exp与Stm的处理上进行了文法改写，避免了二义性。
elaborator 编译器是一个典型的现行结构，类型检查的输入就是parser的输出，也就是源语言的Ast。
codegen 在代码生成的环节，将源语言的Ast翻译成了C语言的Ast，时候将C-Ast进行打印，实际上就完成了翻译。但是，这里有几个地方需要注意。将一个面向对象的语言翻译成C这样的语言，我们需要在中间做一些变换，这些变换实际上也就是面向对象语言的实现技术。
什么是对象？ 这里要说对象到底是什么。对象里面可以有数据，还可以有函数，所以我们可以说对象是数据和操作这些数据的函数的集合。换到C语言里面，对象不能仅仅用一个structure表示，这里也就出现了虚函数表的概念。我们可以将数据和一个函数表组合成一个structure，这个structure其实就是java的对象。
Flattening 所谓的平坦化，就是将java的Class全部消除。显然，在C里面，所有的函数都是平坦的。
垃圾收集器 编译生成的C文件和runtime.c一起编译成可执行文件，使得c带有垃圾收集的功能。为了支持垃圾收集，必须在c的structure里面在加入一些字段，用于GC记录对象的状态。比如需要记录这个对象中那些字段是引用，这个对象是普通对象还是数组对象等等。
优化！ Dog-comp在源码Ast级别上做了4个优化。
 死类删除
 死代码删除
 代数化简
 常量折叠
  DeadClass Elimination 
如上图所示，class Fac是一个根本没有被用到的类，经过死类删除之后，Fac被干掉了。
DeadCode Elimination 
上图的程序包含着死代码。显然，if的else分支是不可能执行的，最后一个while也没有执行的可能。所以经过死代码删除，这两段代码会直接消失。
这里有一个问题需要注意，while(true){}和while(false){}是否应该同样对待呢？while(false)显然是死代码，但是while(true)是否应该被删除呢？答案是否定。
AlgSimp 代数化简主要是针对运算，比如i=a*b*0*(a+2)/m),右侧的表达式可以直接优化为0.
ConstFold 常量折叠是在编译期把常量上的运算做完。
上图的代码中有很多可以优化的地方。执行完常量折叠之后代码如下图。
这里可以观察到，进行完常量折叠之后，实际上有产生的死代码，程序可以继续优化。所以这4个优化不停循环的作，直到达到不动点为止。
CFG 控制流图是一种方便优化的中间表示。如下图就是LinkedList.java中Equal函数的控制流图。
可以使用
dog-comp/$ ./dog-comp ../test/LinkedList.java -visualize svg 生成。  </description>
    </item>
    
  </channel>
</rss>