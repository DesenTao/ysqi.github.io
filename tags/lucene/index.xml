<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/lucene.xml</link>
    <description>在 虞双齐的博客上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <atom:link href="/tags/lucene.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>go如何使用SIMD指令</title>
      <link>https://yushuangqi.com/blog/2016/go-ru-he-shi-yong--simd-zhi-ling.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:26 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/go-ru-he-shi-yong--simd-zhi-ling.html</guid>
      <description>Java SIMD Lucene Elasticsearch 我们首先来看一下 JAVA 如何使用 CPU 的 SIMD 指令。这是一个ru的哥们尝试在lucene里使用SIMD指令加速lucene的postings list（也就是指定term对应的文档id列表）的解码：
http://blog.griddynamics.com/2015/02/proposing-simd-codec-for-lucene.h&amp;hellip;
https://www.youtube.com/watch?v=2HQdbpgHfnQ&amp;amp;index=15&amp;amp;list=PLq-&amp;hellip;
最重要的结论就是 java 自身还不支持JIT（运行时产生的机器码）出SIMD指令。如果用 c/asm 编写 SIMD 的代码，在 java 里调用的话 JNI 本身的开销抵消了 SIMD 带来的好处。所以最终需要使
用一种更底层的方式访问 native 代码：
http://stackoverflow.com/questions/24746776/what-does-a-jvm-have-to-do&amp;hellip;
值得一提的是 elasticsearch 从 2.0 大幅加强了 aggregation，现在已经开始支持 pipeline 了。可以写出类似 select sum(money) / sum(users_count) from payment 之类的代码了。自然 SIMD 的优化也可以做到 aggregation 阶段里去。
https://www.elastic.co/guide/en/elasticsearch/reference/master/search-&amp;hellip;
Go CGO CGO 慢，显而易见。
https://github.com/golang/go/blob/master/src/runtime/cgocall.go
具体来说就是这几行
 /* * Announce we are entering a system call * so that the scheduler knows to create another * M to run goroutines while we are in the * foreign code.</description>
    </item>
    
  </channel>
</rss>