<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go1.8 on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/go1.8.html</link>
    <description>在 虞双齐的博客上关于in Go1.8 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 18 Feb 2017 11:13:48 +0800</lastBuildDate>
    <atom:link href="/tags/go1.8.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gounsafe包</title>
      <link>https://yushuangqi.com/blog/2017/go-unsafebao.html.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:48 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-unsafebao.html.html</guid>
      <description>Go unsafe包
unsafe包概述 直到现在（Go1.7），unsafe包含以下资源：
三个函数：
// unsafe.Sizeof函数返回操作数在内存中的字节大小,参数可以是任意类型的表达式,但是它并不会对表达式进行求值. // 一个Sizeof函数调用是一个对应uintptr类型的常量表达式, // 因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量. func Sizeof(x ArbitraryType) uintptr //函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞. func Offsetof(x ArbitraryType) uintptr //unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数. func Alignof(x ArbitraryType) uintptr   内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 和一种类型：
type Pointer *ArbitraryType  这里，ArbitraryType不是一个真正的类型。官方导出这个类型只是出于完善文档的考虑，在其他的库和任何项目中都没有使用价值，除非程序员故意使用它。
 unsafe.Sizeof, Alignof 和 Offsetof  计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
 由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 一个结构体变量 x 以及其在64位机器上的典型的内存. 灰色区域是空洞.
var x struct { a bool b int16 c []int }  对结构体变量的三个字段调用unsafe包相关函数的计算结果如下，</description>
    </item>
    
    <item>
      <title>Go1_8httpgraceful体验</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:47 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html.html</guid>
      <description>很高兴Go 1.8发布了，这是个值得庆祝的日子。
如何优雅的关闭http服务在Go Web开发中一直被提及和讨论的话题，今天Go 1.8的发布终于为我们带来了这个特性。
文档中是这样介绍的：
func (srv *Server) Shutdown(ctx context.Context) error  Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：
 首先关闭所有的监听
 然后关闭所有的空闲连接
 然后无限期等待连接处理完毕转为空闲，并关闭
 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误
  需要注意的是，Shutdown 并不尝试关闭或者等待 hijacked连接，如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。
其实，你只要调用 Shutdown 方法就好了。
简单示例：
// main.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;os/signal&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World, %v\n&amp;quot;, time.Now()) }) s := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: http.</description>
    </item>
    
  </channel>
</rss>