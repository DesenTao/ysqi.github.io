<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/b</link>
    <description>在 虞双齐的博客上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <atom:link href="/tags/b#43%E6%A0%91.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用Golang写一个搜索引擎(0x04)---B&amp;#43;树</title>
      <link>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing--0x04-----b</link>
      <pubDate>Sat, 31 Dec 2016 11:33:48 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing--0x04-----b</guid>
      <description>本篇较长较枯燥，请保持耐心看完。
前面两章介绍了一下倒排索引以及倒排索引字典的两种存储结构，分别是跳跃表和哈希表，本篇我们介绍另一种数据结构，他也被大量使用在信息检索领域，我在github上实现的搜索引擎的词典也是用的这个数据结构，它就是B+树。
首先，我们看看什么是树，树是程序设计中一个非常基础的数据结构，记得大学时候的数据结构课，链表，栈，队列，然后就是树了，虽然那时候想必大家都被前序遍历，中序遍历，后序遍历折腾过，不过树确实是一种非常有用的数据结构。
上一篇我们说过，表2的第一列首要解决的问题就是能快速找到对应的词，然后找到对应词的倒排列表，除了跳跃表和哈希表，B+树也能满足条件，B+树是B树的变种，我们B树我们就不看了，感兴趣的大家可以直接去google一下，我们主要讲的是B+树，下图就是一个3层的B+树，我画出来可能和大家搜出来的有点出入，但是没关系，关键B+树这种数据结构的思想大家了解了就行。
假设我们有一组数字 34，40，67，5，37，12，45，24，那么，把他们存成B+树就是下图这个样子。
我们很明显看到几个特点
 每个节点的大小为2
 非叶子层的最后一个节点的最后一个元素为NULL
 最底层的叶子节点是顺序排列的，这个例子是从小到大
 上面的内节点的每一个元素都指向的下一级节点中最大的一个数相等
  我尽量的把B+树说简单点，网上的资料也好，查书也好，看上去都挺复杂的，首先我们看看怎么建立这棵树，我尽量用图了，少一些文字也好理解一点，前方大量图预警。
首先，我们的数组是34，12，5，67，37，40，45，24
第一步，初始化B+树，是这样子的 这时候，啥也没有，但是占用了两个节点，标识为无的，表示这个元素无意义，标记为NULL表示无穷大
第二步，插入34这个元素，那么图变成这样子 我们看到，插入的过程是顺着指针一直走到叶子节点，发现叶子节点是空的，然后把元素插入到叶子节点的头部，然后返回上一级节点，将NULL后移，然后把第一个元素置为他的子节点的最大值，请记住这句话：置为他的子节点的最大值
第三步，接着插入第二个元素12 这个步骤复杂一点
 从根节点开始遍历，发现12小于根节点的某一个元素【在这里是第1个元素】，顺着指针往下走
 到达叶子节点，发现12小于叶子节点的某一个元素，说明可以放在这个叶子节点中，并且叶子节点还有一个空位置，那么直接把12按大小顺序插入到这个节点中
  第四步，然后是插入5 这一步更复杂一点，产生了分裂
 从根节点开始遍历，5小于34，顺着指针往下走，到达叶子节点
 到达叶子节点，发现5小于叶子节点的某一个元素，说明可以放在这个叶子节点中，但是，这个节点已经满了，那么，分裂出一个新的节点，将5放到老节点中，被挤走的元素顺移到新节点中
 返回上一级节点，由于第一个叶子节点的最大元素已经变成12了，所以将该节点的元素由34改成指向的叶子节点的最大元素12
 由于新生成了一个节点，将NULL这个元素指向新生成的节点
  第五步，接着我们插入67 这一步比较简单
 从根节点开始遍历，67小于NULL，顺着指针往下走，到达叶子节点
 到达叶子节点，发现67大于该节点的每一个元素，并且叶子节点有空位，直接插入即可
  第六步，我们插入37，插完这个后面的我就不写了，感兴趣可以自己画一下 这一步复杂了，这一步不仅分裂了，而且分裂了两次，并且层数增加了一层
 从根节点开始遍历，37小于NULL，顺着指针往下走，到达叶子节点
 到达叶子节点，37小于叶子节点中的67，表示可以插入到这个节点中，但是节点满了，我们按照第四步的操作，分裂节点。
 分裂完了以后，产生了一个[34,37]，一个[67,无]两个节点，往上走的时候，发现上一层的节点插入了37以后也满了，继续按照第四步分裂。
 分裂完了以后，发现上层没有节点了，那么就新建一个根节点当上层节点，按照分裂的步骤给根节点赋值。
  按照这六步，前5个元素就插入到B+树中了，后面的步骤您可以自己走一走，B+树基本的思想就是这样子的，可能我没有按照教科书上的做法来说，但这并不影响大家的理解，我相信看完了以后虽然你脑子里没有标准的算法步骤，但应该有个大致的轮廓了，只不过需要自己再仔细想想步骤。
总的来说，B+树的插入步骤无外乎以下几个步骤  每次都要从根节点开始
 比较大小，找到小于当前值的元素，顺着指针往下走，继续比较大小，一直到达叶子节点，那么这个叶子节点就是你要操作的节点了。</description>
    </item>
    
  </channel>
</rss>