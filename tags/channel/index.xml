<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发</title>
    <link>https://yushuangqi.com/tags/channel.xml</link>
    <description>在 虞双齐Golang开发上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/channel.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>在Golang中使用Go关键字和Channel实现并行</title>
      <link>https://yushuangqi.com/blog/2016/zai--golang-zhong-shi-yong--go-guan-jian-zi-he--channel-shi-xian-bing-hang.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/zai--golang-zhong-shi-yong--go-guan-jian-zi-he--channel-shi-xian-bing-hang.html</guid>
      <description>Go 关键字和 channel 的用法 go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下： //go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体 go GetThingDone(param1, param2); //上例的变种，新建一个匿名方法并执行 go func(param1, param2) { }(val1, val2) //直接新建一个 goroutine 并在 goroutine 中执行代码块 go { //do someting... }  因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。 //resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。 var resultChan chan int //将 123 放到这个信封里面，供别人从信封中取用 resultChan &amp;lt;- 123 //从 resultChan 中取值。这个时候 result := 123 result := &amp;lt;- resultChan  使用 go 关键字和 channel 实现非阻塞调用 阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.</description>
    </item>
    
    <item>
      <title>Go语言并发模型:像UnixPipe那样使用channel</title>
      <link>https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-xiang-unix-pipena-yang-shi-yong-channel.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:13 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-xiang-unix-pipena-yang-shi-yong-channel.html</guid>
      <description>简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。
本文要讲的就是一些使用流水线的一些例子，流水线的错误处理也是本文的重点。
阅读建议 数据流水线充分利用了多核特性，代码层面是基于 channel 类型 和 go 关键字。
channel 和 go 贯穿本文的始终。如果你对这两个概念不太了解，建议先阅读之前公众号发布的两篇文章：Go 语言内存模型(上/下)。
如果你对操作系统中&amp;rdquo;生产者&amp;rdquo;和&amp;rdquo;消费者&amp;rdquo;模型比较了解的话，也将有助于对本文中流水线的理解。
本文中绝大多数讲解都是基于代码进行的。换句话说，如果你看不太懂某些代码片段，建议补全以后，在机器或play.golang.org 上运行一下。对于某些不明白的细节，可以手动添加一些语句以助于理解。
由于 Go语言并发模型 的英文原文 Go Concurrency Patterns: Pipelines and cancellation 篇幅比较长，本文只包含 理论推导和简单的例子。
下一篇文章我们会对 &amp;ldquo;并行MD5&amp;rdquo; 这个现实生活的例子进行详细地讲解。
什么是 &amp;ldquo;流水线&amp;rdquo; (pipeline)? 对于&amp;rdquo;流水线&amp;rdquo;这个概念，Go语言中并没有正式的定义，它只是很多种并发方式的一种。这里我给出一个非官方的定义：一条流水线是 是由多个阶段组成的，相邻的两个阶段由 channel 进行连接；
每个阶段是由一组在同一个函数中启动的 goroutine 组成。在每个阶段，这些 goroutine 会执行下面三个操作：
 通过 inbound channels 从上游接收数据
 对接收到的数据执行一些操作，通常会生成新的数据
 将新生成的数据通过 outbound channels 发送给下游
  除了第一个和最后一个阶段，每个阶段都可以有任意个 inbound 和 outbound channel。</description>
    </item>
    
  </channel>
</rss>