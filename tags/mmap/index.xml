<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mmap on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/mmap.html</link>
    <description>在 虞双齐的博客上关于in Mmap 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:33:50 +0800</lastBuildDate>
    <atom:link href="/tags/mmap.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>用Golang写一个搜索引擎(0x02)---倒排索引技术</title>
      <link>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing-0x02----dao-pai-suo-yin-ji-shu.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:50 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yong-golangxie-yi-ge-sou-suo-yin-qing-0x02----dao-pai-suo-yin-ji-shu.html</guid>
      <description>https://segmentfault.com/a/
这一篇，我们来说说搜索引擎最核心的技术，倒排索引技术，倒排索引可能需要分成几篇文章才说得完，我们先会说说倒排索引的技术原理，然后会讲讲怎么用一些数据结构和算法来实现一个倒排索引，然后会说一个索引器怎么通过文档来生成一个倒排索引。
倒排索引 什么是倒排索引呢？索引我们都知道，就是为了能更快的找到文档的数据结构，比如给文档编个号，那么通过这个号就可以很快的找到某一篇文档，而倒排索引不是根据文档编号，而是通过文档中的某些个词而找到文档的索引结构。
倒排索引技术简单，高效，简直是为搜索引擎这种东西量身定做的，就是靠这个技术，实现一个搜索引擎才成为可能，我们也才能在海量的文章中通过一个关键词找到我们想要的内容。
我们看个例子，有下面的几个文档：
文档编号 文档内容
1 这是一个Go语言实现的搜索引擎 2 PHP是世界上最好的语言 3 Linux是C语言和汇编语言实现的 4 谷歌是一个世界上最好的搜索引擎公司
直观的看，我们通过编号1,2,3,4可以很快的找到文档，但是我们需要通过关键词找文档，那么把上面那个表格稍微变化一下，就是倒排索引了
倒排索引【只列出了部分关键词】
关键词 文档编号
Go 1 语言 1，2，3 实现 1，3 搜索引擎 1，4 PHP 2 世界 2，4 最好 2，4 汇编 3 公司 4
这样就非常好理解了吧，实际上倒排索引就是把文档的内容切词以后重新生成了一个表格，通过这个表格，我们可以很快的找到每个关键词对应的文档，好了，没有了，到这里，就是倒排索引的核心原理，也是搜索引擎最基础的基石，不管是谷歌还是某度，最核心的东西就是这两个表格了，呵呵，没这两表格，啥都干不了。
看上去很简单吧，好吧，我们现在来模拟搜索引擎进行一次搜索，比如，我们键入关键词搜索引擎
1.我们在表格2中查到搜索引擎这个词出现在第4行
2.找到第4行的第2列，把文档编号找出来，是1和4
3.去第一个表格通过文档编号把每个文档的实际内容找出来
4.将1和4的结果显示出来
5.搜索完成
上面就是搜索引擎的最基础的技术了，如果来设计一个数据结构和算法来实现表2就成了搜索引擎技术的关键。
在实现数据结构和算法之前，我们需要知道搜索引擎搜索的是海量的数据，一般的中型电商的数据都是几十上百G的数据了，所以这个数据结构应该是存储在本地磁盘的而不是在内存中的，基于以上的考虑，为了快速搜索，要么自己实现cache来缓存热数据，要么考虑使用操作系统的底层技术MMAP，鉴于我自己实现的cache不见得（基本上是不太可能）比操作系统做得好，所以我使用的是MMAP。
MMAP系统调用  mmap是将一个文件或者其它对象映射进内存。文件被映射到多个页上，如果文件的大小不是所有页的大小之和，最后一个页不被使用的空间将会清零。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。
 mmap最大的一个好处是操作系统会自己将磁盘上的文件映射到内存，当内存足够的时候，操作文件就像操作内存一样快，而当内存不足的时候，操作系统又会自己将一些页从内存中去掉，实现了一个类似缓存的东西。特别适合于对于巨大文件的读操作，而我们的倒排索引文件就是这种巨大的文件，而且基本上写入一次以后就不太修改了，每次查询都读操作，所以使用mmap是一个比较好的选择。
mmap是一个系统调用，不同的操作系统实现有所不同，Linux下对应的C的调用方法是下面这个，具体的参数含义大家可以man一下：
 头文件 &amp;lt;sys/mman.h&amp;gt;
函数原型
void mmap(void start,size_t length,int prot,int flags,int fd,off_t offset);
 一个巨大的文件mmap之后，文件读写操作的性能由系统内存决定，系统可用内存越大，那么读写文件的性能越好，因为操作系统的内存足够，系统会将更多的文件载入到内存，提高系统吞吐量。
在Go语言中，对应的MMAP调用是：（需要引入Syscall包）
 func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, err error)</description>
    </item>
    
  </channel>
</rss>