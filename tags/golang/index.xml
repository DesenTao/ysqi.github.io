<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/tags/golang.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/golang.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>GoDoc文档使用</title>
      <link>https://yushuangqi.com/blog/2017/goyu-yan-shi-zhan-bi-ji-san--go-doc-wen-dang.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:09 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/goyu-yan-shi-zhan-bi-ji-san--go-doc-wen-dang.html</guid>
      <description>《Go语言实战》读书笔记，未完待续，欢迎关注公众号flysnow_org，第一时间看后续笔记。
 对于协作开发或者代码共享来说，文档是一个可以帮助开发者快速了解以及使用这些代码的一个教程，文档越全面，越详细，入门越快，效率也会更高。
在Go语言中，Go为我们提供了快速生成文档以及查看文档的工具，让我们可以很容易的编写查看文档。
Go提供了两种查看文档的方式，一种是使用go doc命令在终端查看，这种适用于使用VIM等工具在终端开发的人员，它们不用离开终端，既可以查看想查看的文档，又可以编码。
第二种方式，是使用浏览器查看的方式，通过godoc命令可以在本机启动一个web服务，我们可以通过打开浏览器，访问这个服务来查看我们的Go文档。
从终端查看文档 这种方式适用于在终端开发的，它们一般不像离开终端，查完即可继续编码，这时候使用go doc命令是很不错的选择。
➜ hello go help doc usage: go doc [-u] [-c] [package|[package.]symbol[.method]] Doc prints the documentation comments associated with the item identified by its arguments (a package, const, func, type, var, or method) followed by a one-line summary of each of the first-level items &amp;quot;under&amp;quot; that item (package-level declarations for a package, methods for a type, etc.). Flags: -c Respect case when matching symbols.</description>
    </item>
    
    <item>
      <title>Go配置文件热更新</title>
      <link>https://yushuangqi.com/blog/2017/golangpei-zhi-wen-jian-re-geng-xin.html</link>
      <pubDate>Mon, 13 Mar 2017 07:58:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangpei-zhi-wen-jian-re-geng-xin.html</guid>
      <description>配置文件热更新是服务器程序的一个基本功能，通过热更新可以不停机调整程序的配置，特别是在生产环境可以提供极大的便利，比如发现log打得太多了可以动态调高日志等级，业务逻辑参数变化，甚至某个功能模块的开关等都可以动态调整。
每种语言都有自己的热更新实现方式，在golang里面我看到了有人采用了一种错误的实现方式，如下：
type Config struct { Test1 string `json:&amp;quot;Test1&amp;quot;` Test2 int `json:&amp;quot;Test2&amp;quot;` } var ( config *Config ) func loadConfig() { f, err := ioutil.ReadFile(&amp;quot;config.json&amp;quot;) if err != nil { fmt.Println(&amp;quot;load config error: &amp;quot;, err) } err = json.Unmarshal(f, &amp;amp;config) if err != nil { fmt.Println(&amp;quot;Para config failed: &amp;quot;, err) } } func init() { loadConfig() fmt.Println(&amp;quot;Load config: &amp;quot;, *config) s := make(chan os.Signal, 1) signal.Notify(s, syscall.SIGUSR2) go func() { for { &amp;lt;-s loadConfig() fmt.</description>
    </item>
    
    <item>
      <title>为什么Go语言在中国格外的火</title>
      <link>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:23 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</guid>
      <description>go语言推出有几年了，似乎不温不火。但是在中国范围内，确实被关注的一塌糊涂。
这是2017年2月份TIOBE出的编程语言排名：
在拉勾网上搜索go的职位，结果有119个(2017年2月14日搜索结果)，似乎还没有那么火爆：
但是在中国，很多公司，很多程序员都在谈论go语言，也就是说在中国对于go的关注异常火爆。
根据谷歌搜索的统计，如下图： The graph above shows the searches for “golang” by country on Google Trends.
外国人专门写了一篇文章，来分析为什么go在中国如此火： ( 《Why is Golang popular in China?》)http://herman.asia/why-is-go-popular-in-china
下面是知乎的回复： 作者：匿名用户
链接：https://www.zhihu.com/question/30172794/answer/47122000
来源：知乎 著作权归作者所有，转载请联系作者获得授权。
这个“火”字看你怎么理解了。 Go在国内更火只是感觉上的。比如推文，以及谈论的相关话题较多而已(但能有nodejs多么？)，本身中国人口数量就多，按这个衡量的办法去看的话，swift在国内也比在国外火； 实际上Go在国外更火（这里的火是实际的使用情况），对比一下国内和国外使用Go的程度、数量，Go相关的技术大会举办的频率和数量就一目了然了。
Go在国内真正上被全栈使用的就七牛一家，但国外除了docker，coreOS还有很多初创企业。 国内比较有影响力的就一个beego框架，你看看国外的有多少。
去github上搜一下active的Go的project数量，看看Go在国外是不是没人用？我反正在github的trending里面几乎每天都能看到Go的project。hacker news上面有关Go的“xxx writen in Go”的炒作文也不要太多。 这个 dariubs/GoBooks · GitHub 是有人整理的Go相关的书籍，看看是不是国外的书籍比国内的少？8月份K&amp;amp;R中的K也要推出属于Go的圣经了。
另外老有人喜欢说：Google喜欢关闭产品，这玩意儿迟早死掉。可惜golang是开源项目，关不掉的，CloudFlare那个crypto的patch(Gerrit Code Review)以后可能会进Go的标准库，Godep已经成为事实上的包管理标准，这些都是社区自己搞出来的，和google一毛线关系没有。另外就是最近google自己一些主力产品或者平台在优先支持语言上，Go总是和java，c/c++，python一起名列其中，grpc就是一个例子等等。所以，觉得Go只是google的一个玩具的人，你的观点能不能站得住脚，自己掂量吧。
我的个人观点是： Go显示已经站住了脚跟(如果是2013年，我还是不敢说这种话的)，找到了属于自己的空间，但是比起那些主流的甚至nodeJS来说，还是使用的不够广泛。这个语言人为炒作也罢，一些人认为的google光环也罢，实际使用也罢，总之： 这个语言已经站住脚跟了，能用于并且已经用于生产环境了，接下来几年只会一直呈上升势头。
个人观点：
1 一些真正使用go语言的公司：
这些公司在高速发展的同时，Golang也因此在国内逐渐传播开来。在云计算时代，从国内Go 语言发展和应用来看，七牛算是国内第一家选 Go 语言做服务端的公司。早在2011年，当Go语法还没完全稳定下来的情况下，七牛就已经选择将Go作为存储服务端的主题语言。关于这点，七牛CEO许式伟谈到：编程哲学的重塑是 Go 语言独树一帜的根本原因，其它语言仍难以摆脱 OOP 或函数式编程的烙印，只有 Go 完全放弃了这些，对编程范式重新思考，对热门的面向对象编程提供极度简约但却完备的支持。Go 是互联网时代的C语言，不仅会制霸云计算，10 年内将会制霸整个 IT 领域。
2 在中国程序员眼中，谷歌出品必属精品 确实，在互联网世界，在开源世界，Google为我们贡献了太多太多。</description>
    </item>
    
    <item>
      <title>编写地道的Go代码</title>
      <link>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:58 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</guid>
      <description>在阅读本文之前，我先推荐你阅读官方的 Effective Go文档，或者是中文翻译版: 高效Go编程，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。
最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。
本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。
注释 可以通过 /* …… */ 或者 // ……增加注释， //之后应该加一个空格。
如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。
 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /*Package net provides a portable interface for network I/O, includingTCP/IP, UDP, domain name resolution, and Unix domain sockets....... */ package net......  注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在godoc中容易查找。</description>
    </item>
    
    <item>
      <title>Gonet_http包</title>
      <link>https://yushuangqi.com/blog/2017/go-net_httpbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:57 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-net_httpbao.html</guid>
      <description>Go net/http包
Go Http客户端 get请求可以直接http.Get方法
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;log&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;bytes&amp;quot; ) func main() { resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;) if err != nil { // handle error log.Println(err) return } defer resp.Body.Close() headers := resp.Header for k, v := range headers { fmt.Printf(&amp;quot;k=%v, v=%v\n&amp;quot;, k, v) } fmt.Printf(&amp;quot;resp status %s,statusCode %d\n&amp;quot;, resp.Status, resp.StatusCode) fmt.Printf(&amp;quot;resp Proto %s\n&amp;quot;, resp.Proto) fmt.Printf(&amp;quot;resp content length %d\n&amp;quot;, resp.ContentLength) fmt.Printf(&amp;quot;resp transfer encoding %v\n&amp;quot;, resp.</description>
    </item>
    
    <item>
      <title>Golang学习摘录一:初识</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</guid>
      <description>1、Hello Word编写方式 package main import &amp;quot;fmt&amp;quot; func main (){ fmt.Printf(&amp;quot;Hello, world&amp;quot;) }  编译 go build helloworld.go
运行 ./helloworld
2、声明方式 1、普通方式 var a int = 15 var b bool = false 或 var a int var b bool a = 15 b = false 2、 :=会自动匹配类型，只能在函数内使用 a := 15 b := false 3、中括号的形式： var ( x int b bool ) 4、平行赋值 a,b := 20,16 #注意 :Go 的编译器对声明却未使用的变量在报错。 5、常量，只能是数字、字符串或布尔值 const( // 枚举的生成方式 a = iota // a为0 b = iota // b为1，改行的 “=iota”可省略 ) 如果需要,可以明确指定常量的类型: const ( a = 0 b string = &amp;quot;0&amp;quot; )  3、字符串 var s string = &amp;quot;hello&amp;quot; #Go中字符串是不可变的  如果想修改字符需要使用下面的方法</description>
    </item>
    
    <item>
      <title>Golang语言常用算法</title>
      <link>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangyu-yan-chang-yong-suan-fa.html</guid>
      <description>在学习golang语言，文档看的实在是乏味，就想着把常用的算法做个实现，边写变学习，想来效果还是不错的！
​1. 堆排序
package main import &amp;quot;fmt&amp;quot; func buildHeap(array []int, length int) { var i, j int; for i = 1; i &amp;lt; length; i = i + 1 { for j = i; j &amp;gt; 0 &amp;amp;&amp;amp; array[j] &amp;gt; array[(j-1)/2]; j = (j - 1)/2 { array[j], array[(j-1)/2] = array[(j-1)/2], array[j] } } } func heapSort(array []int, length int) { array[0], array[length - 1] = array[length - 1], array[0] if length &amp;lt;= 2 { return } i, j:= 0, 0 for { j = 2 * i + 1 if j + 1 &amp;lt; length - 1 { if array[j] &amp;lt; array[j + 1] { j = j + 1 } } else if j &amp;gt;= length -1 { break } array[i], array[j] = array[j], array[i] i = j } heapSort(array, length - 1) } func main() { primes := [6]int{3, 11, 5, 2, 13, 7} fmt.</description>
    </item>
    
    <item>
      <title>Golang学习摘录三:函数</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-san-han-shu.html</guid>
      <description>函数定义 type mytype int // 新的类型 func (p mytype) funcname(q int) (r,s int) {return 0,0}  作用域 在 Go 中,定义在函数外的变量是全局的,那些定义在函数内部的变量,对于函数来说 是局部的。如果命名覆盖——一个局部变量与一个全局变量有相同的名字——在函数 执行的时候,局部变量将覆盖全局变量。
多值返回 func (file *File) Write(b []byte) (n int, err error)
Go得函数可以返回多个值
命名返回值 Go 函数的返回值或者结果参数可以指定一个名字,并且像原始的变量那样使用,就像 输入参数那样。如果对其命名,在函数开始时,它们会用其类型的零值初始化。如果 函数在不加参数的情况下执行了 return 语句,结果参数会返回。
例：
func ReadFull(r Reader, buf []byte) (n int, err error) { for len(buf) &amp;gt; 0 &amp;amp;&amp;amp; err == nil { var nr int nr, err = r.Read(buf) n += nr buf = buf[nr:len(buf)] } return }  延迟代码defer 在 defer 后指定的 函数会在函数退出前调用。</description>
    </item>
    
    <item>
      <title>Golang学习摘录二:控制语句</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-er-kong-zhi-yu-gou.html</guid>
      <description>if语句 i f x &amp;gt; 0 { // {是强制的,且必须和if在同一行 return y } else { return x }  if 和 switch 接受初始化语句,通常用于设置一个(局部)变量。
if err := Chmod(0664); err != nil { //nil 与 C 的 NULL 类似 fmt.Printf(err) //err 的作用域被限定在 if 内 return err }  goto语句 用 goto 跳转到一定是当前函数内定义的标签
func myfunc() { i := 0 Here: // 这行的第一个词,以分号结束作为标签,标签名区分大小写 println(i) i++ goto Here // 跳转 }  for语句 Go 的 for 循环有三种形式,只有其中的一种使用分号。</description>
    </item>
    
    <item>
      <title>Golang学习摘录七:并发</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-qi-bing-fa.html</guid>
      <description>Go使用channel和goroutine开发并行程序。goroutine 是 Go并发能力的核心要素。
goroutine 是一个普通的函数，只是需要使用关键字 go 作为开头。
ready(&amp;quot;Tea&amp;quot;, 2) // 普通函数调用 go ready(&amp;quot;Tea&amp;quot;, 2) // ready() 作为 goroutine 运行  Go routine实践
func ready(w string, sec int) { time.Sleep(time.Duration(sec) * time.Second) fmt.Println(w,&amp;quot;is ready!&amp;quot;) } func main() { go ready(&amp;quot;Tea&amp;quot;, 2) go ready(&amp;quot;Coffee&amp;quot;, 1) fmt.Println(&amp;quot;I&#39;m waiting&amp;quot;) time.Sleep(5 * time.Second) } // 输出 I&#39;m waiting //立刻 Coffee is ready! //1秒后 Tea is ready! //2秒回  如果不等待goroutine的执行（例如移除第17行），程序会立刻终止，而任何正在执行的goroutine都会停止。为了修复使用channels机制来和goroutine通讯。可以通过channel发送或接受值。这些值只能是特定的类型:channel 类型。
注意，必须使用 make 创建 channel：
ci := make(chan int) //创建 channel ci 用于发送和接收整数 cs := make(chan string) //创建 channel cs 用于字符串 cf:=make(chan interface{})//channel cf 使用了空接口来满足各种类型  向 channel 发送或接收数据，是通过类似的操作符完 成的:&amp;lt;−.</description>
    </item>
    
    <item>
      <title>Golang学习摘录五:进阶</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html</guid>
      <description>Go 有指针。然而却没有指针运算,因此它们更象是引用而不是你所知道的来自于 C 的指针。指针非常有用。在 Go 中调用函数的时候,得记得变量是值传递的。因此,为了修改一个传递入函数的值的效率和可能性,有了指针。
var p *int fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印nil var i int // 定义一个整型变量i p = &amp;amp;i // 使得p指向i fmt.Printf(&amp;quot;%v&amp;quot;, p) // 打印出来的内容类似0x7ff96b81c000a  内存分配 用new分配内存 内建函数 new 本质上说跟其他语言中的同名函数功能一样:new(T) 分配了零值填充 的 T 类型的内存空间,并且返回其地址,一个 *T 类型的值。用 Go 的术语说,它返回 了一个指针,指向新分配的类型 T 的零值。记住这点非常重要。
用make分配内存 内建函数 make(T, args) 与 new(T) 有着不同的功能。它只能创建 slice,map 和 channel,并且返回一个有初始值(非零)的 T 类型,而不是 *T。本质 来讲,导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。 例如,一个 slice,是一个包含指向数据(内部 array)的指针,长度和容量的三项描述 符;在这些项目被初始化之前,slice 为 nil。对于 slice,map 和 channel,make 初始 化了内部的数据结构,填充适当的值。</description>
    </item>
    
    <item>
      <title>Golang学习摘录六:接口</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html</guid>
      <description>Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集合。
// 这段代码定义了具有一个字段和两个方法的结构类型s。 type S struct { i int } func (p *S) Get() int { return p.i } func (p *S) Put(v int) { p.i = v } // 定义接口 type I interface { Get() int Put(int) } // 对于接口I，S是合法的实现，因为它定义了 I 所需的两个方法。注意：即便是没有明 确定义 S 实现了 I，这也是正确的。 // Go 程序的特性接口值： func f(p I) {// 定义一个函数接受一个接口类型作为参数 fmt.Println(p.Get()) // p实现了接口I，必须有Get()方法 p.Put(1) // Put()方法是类似的 // 这里的变量p保存了接口类型的值。 } // 调用 var s S f(&amp;amp;s) // 因为S实现了I，可以调用f向其传递S类型的值的指针 // 获取 s 的地址,而不是 S 的值的原因,是因为在 s 的指针上定义了方法,参阅上面的 代码 5.</description>
    </item>
    
    <item>
      <title>Golang学习摘录四:包</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:54 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html</guid>
      <description>包是函数和数据的集合。用 package 关键字定义一个包。文件名不需要与包名 一致。包名的约定是使用小写字符。Go 包可以由多个文件组成,但是使用相同的 package &amp;lt;name&amp;gt; 这一行。
package even func Even(i int) bool { return i%2==0 } func odd(i int) bool { return i%2==1 }  名称以大写字母起始的是可导出的，可以在包的外部调用。
共有函数的名称以大写字母开头。
私有函数的名称以小写字母开头。
package main import ( //导入下面的包 &amp;quot;event&amp;quot; //本地包even在这里导入 &amp;quot;fmt&amp;quot; ) func main(){ i := 5 fmt.Printf(&amp;quot;Is %d event? %v\n&amp;quot;, i,event.Even(i))// 调用even包中的函数。访问一个包中的函数的语法是&amp;lt;package&amp;gt;.Function()。 }  Go程序的命名规则：包名约定小写字母开头；方法名最好使用驼峰式名称，避免使用下划线，方法名应简洁清晰。
包的文档 每个包都应该有包注释,在 package 前的一个注释块。对于多文件包,包注释只需要 出现在一个文件前,任意一个文件都可以。包注释应当对包进行介绍,并提供相关于 包的整体信息。这会出现在 go doc 生成的关于包的页面上,并且相关的细节会一并 显示。
官方regexp包的例子：
 /* The regexp package implements a simple library for regular expressions.</description>
    </item>
    
    <item>
      <title>Goreflect包</title>
      <link>https://yushuangqi.com/blog/2017/go-reflectbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:53 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-reflectbao.html</guid>
      <description>Go reflect包
反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Type.
reflect 包中另一个重要的类型是 Value. 一个 reflect.Value 可以持有一个任意类型的值. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value. 和 reflect.TypeOf 类似, reflect.ValueOf 返回的结果也是对于具体的类型, 但是 reflect.Value 也可以持有一个接口值.
reflect.Type 类型 代码，
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;unsafe&amp;quot; ) // 嵌套结构体 type ss struct { a struct { int string } int string bool float64 } func (s ss) Method1(i int) string { return &amp;quot;结构体方法1&amp;quot; } func (s *ss) Method2(i int) string { return &amp;quot;结构体方法2&amp;quot; } var ( intValue = int(0) int8Value = int8(8) int16Value = int16(16) int32Value = int32(32) int64Value = int64(64) uIntValue = uint(0) uInt8Value = uint8(8) uInt16Value = uint16(16) uInt32Value = uint32(32) uInt64Value = uint64(64) byteValue = byte(0) runeValue = rune(0) uintptrValue = uintptr(0) boolValue = false stringValue = &amp;quot;&amp;quot; float32Value = float32(32) float64Value = float64(64) complex64Value = complex64(64) complex128Value = complex128(128) arrayValue = [5]string{} // 数组 sliceValue = []byte{0, 0, 0, 0, 0} // 切片 mapValue = map[string]int{} // 映射 chanValue = make(chan int, 2) // 通道 structValue = ss{ // 结构体 struct { int string }{10, &amp;quot;子结构体&amp;quot;}, 20, &amp;quot;结构体&amp;quot;, false, 64.</description>
    </item>
    
    <item>
      <title>Gobuild命令说明</title>
      <link>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</link>
      <pubDate>Wed, 22 Feb 2017 08:37:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</guid>
      <description>go help build
 构建编译由导入路径命名的包，以及它们的依赖关系，但它不会安装结果.
使用 go build [-o 输出名] [-i] [编译标记] [包名]  如果参数为***.go文件或文件列表，则编译为一个个单独的包。
当编译单个main包（文件），则生成可执行文件。
当编译单个或多个包非主包时，只构建编译包，但丢弃生成的对象（.a），仅用作检查包可以构建。
当编译包时，会自动忽略&amp;rsquo;_test.go&amp;rsquo;的测试文件。
参数 -o output 指定编译输出的名称，代替默认的包名。  -i install 安装作为目标的依赖关系的包(用于增量编译提速)。  以下 build 参数可用在 build, clean, get, install, list, run, test -a 完全编译，不理会-i产生的.a文件(文件会比不带-a的编译出来要大？) -n 仅打印输出build需要的命令，不执行build动作（少用）。 -p n 开多少核cpu来并行编译，默认为本机CPU核数（少用）。 -race 同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64. -msan 启用与内存消毒器的互操作。仅支持linux / amd64，并且只用Clang / LLVM作为主机C编译器（少用）。 -v 打印出被编译的包名（少用）. -work 打印临时工作目录的名称，并在退出时不删除它（少用）。 -x 同时打印输出执行的命令名（-n）（少用）. -asmflags &#39;flag list&#39; 传递每个go工具asm调用的参数（少用） -buildmode mode 编译模式（少用） &#39;go help buildmode&#39; -compiler name 使用的编译器 == runtime.</description>
    </item>
    
  </channel>
</rss>