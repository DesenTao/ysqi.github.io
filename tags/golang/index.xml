<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/tags/golang.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/golang.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Gobuild命令说明</title>
      <link>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</link>
      <pubDate>Wed, 22 Feb 2017 08:37:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ming-ling--go-build.html</guid>
      <description>go help build
 构建编译由导入路径命名的包，以及它们的依赖关系，但它不会安装结果.
使用 go build [-o 输出名] [-i] [编译标记] [包名]  如果参数为***.go文件或文件列表，则编译为一个个单独的包。
当编译单个main包（文件），则生成可执行文件。
当编译单个或多个包非主包时，只构建编译包，但丢弃生成的对象（.a），仅用作检查包可以构建。
当编译包时，会自动忽略&amp;rsquo;_test.go&amp;rsquo;的测试文件。
参数 -o output 指定编译输出的名称，代替默认的包名。  -i install 安装作为目标的依赖关系的包(用于增量编译提速)。  以下 build 参数可用在 build, clean, get, install, list, run, test -a 完全编译，不理会-i产生的.a文件(文件会比不带-a的编译出来要大？) -n 仅打印输出build需要的命令，不执行build动作（少用）。 -p n 开多少核cpu来并行编译，默认为本机CPU核数（少用）。 -race 同时检测数据竞争状态，只支持 linux/amd64, freebsd/amd64, darwin/amd64 和 windows/amd64. -msan 启用与内存消毒器的互操作。仅支持linux / amd64，并且只用Clang / LLVM作为主机C编译器（少用）。 -v 打印出被编译的包名（少用）. -work 打印临时工作目录的名称，并在退出时不删除它（少用）。 -x 同时打印输出执行的命令名（-n）（少用）. -asmflags &#39;flag list&#39; 传递每个go工具asm调用的参数（少用） -buildmode mode 编译模式（少用） &#39;go help buildmode&#39; -compiler name 使用的编译器 == runtime.</description>
    </item>
    
    <item>
      <title>go协程与主线程强占运行</title>
      <link>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:49 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</guid>
      <description>最近在学习了go 语言 , 正好学习到了 协程这一块 ,遇到了困惑的地方.这个是go语言官方文档 . 在我的理解当中是,协程只能在主线程释放时间片后才会经过系统调度来运行协程,其实正确的也确实是这样的,但是我遇到了协程强占主线程的一个问题,经过帮助,现在已经了解.废话不多说,先看代码
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { go say(&amp;quot;world&amp;quot;) say(&amp;quot;hello&amp;quot;) /* fmt.Println(&amp;quot;---------------1&amp;quot;) a := []int{7, 2, 8, -9, 4, 0} fmt.Println(&amp;quot;===&amp;quot;, a[:len(a)/2]) c := make(chan int) go sum(a[:len(a)/2], c) go sum(a[len(a)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // receive from c fmt.Println(x, y, x+y) fmt.Println(&amp;quot;---------------2&amp;quot;) c2 := make(chan int, 2) c2 &amp;lt;- 1 c2 &amp;lt;- 2 fmt.Println(&amp;lt;-c2) fmt.Println(&amp;lt;-c2) fmt.Println(&amp;quot;---------------3&amp;quot;) c3 := make(chan int, 10) go fibonacci(cap(c3), c3) for i := range c3 { fmt.</description>
    </item>
    
    <item>
      <title>Go1_8正式发布</title>
      <link>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:46 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</guid>
      <description>今天Go团队很高兴地宣布Go 1.8发布了。你可以从下载页面获得1.8版本。在这个版本中，整个标准库有显着的性能改进和变化。
Go 1.7中为64位x86系统引入的编译器后端现在用于所有体系结构，在这些体系结构下可以看到显着的性能改进。例如，我们的基准程序所需的CPU时间在32位ARM系统上减少了20-30％。在此版本中，对于64位x86系统也有一些性能提升。编译器和链接器跑得更快。编译时间应该比Go 1.7缩短约15％。在这一领域还有更多的工作要做：希望未来版本的编译速度更快。
垃圾收集暂停应明显更短，通常在100微秒以下，通常低至10微秒。
HTTP服务器添加对HTTP/2 Push的支持，允许服务器向客户端推送。这对于消除网络延迟非常有用。 HTTP服务器还添加了对优雅停机的支持，允许服务器完成正在运行的请求之后关闭从而最小化停机时间。
context（添加到Go 1.7中的标准库）提供了取消和超时机制。 Go 1.8在更多的标准库中添加了对context的支持，包括database/sql和net包以及net/http包中的Server.Shutdown。
现在使用新添加的Slice函数使得对slice进行排序更简单。例如，要通过“名称”字段对结构体片段进行排序：
Go 1.8包括很多新增API，以及老API的改进和修复。 你可以在Go 1.8发行说明中查找完整的修改列表，以及有关上面列出内容的详细信息。
为了庆祝新版发布，世界各地的Go用户组都在本周举办发布会。 发布会已经成为Go社区的一个传统，所以如果你错过了这一次，当1.9发布时应该注意了。
感谢超过200个贡献者谁帮助了1.8版本的发布。</description>
    </item>
    
    <item>
      <title>gogrpc安装</title>
      <link>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:45 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</guid>
      <description>Prerequisites Go version gRPC works with Go 1.5 or higher.
$ go version  For installation instructions, follow this guide: Getting Started - The Go Programming Language
Install gRPC Use the following command to install gRPC.
$ go get google.golang.org/grpc  Install Protocol Buffers v3 Install the protoc compiler that is used to generate gRPC service code. The simplest way to do this is to download pre-compiled binaries for your platform(protoc-&amp;lt;version&amp;gt;-&amp;lt;platform&amp;gt;.</description>
    </item>
    
    <item>
      <title>golangappend的并发问题</title>
      <link>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</guid>
      <description>先看一段代码
ackage main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var wg sync.WaitGroup s := make([]int, 0, 1000) for i := 0; i &amp;lt; 1000; i++ { v := i wg.Add(1) go func() { s = append(s, v) wg.Done() }() } wg.Wait() fmt.Printf(&amp;quot;%v\n&amp;quot;, len(s)) }  结果
第一次：928 第二次：945 第三次：986 ……  多运行几次你就会发现，slice长度并不是1000，而是不停的在变，为什么呢？
因为append并不是并发安全的。
我们举一个简单例子，比如，当A和B两个协程运行append的时候同时发现s[1]这个位置是空的，他们就都会把自己的值放在这个位置，这样他们两个的值就会覆盖，造成数据丢失。
那该怎么写？最简单的方式就是用锁，贴一个例子。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var ( wg sync.</description>
    </item>
    
    <item>
      <title>设计模式(golang)</title>
      <link>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</guid>
      <description>设计模式的六大原则 摘自 Java开发中的23种设计模式详解
 1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后 面的具体设计中我们会提到这点。
 2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何 基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受 到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。 实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽 象化的具体步骤的规范。—— From Baidu 百科
 3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
 4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出， 其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
 5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
 6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。
  实现代码 {#h1_1} https://github.com/BPing/golang_design_pattern/tree/master/pattern
 创建型 C 结构型 J 行为型 X   -AbstractFactory.go : 抽象工厂模式(C) -Adapter.go : 适配器模式(J) -Bridge.go : 桥接模式(J) -Builder.</description>
    </item>
    
    <item>
      <title>数据库不适合Docker及容器化的7大原因</title>
      <link>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:42 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</guid>
      <description>导读：所有的服务都开始了容器化升级，在一切皆容器的主流思想下，无状态的服务采用容器化已经是大势所趋，常常困扰架构师的一个问题是，数据库是否需要容器化，本文作者 Mikhail Chinkov 提出了自己否定观点，由高可用架构翻译。

如果我们观察 2017 年技术行业，容器和 Docker 依然将是最热门的流行语。我们开始在每个领域的 Docker 容器中打包开发的软件。从小型初创公司到巨大的微服务平台都在使用容器技术。从 CI 平台到 Raspberry Pi 。从数据库到……
数据库？您确定要将数据库放在容器中吗？
不幸的是，这不是虚构的场景。我看到许多快速增长的项目将数据持久化到容器中。并且将计算服务和数据服务放在同一台机器上。笔者希望有经验的人不会用这个解决方案。
下面是我的观点，数据库容器化从今天来看是非常不合理的。
数据库不适合容器化的7大原因 **
**
1. 数据不安全 
即使你要把 Docker 数据放在主机来存储 ，它依然不能保证不丢数据。 Docker volumes 的设计围绕 Union FS 镜像层提供持久存储，但它仍然缺乏保证。
使用当前的存储驱动程序，Docker 仍然存在不可靠的风险。 如果容器崩溃并数据库未正确关闭，则可能会损坏数据。

2. 运行数据库的环境需求 **
**
常看到 DBMS 容器和其他服务运行在同一主机上。 然而这些服务对硬件要求是非常不同的。
数据库（特别是关系型数据库）对 IO 的要求较高。 一般数据库引擎为了避免并发资源竞争而使用专用环境。如果将你的数据库放在容器中，那么将浪费你的项目的资源。 因为你需要为该实例配置大量额外的资源。 在公有云，当你需要 34G 内存时，你启动的实例却必须开 64G 内存。在实践中，这些资源并未完全使用。
怎么解决？ 您可以分层设计，并使用固定资源来启动不同层次的多个实例。 水平伸缩总是比垂直伸缩更好。 
3. 网络问题 **
**
要理解 Docker 网络，您必须对网络虚拟化有深入的了解。也必须准备应付好意外情况。你可能需要在没有支持或没有额外工具的情况下，进行 bug 修复。</description>
    </item>
    
    <item>
      <title>Go最新的dep详解</title>
      <link>https://yushuangqi.com/blog/2017/gozui-xin-de-depxiang-jie.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:41 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/gozui-xin-de-depxiang-jie.html</guid>
      <description>该文翻译自https://medium.com/i-can-haz-downtime/dep-101-c85e8ab6ed45#.hbngswi0e
我很高兴在过去几个月和几个其他gopher开发的一个原型依赖管理工具，名为dep。
dep是去年开始由Peter Bourgon组织的项目的一部分。由于我参与开发了一个“godep”，Go的OG依赖管理工具（继承自Keith Rarick），因此加入了dep项目的团队。
除了我自己和Peter，团队的其他成员是Jessie Frazelle，Andrew Gerrand和Sam Boyer。 Andrew是Google Go team的一员。 Jessie在Google工作，并参与过大型Go项目，如Docker和Kubernetes。 Sam维护gps。
该团队发布了一系列我们工作过程中的进展信息。到目前为止，各种其他工具作者和相关方也以不同的方式参与这一项目。
起初 假设我们正在使用github.com/gorilla/mux编写一个Web应用程序。 这里是一些代码，让我们开始：
package main import ( &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;github.com/gorilla/mux&amp;quot; ) func main() { r := mux.NewRouter() r.Handle(&amp;quot;/&amp;quot;, http.FileServer(http.Dir(&amp;quot;.&amp;quot;))) http.ListenAndServe(&amp;quot;:&amp;quot;+os.Getenv(&amp;quot;PORT&amp;quot;), r) }  在现有项目上第一次使用dep时，需要运行dep init。
dep init将在GOPATH中已经包含github.com/gorilla/mux，manifest.json文件将包括它。我先运行如下命令：
go get -u github.com/gorilla/mux  所以在我的\$GOPATH中github.com/gorilla/mux的分支是master。如果我的\$GOPATH中的版本匹配Semver tag（例如：v1.2.3），那么将使用该tag的名称。
dep可以跨越架构和go版本。我们可以将github.com/gorilla/mux与旧版本的Go（&amp;lt;1.7.0）的github.com/gorilla/context包结合使用。当我最后运行
go get -u github.com/gorilla/mux  的时候，我运行的是Go 1.7.5，所以github.com/gorilla/context包不在我的\$GOPATH。因为可能是编译项目所需的依赖，它会包含在lock.json文件中。在这种场景下，如果从属项目有一个semver兼容的release tag，dep会选择最新的版本。在这种情况下是github.com/gorilla/context的v1.1。
因为github.com/gorilla/mux不包含manifest.json文件，dep不知道github.com/gorilla/mux目前是否能与github.com/gorilla/context@v1.1配合使用。dep一般使用在依赖的manifest.json文件中找到的约束。
dep init包括所有依赖关系（包括递归依赖）以及在lock.json文件中使用的确切版本。
对于示例应用程序，这将创建以下两个文件：
lock.json
{ &amp;quot;memo&amp;quot;: &amp;quot;d741a3bed21fe6cae9d67c523b0a343859882b2f246f2a293e2676cfacd5a2ce&amp;quot;, &amp;quot;projects&amp;quot;: [ { &amp;quot;name&amp;quot;: &amp;quot;github.</description>
    </item>
    
    <item>
      <title>优秀的 Go存储开源项目和库</title>
      <link>https://yushuangqi.com/blog/2017/you-xiu-de-go-cun-chu-kai-yuan-xiang-mu-he-ku.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:40 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/you-xiu-de-go-cun-chu-kai-yuan-xiang-mu-he-ku.html</guid>
      <description>今年谷歌家的 Go 编程语言流行度有着惊人的上升趋势，其发展也是越来越好，因此本文整理了一些优秀的 Go 存储相关开源项目和库，一起分享，一起学习。
存储服务器（Storage Server） Go 实现的存储服务器  minio - Minio 是一个与 Amazon S3 APIs 兼容的开源对象存储服务器，分布式存储方案 rclone - “用于云存储的 Rsync” - Google Drive, Amazon Drive, S3, Dropbox, Backblaze B2, One Drive, Swift, Hubic, Cloudfile… camlistore - Camlistore 是你的个人存储系统：一种存储、同步、共享、建模和备份内容的方式 torus - CoreOS 的现代分布式存储系统 s3git - 云存储的 Git。用于数据的分布式版本控制系统 rook - 开放、云本地和通用的分布式存储  Key-Value 存储（Key-Value Store） Go 实现的 Key-Value 存储  etcd - 可靠的分布式 key-value 存储，用于分布式系统的最关键数据 go-cache - Go 语言实现的一个内存中的缓存框架，实现 Key-Value 的序列存储，适用于单台机器应用程序 biscuit - Biscuit 用于 AWS 基础架构建设时多区域 HA key-value 存储 diskv - 支持磁盘的 key-value 存储  文件系统（File System） Go 实现的文件系统  git-lfs - 用于大文件版本控制的 Git 扩展 seaweedfs - SeaweedFS 是一个用于小文件的简单且高度可扩展的分布式文件系统 fsnotify - Go 实现的跨平台文件系统监控库 goofys - Go 实现的高性能，POSIX-ish Amazon S3 文件系统 go-systemd - systemd 的 Go 语言绑定版（包括socket activation, journal, D-Bus, 和 unit files） gcsfuse - 用于与 Google 云存储交互的用户空间文件系统 svfs - 基于 Openstack 的虚拟文件系统  数据库（Database） Go 实现的数据库  BigCache - 用于千兆字节数据的高效 key/value 缓存 bolt - Go 实现的低层级的 key/value 数据库 buntdb - 一个 Go 实现的快速、可嵌入的 key/value 内存数据库，具有自定义索引和 geospatial 支持的功能 cache2go - key/value 内存缓存，支持基于超时的自动无效功能 cockroach - 一个可伸缩的、支持地理位置处理、支持事务处理的数据存储系统 couchcache - 由 Couchbase 服务器支持的 RESTful 缓存微服务 dgraph - 具有可扩展、分布式、低延迟和高吞吐量功能的图形数据库 eliasdb - 使用 REST API，短语搜索和类似 SQL 查询语言的无依赖性，支持事务处理的图形数据库 forestdb - Go bindings for ForestDB.</description>
    </item>
    
    <item>
      <title>Macgolang下载mgo</title>
      <link>https://yushuangqi.com/blog/2017/mac-golangxia-zai-mgo.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/mac-golangxia-zai-mgo.html</guid>
      <description>mgo是第三方提供的golang连接mongodb的库，使用如下命令，进行下载
go get labix.org/v2/mgo  会出错，说没有安装bzr，bzr是mgo使用的版本控制软件，全名 bazaar，可以在http://wiki.bazaar.canonical.com/Download下载各操作系统的版本。bzr安装好后，执行上述下载命令，可能还是会出错，错误如下
bzr: ERROR: Couldn&#39;t import bzrlib and dependencies. Please check the directory containing bzrlib is on your PYTHONPATH. Traceback (most recent call last): File &amp;quot;/usr/local/bin/bzr&amp;quot;, line 102, in &amp;lt;module&amp;gt; import bzrlib ImportError: No module named bzrlib  上网查了一下是因为bzr使用的是python2.6版本，使用python -V查看本机安装的2.7的版本，需要降版本。
进入/usr/local/bin/目录，使用vi或vim修改bzr文件，修改第一行：#!/usr/bin/python 为 #!/usr/bin/python2.6，保存退出。在使用前面的下载命令，成功下载mgo。由于网速问题，可能要多下几次。</description>
    </item>
    
    <item>
      <title>浅析GO语言中如何优雅地中断定时任务</title>
      <link>https://yushuangqi.com/blog/2017/jian-xi-goyu-yan-zhong-ru-he-you-ya-de-zhong-duan-ding-shi-ren-wu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:38 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jian-xi-goyu-yan-zhong-ru-he-you-ya-de-zhong-duan-ding-shi-ren-wu.html</guid>
      <description>问题描述 现在我们创建了一个定时器，能定时的去做某件事，并且在执行时间超时的时候，能把这个定时器关掉。例如需要收集一周的日志，创建一个定时任务去收集日志，每5秒钟执行一次，一周的时间过后需要停掉这个定时任务。
标准库Ticker 标准库提供里的Ticker类，主要功能是定时重复的去做某件事情，如果没有设定超时，它会一直执行下去。常见的写法如下：
t := time.NewTicker(3 * time.Second) timeout := time.After(10 * time.Second) go func() { for { &amp;lt;-t.C ... } }() &amp;lt;-timeout ...  注意到这个Ticker对象是无法关闭的，好的，你可能会发现Ticker类提供了Stop方法。但是我们看看如果你这样去关闭t的话，会出现什么情况。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func DoTickerWork(res chan interface{}, timeout &amp;lt;-chan time.Time) { t := time.NewTicker(3 * time.Second) go func() { defer close(res) i := 1 for { &amp;lt;-t.C fmt.Printf(&amp;quot;start %d th worker\n&amp;quot;, i) res &amp;lt;- i i++ } }() &amp;lt;-timeout t.</description>
    </item>
    
    <item>
      <title>CMDB发布平台:go发布管理</title>
      <link>https://yushuangqi.com/blog/2017/cmdbfa-bu-ping-tai-gofa-bu-guan-li.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:37 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/cmdbfa-bu-ping-tai-gofa-bu-guan-li.html</guid>
      <description>CMDB发布平台是ezbuy的一个发布管理平台，包含了go的发布，windows serices发布，iis发布，memcache管理，svn管理，资产信息管理操作。
随着公司的业务发展，公司go的服务有100多个单实例，如果多机部署计算，是成倍数增长的，而且每天更新发布的频率高，所以如果人为的去发布，会出现以下问题：
 开发人员每次update服务，都需要找运维人员发布 每次发布，没有版本信息记载，只有相应的版本号，即没有历史数据 重复工作量大，无技术可言，且容易人为发布错误 没有消息通知 开发人员各自在自己电脑上编译，然后提交到svn（环境不统一）  go现在的发布是每次jenkis自动编译通过后，自动上传到svn上，避免编译成mac os版本的go上传到svn，然后通过CMDB平台发布，发布涉及手动和自动发布两个操作：
 手动：开发人员手动通过CMDB平台发布 自动：编译好后，jenkis直接调用CMDB API自动发布到线上（持续CD）  综上问题，CMDB开发了go发布管理模块，模块里包含以下功能：
 部署 发布 更新go配置文件 重启go服务 版本回滚 go服务状态 go crontab发布更新 go cron job定时任务列表  [部署]： 线上运维人员可以通过运维平台直接部署一个新的go服务
go部署
[发布]： 开发人员有权限直接发布服务到线上，无需运维人员干预，且每次发布要填入相应的tower发布url，否则不给予发布
go发布

不管服务成功与否，CMDB会调用钉钉api，将发布结果发送到钉钉消息群，同时CMDB也会保存一份日志到数据库。
go发布消息
[更新go配置文件]： go配置文件我们会单独的将所有go实例的配置文件保存在一个svn库，这样的好处是，有版本控制，避免开发人员人为改动，且敏感信息只有相应权限的人才能查看，所以每次配置文件改表，直接相应有权限的人提交到svn，通过更新go配置文件下发的所有主机：
go下发配置文件
[版本回滚]： 线上运维同学可以通过CMDB平台回滚到相应的版本
[服务状态]： 开发人员可以实时查看go服务运行的状态
[go crontab更新]： 开发人员可以直接发布go的服务
[cron job列表]： 可以在CMDB平台查看所有的cron job和cron job上次执行的时间
最后，我们将会把go的配置文件统一线上线下环境一样，且不暴露敏感信息，敬请关注下一篇《如何利用consul-template保持线上线下配置文件一致》</description>
    </item>
    
    <item>
      <title>深入了解Go接口</title>
      <link>https://yushuangqi.com/blog/2017/shen-ru-le-jie-gojie-kou.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:37 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shen-ru-le-jie-gojie-kou.html</guid>
      <description>http://studygolang.com/articles/
深入了解Go接口
如果说goroutine和channel是Go并发的两大基石，那么接口是Go语言编程中数据类型的关键。在Go语言的实际编程中，几乎所有的数据结构都围绕接口展开，接口是Go语言中所有数据结构的核心。
Go语言中的接口是一些方法的集合（method set），它指定了对象的行为：如果它（任何数据类型）可以做这些事情，那么它就可以在这里使用。
type Reader interface { Read(p []byte) (n int, err error) } type Writer interface { Write(p []byte) (n int, err error) } type Closer interface { Close() error } type Seeker interface { Seek(offset int64, whence int) (int64, error) }  上面的代码定义了4个接口。
假设我们在另一个地方中定义了下面这个结构体：
type File struct { // ... } func (f *File) Read(buf []byte) (n int, err error) func (f *File) Write(buf []byte) (n int, err error) func (f *File) Seek(off int64, whence int) (pos int64, err error) func (f *File) Close() error  我们在实现File的时候，可能并不知道上面4个接口的存在，但不管怎样，File实现了上面所有的4个接口。我们可以将File对象赋值给上面任何一个接口。</description>
    </item>
    
    <item>
      <title>Go1_8graceful优雅的重启HTTP服务</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</link>
      <pubDate>Sat, 18 Feb 2017 10:33:41 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</guid>
      <description>很高兴Go 1.8发布了，这是个值得庆祝的日子。
如何优雅的关闭http服务在Go Web开发中一直被提及和讨论的话题，今天Go 1.8的发布终于为我们带来了这个特性。
文档中是这样介绍的：
func (srv *Server) Shutdown(ctx context.Context) error  Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：
 首先关闭所有的监听
 然后关闭所有的空闲连接
 然后无限期等待连接处理完毕转为空闲，并关闭
 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误
  需要注意的是，Shutdown 并不尝试关闭或者等待 hijacked连接，如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。
其实，你只要调用 Shutdown 方法就好了。
简单示例：
// main.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;os/signal&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World, %v\n&amp;quot;, time.Now()) }) s := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: http.</description>
    </item>
    
    <item>
      <title>TiDB架构的演进和开发哲学</title>
      <link>https://yushuangqi.com/blog/2017/tidb-jia-gou-de-yan-jin-he-kai-fa-zhe-xue.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/tidb-jia-gou-de-yan-jin-he-kai-fa-zhe-xue.html</guid>
      <description>https://segmentfault.com/a/
 本文来自 CSDN《程序员》2017 年 2 月的封面报道。
对于一个从零开始的数据库来说：选择什么语言，整体架构怎么做，要不要开源，如何去测试…太多的问题需要去考量。
 在本篇文章中，PingCAP 联合创始人兼 CTO 黄东旭对 TiDB 的开发历程进行了详细简介，为大家还原 TiDB 的架构演进全过程。
在大约两年前，我有一次做 MySQL 分库分表和中间件的经历，那时在中间件里做 sharding，把 16 个节点的 MySQL 扩到 32 节点，差不多要提前一个月做演练，再用一个礼拜来上线。我就在想，能不能有一个数据库可以让我们不再想分库分表这些东西？当时我们也刚刚做完 Codis，觉得分布式是个比较合适的解决方案。另外我一直在关注学术圈关于分布式数据库的最新进展，有看到谷歌在 2013 年发的 Spanner 和 F1 的论文，所以决定干脆就重新开始写一个数据库，从根本上解决 MySQL 扩展性的问题。
而决定之后发现面对的问题非常复杂：选择什么语言，整个架构怎么做，到底要不要开源……做基础软件有一个很重要的事情：写出来并不难，难的是你怎么保证这个东西写对了。尤其是对于业务方，他们所有的业务正确性是构建在基础软件的正确性上。所以，对于分布式系统来说，什么是写对了，怎么去测试，这都是很重要的问题。关于这些我想了很久。
一开始总是要起步的。当时就决定冷静一下，先确定一个目标：解决 MySQL 的问题。MySQL 是单机型数据库，它没有办法做全扩展，我们选择 MySQL 兼容，首先选择在协议和语法层面的兼容，因为已有的社区里边很多的海量的测试。第二点是用户的迁移成本，能让用户迁移得很顺畅。第三是因为万事开头难，必须得有一个明确的目标，选定一个目标去做，对开发人员来说心理的压力最小。确定目标以后，我们 3 个人的创始团队从原来的公司出来，拿了一笔比较大的风险投资，开始正式做这件事情。
兼容 MySQL 最简单的方案，就是直接用 MySQL。为了让这个东西尽快地做起来，我们一开始做了一个最简单的版本，复用 MySQL前端 代码，做一个分布式的存储引擎就可以了，这个事情想想还是蛮简单的，所以非常乐观，觉得这个战略很完美。
上图是我在 2015 年 4 月份用六个礼拜完成的第一个版本的框架，但是后来没好意思开源出来，虽然能跑，但是在性能上完全无法接受。我就想这个东西为什么这么慢？一步一步去看每一层，就想动手改，但是发现工程量巨大，比如 MySQL 的 SQL 优化器， 事务模型等等，完全没有办法下手。就像这个架构图里看到的，因为在 MySQL Engine 这一层，我们能做的事情太少了，所以就没有办法。
第一版实验到此宣告失败，现在看起来写 SQL parser 和优化器等这些已经是绕不开了，我们索性决定从头开始写，唯一给我安慰的就是终于可以使用我们最爱的编程语言了，就是 Go。
我们跟其他做这种软件的工程师的思路相反，选择了从上往下写，先写最顶层的 SQL 的接口 SQL Layer，我要保证这个东西长得跟 MySQL 一模一样，包括网络协议和语法层。从 TiDB 网络协议、SQL 的语法解析器、到 SQL 的优化器、执行器等基本从上到下写了一遍。这个阶段持续了大概三个月左右。从这个阶段开始，我们慢慢摸索出了几个实践中深有体会的开发哲学。</description>
    </item>
    
  </channel>
</rss>