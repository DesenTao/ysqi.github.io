<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/tags/java.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/java.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>谷歌:谁拥有下一代云平台的DNA？机器学习和云端智能是云的未来</title>
      <link>https://yushuangqi.com/blog/2016/gu-ge-shei-yong-you-xia-yi-dai-yun-ping-tai-de-dnaji-qi-xue-xi-he-yun-duan-zhi-neng-shi-yun-de-wei.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:53 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gu-ge-shei-yong-you-xia-yi-dai-yun-ping-tai-de-dnaji-qi-xue-xi-he-yun-duan-zhi-neng-shi-yun-de-wei.html</guid>
      <description>在“NEXT2016”会议上，Google的Eric Schmidt提到Google所占最大的优势之一就是站在云计算下一个十年的前沿。它不是基础设施或者软件，也不像纯数据一样简单。
Crowdsourced 智能，是个进化，可以创建更加智能的从上到下各级用户都可以利用、重新训练、改变、为自己目的输出的系统。这一切将会点燃新一代云平台的未来发展方向。
Crowdsourcing数据的这个概念会令训练变得更好、变得更加智能、范围更加宽广，这也是谷歌在接下来云计算的十年里有竞争力的核心优势，Schmidt说道。“我坚信快速评估模型，谷歌云计算，机器学习，以及crowdsourcing将会是每一个IPO的基础，在下一个5年里成为赢家。”这会是一个跟产生应用程序的过程很相似的评估——将用户眼下真正需要的智能创建然后放进去，在这背后还有着底层基础设施，很多这样的抽象层次才会让用户有无缝体验。Schmidt比较说，这跟汽车产业十分相像——从早期的时候，到离合器，再到未来的自驾。
“Google云平台跟未来要发生的简直同步到完美。这个平台还不是终结，而是底层——总有些&amp;rdquo;什么&amp;rdquo;在这上面。这个“什么”就是机器学习，包括狭义的AI和广义的AI，就是下一代的转化。编程范型改就这样改变了。除了让电脑编程，还可以让电脑做你想让它做的事情。这是编程的一个基本变化。”
Schmidt说，为这次转变作的最好的准备就是在Linux的上面、Google云平台上面和Kubernetes上面开始创建。从开发角度来说，是为了可扩展的、便携的像Go，Python，node.js，java这样的语言结合工作，以及创建在Google App Engine上面。但是在这个清单再往上，就是应用TensorFlow的问题了，这将是未来5年内谷歌机器学习和分析策略的核心（他估计，许多其它企业也一样）。
关于TensorFlow 请点击这里
随着谷歌新机器学习平台的首次展示，等于在这片沙地上首次插入了这面旗帜，后续会有比如AWS，Microsoft的Azure等等有着高级机器学习和云基础设施的公司比如IBM纷至沓来。因为不像其它那些公司，Google拥有自身已有的而很多其它公司所没有的诸如照片，声音和文本的服务为资源来做crowdsource服务，来促进下图列出来的这些服务。
Jeff Dean，谷歌System Infrastructure组，也是Google Brain项目主导人说道：“在过去的几年里，我们已经将机器学习创建塞入我们做的每件事情中。” 这就是为什么公司安卓语音识别系统运行得如此好，也是为什么他们的翻译服务如此深远，相对准确，也是为什么照片脸和对象识别与分类可以做到无缝。crowdsourced服务，就是Google提供最丰富的档案和流媒体数据来做更加智能的机器，并且更加高级的深层学习能力。针对其他之前由硬件统治见长的云，Google将会采取更加温和的方法（通过软件）来抗衡。
安装了TensorFlow来允许复杂的深层学习作为全面管理服务，云计算未来的十年会是非常不同的，更不用说下一代将是数据分析的天下。我们已经从需要用同样的旧工具（一些新的框架比如MapReduce和Hadoop）来处理很多数据得出方法的时代解放出来，通过让数据自己计算来实现“量子跳跃”，至少理论上是这样的。而且那会是一件大事——一件可以威胁到目前云霸权地位的大事，谷歌可能会全栈关注以及拥有crowdsource－able服务。
即使TensorFLow只是在2015年底刚出现，Schmidt坚信这是下一代谷歌用复杂的分析工作负载为大型企业提供更加深层大范围的服务的能力。这是下一个应用程序和云应用范例浪潮的开始——而且很可能，对于谷歌自己作为推动的地位以及在500强公司的推动下，500强公司和AWS也会迈出他们的第一步。
不久之前，就像我们在AWS的第一个十年快到之前评论的那样，即使是在弹性非常大的应用程序里，重点也仍然在基础设施的进化上，而且与之相关的工具和服务都是互相挂钩的。云的头十年是强烈植根于这些基础之上在考量的：考量安全，网络，当然还有所需的大型主机来推动呈爆发增长的用户应用程序。毋庸置疑，AWS走在云平台前沿，这是众所周知的，随着附加的元素通过其它一样缺乏初始动机的公司也开始出租备用基础设备（相比较于仅仅只是为主持基于云端服务来创建数据中心来说）。
AWS之前所有的努力都值得被认可，然而现在AWS和他的云计算领域同伴面临的，是安装了crowdsourced数据、机器学习和深层次学习框架并用它来做一些高层次的业务，支持新的已经存在的服务；在这些服务上，谷歌的定位是让用户获得超值的服务。这一年会是谷歌云在某种程度上找到它的立足点，之前它并没有跟大规模企业合作过，这些企业之前通过Amazon的服务对公有云（通常通过混合模型）有了初步的尝试，需要一些过程来信服来摆脱最初经历的那些恐惧、成本、冒险，从而从纯粹云的基础设施来经历再一次的转变。
可以让大家刮目相看的云平台一定不再是硬件设施了。这其实是差不多的一个过程，可以预料到，谷歌会采取进一步努力来支持谷歌可提供的云端服务“实例”，就像AWS之前的过程一样，AWS在存储、加速、CPU和网络选项多方面都提供服务来抢占市场。核心竞争力一定是来自于一个对大多数公司来说很难做到的事情——下一代智能分析能力，可以做到如此智能、协调，这会是扰动原有云生态布局，在未来主导游戏规则改变的事情，至少在谷歌眼里是这样。
原文链接
（如果需要转载，请联系我们哦，尊重知识产权人人有责）</description>
    </item>
    
    <item>
      <title>GC垃圾回收机制:浅析与理解</title>
      <link>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:29 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gcla-ji-hui-shou-ji-zhi--jian-xi-yu-li-jie.html</guid>
      <description>GC垃圾回收机制： 浅析与理解 对垃圾回收进行分析前，我们先来了解一些基本概念
基本概念  内存管理：内存管理对于编程语言至关重要。汇编允许你操作所有东西，或者说要求你必须全权处理所有细节更合适。C 语言中虽然标准库函数提供一些内存管理支持，但是对于之前调用 malloc 申请的内存，还是依赖于你亲自 free 掉。从C++、Python、Swift 和 Java 开始，才在不同程度上支持内存管理。
 内存压缩：对内存碎片进行压缩。（和win10的那个“内存压缩”不太一样啦）
 win10内存压缩：物理内存已经见底，将一部分不常使用的内存数据打包压缩起来，等到有程序需要访问那些数据的时候，再解压缩出来。
 引用与指针：
 引用被创建的同时必须被初始化（指针则可以在任何时候被初始化）。
 不能有NULL 引用，引用必须与合法的存储单元关联（指针则可以是NULL）。
 一旦引用被初始化，就不能改变引用的关系（指针则可以随时改变所指的对象）。
 引用只是某块内存的别名。
 实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用” 这东西？
答案是“用适当的工具做恰如其分的工作”。比如说，某人需要一份证明，本来在文件上盖 上公章的印子就行了，如果把取公章的钥匙交给他，那么他就获得了不该有的权利。（什么情况下，就用什么对策）
 为什么还要说“只有指针，没有引用是一个重要改变？”？
答案是虽然引用在某些情况下好用，但他也会导致致命错误。如下：
char *pc = 0; // 设置指针为空值 char&amp;amp; rc = *pc; // 让引用指向空值   这是非常有害的，毫无疑问。结果将是不确定的（编译器能产生一些输出，导致任何事情都有可能发生），应该躲开写出这样代码的人除非他们同意改正错误。如果你担心这样的代码会出现在你的软件里，那么你最好完全避免使用引用，要不然就去让更优秀的程序员去做。
 最后上附图，帮助理解
  堆（heap）和栈（stack）
 平常说的“堆栈”其实是栈。
 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。
 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控 制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。
  程序的栈结构
 程序的地址空间布局： 程序运行靠四个东西：代码、栈、堆、数据段。代码段主要存放的就是可执行文件(通常可执行文件内，含有以二进制编码的微处理器指令，也因此可执行文件有时称为二进制文件)中的代码；数据段存放的就是程序中全局变量和静态变量；堆中是程序的动态内存区域，当程序使用malloc或new得到的内存是来自堆的；栈中维护的是函数调用的上下文，离开了栈就不可能实现函数的调用。</description>
    </item>
    
  </channel>
</rss>