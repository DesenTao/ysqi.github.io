<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cockroachdb on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/cockroachdb.html</link>
    <description>在 虞双齐的博客上关于in Cockroachdb 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:34:05 +0800</lastBuildDate>
    <atom:link href="/tags/cockroachdb.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>[译]CockroachDBGC优化总结</title>
      <link>https://yushuangqi.com/blog/2016/yi--cockroachdb-gcyou-hua-zong-jie.html.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:05 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/yi--cockroachdb-gcyou-hua-zong-jie.html.html</guid>
      <description>几周前我们分享了一个帖子讲述我们为什么选择Go语言编写CockroachDB，我们收到一些问题，询问我们是如何解决Go语言的一些已知问题，特别是关于性能、GC和死锁的问题。
本文中我们将分享几个非常有用的优化技巧用以改善许多常见的GC性能问题（接下来还将覆盖一些有趣的死锁问题）。我们将重点分享如何通过嵌套结构体、使用 sync.Pool、和复用后端数组减少内存分配和降低GC开销。
减少内存分配和GC优化 将Go与其他语言（比如java）区别开来的是Go语言能让你管理内存布局。通过GO语言，你可以合并碎片，而其他垃圾集合语言不能。
让我们看看CockroachDB中从磁盘读取数据并解码的一小段代码：
metaKey := mvccEncodeMetaKey(key) var meta MVCCMetadata if err := db.GetProto(metaKey, &amp;amp;meta); err != nil { // Handle err } ... valueKey := makeEncodeValueKey(meta) var value MVCCValue if err := db.GetProto(valueKey, &amp;amp;value); err != nil { // Handle err }  为了读取数据，我们执行了4次内存分配：MVCCMetadata结构体、MVCCValue结构体和metaKey、valueKey。在Go语言中我们可以通过合并结构体和预分配空间给Key把内存分配减少为1次。
type getBuffer struct { meta MVCCMetadata value MVCCValue key [1024]byte } var buf getBuffer metaKey := mvccEncodeKey(buf.key[:0], key) if err := db.GetProto(metaKey, &amp;amp;buf.</description>
    </item>
    
  </channel>
</rss>