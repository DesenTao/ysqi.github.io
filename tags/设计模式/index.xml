<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on 虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</link>
    <description>在 虞双齐的博客上关于in 设计模式 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Sat, 31 Dec 2016 11:34:38 +0800</lastBuildDate>
    <atom:link href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" rel="self" type="application/rss+xml" />
    
    <item>
      <title>【转载】Go语言设计模式实践:迭代器(Iterator)</title>
      <link>https://yushuangqi.com/blog/2016/zhuai-zai-goyu-yan-she-ji-mo-shi-shi-jian-die-dai-qi-iterator.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:38 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/zhuai-zai-goyu-yan-she-ji-mo-shi-shi-jian-die-dai-qi-iterator.html</guid>
      <description>原文：http://www.cnblogs.com/newgame/p/4061083.html
关于本系列 决定开个新坑。
这个系列首先是关于Go语言实践的。在项目中实际使用Go语言也有段时间了，一个体会就是不论是官方文档、图书还是网络资料，关于Go语言惯用法（idiom）的介绍都比较少，基本只能靠看标准库源代码自己琢磨，所以我特别想在这方面有一些收集和总结。
然后这个系列也是关于设计模式的。虽然Go语言不是一门面向对象编程语言，但是很多面向对象设计模式所要解决的问题是在程序设计中客观存在的。不管用什么语言，总是要面对和解决这些问题的，只是解决的思路和途径会有所不同。所以我想就以经典的设计模式作为切入点来展开这个系列，毕竟大家对设计模式都很熟悉了，可以避免无中生有想出一些蹩脚的应用场景。
本系列的具体主题会比较灵活，计划主要包括这些方面的话题：
Go语言惯用法。
设计模式的实现。特别是引入了闭包，协程，DuckType等语言特性后带来的变化。
设计模式思想的探讨。会有一些吐槽。
不使用迭代器的方案 首先要指出的是，绝大多数情况下Go程序是不需要用迭代器的。因为内置的slice和map两种容器都可以通过range进行遍历，并且这两种容器在性能方面做了足够的优化。只要没有特殊的需求，通常是直接用这两种容器解决问题。即使不得不写了一个自定义容器，我们几乎总是可以实现一个函数，把所有元素（的引用）拷贝到一个slice之后返回，这样调用者又可以直接用range进行遍历了。
当然某些特殊场合迭代器还是有用武之地。比如迭代器的Next()是个耗时操作，不能一口气拷贝所有元素；再比如某些条件下需要中断遍历。
经典实现 经典实现完全采用面向对象的思路。为了简化问题，下面的例子中容器就是简单的[]int，我们在main函数中使用迭代器进行遍历操作并打印取到的值，迭代器的接口设计参考java。
package main import &amp;#34;fmt&amp;#34; type Ints []int func (i Ints) Iterator() *Iterator { return &amp;amp;Iterator{ data: i, index: 0, } } type Iterator struct { data Ints index int } func (i *Iterator) HasNext() bool { return i.index &amp;lt; len(i.data) } func (i *Iterator) Next() (v int) { v = i.data[i.index] i.index++ return v } func main() { ints := Ints{1, 2, 3} for it := ints.</description>
    </item>
    
  </channel>
</rss>