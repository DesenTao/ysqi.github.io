<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Go语言技术独立咨询顾问</title>
    <link>https://yushuangqi.com/tags/%E5%B9%B6%E5%8F%91.xml</link>
    <description>在 虞双齐Go语言技术独立咨询顾问上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/%E5%B9%B6%E5%8F%91.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go并发模式:管道和取消</title>
      <link>https://yushuangqi.com/blog/2016/gobing-fa-mo-shi-guan-dao-he-qu-xiao.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:02 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gobing-fa-mo-shi-guan-dao-he-qu-xiao.html</guid>
      <description>原地址：[](http://air.googol.im/2014/03/15/go-concurrency-patterns-pipelines-and-cancellation.html)http://air.googol.im/2014/03/15/go-concurrency-patterns-pipelines-and-cancellation.html
译自[](http://blog.golang.org/pipelines)http://blog.golang.org/pipelines。
这是Go官方blog的一篇文章，介绍了如何使用Go来编写并发程序，并按照程序的演化顺序，介绍了不同模式遇到的问题以及解决的问题。主要解释了用管道模式链接不同的线程，以及如何在某个线程取消工作时，保证所有线程以及管道资源的正常回收。
Go并发模式：管道和取消
作者：Sameer Ajmani，blog.golang.org，写于2014年3月13日。
介绍 Go本身提供的并发特性，可以轻松构建用于处理流数据的管道，从而高效利用I/O和多核CPU。这篇文章就展示了这种管道的例子，并关注当操作失败时要处理的一些细节，并介绍了如何干净的处理错误的技巧。
什么是管道？ Go语言里没有明确定义管道，而只是把管道当作一类并发程序。简单来说，管道是一系列由channel联通的状态（stage），而每个状态是一组运行相同函数的Goroutine。每个状态上，Goroutine
 通过流入（inbound）channel接收上游的数值 运行一些函数来处理接收的数据，一般会产生新的数值 通过流出（outbound）channel将数值发给下游  每个语态都会有任意个流入或者流出channel，除了第一个状态（只有流出channel）和最后一个状态（只有流入channel）。第一个状态有时被称作源或者生产者；最后一个状态有时被称作槽（sink）或者消费者。
我们先从一个简单的管道例子开始解释这些想法和技术。之后，我们再来看一些更真实的例子。
求平方数 考虑一个管道和三个状态。
第一个状态，gen，是一个将一系列整数一一传入channel的函数。gen函数启动一个Goroutine，将整数数列发送给channel，如果所有数都发送完成，关闭这个channel：
func gen(nums ...int) &amp;lt;-chan int { out := make(chan int) go func() { for _, n := range nums { out &amp;lt;- n } close(out) }() return out }  第二个状态，sq，从一个channel接收整数，并求整数的平方，发送给另一个channel。当流入channel被关闭，而且状态已经把所有数值都发送给了下游，关闭流出channel：
func sq(in &amp;lt;-chan int) &amp;lt;-chan int { out := make(chan int) go func() { for n := range in { out &amp;lt;- n * n } close(out) }() return out }  主函数建立起管道，并执行最终的状态：从第二个状态接收所有的数值并打印，直到channel被关闭：</description>
    </item>
    
    <item>
      <title>Fanout-更容易得写并发代码</title>
      <link>https://yushuangqi.com/blog/2016/fanout---geng-rong-yi-de-xie-bing-fa-dai-ma.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:37 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/fanout---geng-rong-yi-de-xie-bing-fa-dai-ma.html</guid>
      <description>不用管理 grouting 和 channel 了。 以下为转发 golangtc.com 原文：
刚刚写了个包，觉得值得出来分享下：
文档: https://github.com/sunfmin/fanout
用来简化并发程序(goroutine, channel)的编写，这个包直接改写自Go Concurrency Patterns: Pipelines博客的最后一个样例程序。
平时写带goroutine和channel的程序，总是时不时的爆&amp;rdquo;fatal error: all goroutines are asleep - deadlock!&amp;ldquo;，检查起来又很难找原因。
例子程序 - 用60个goroutine一起跑whois来查看域名是不是还在:
inputs := []interface{}{} for _, word:= range domainWords { inputs = append(inputs, word) } results, err2 := fanout.ParallelRun(60, func(input interface{}) (interface{}, error) { word := input.(string) if strings.TrimSpace(word) == &amp;quot;&amp;quot; { return nil, nil } py := pinyin.Convert(word) pydowncase := strings.ToLower(py) domain := pydowncase + &amp;quot;.</description>
    </item>
    
    <item>
      <title>PHP编程中的并发</title>
      <link>https://yushuangqi.com/blog/2016/phpbian-cheng-zhong-de-bing-fa.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:04 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/phpbian-cheng-zhong-de-bing-fa.html</guid>
      <description>PHP编程中的并发  周末去北京面了两个公司，认识了几位技术牛人，面试中聊了很多，感觉收获颇丰。认识到了自己的不足之处，也坚定了自己对计算机学习的信心。本文是对其中一道面试题的总结。
 面试中有一个问题没有很好的回答出来，题目为：并发3个http请求，只要其中一个请求有结果，就返回，并中断其他两个。
当时考虑的内容有些偏离题目原意， 一直在考虑如何中断http请求，大概是在 client-&amp;gt;recv() 之前去判断结果是否已经产生，所以回答的是用 socket 去发送一个 http 请求，把 socket 加入 libevent 循环监听，在callback中判断是否已经得到结果，如果已经得到结果，就直接 return。
后来自己越说越觉得不对，既然已经recv到结果，就不能算是中断http请求。何况自己从来没用过libevent。后来说了还说了两种实现，一个是用 curl_multi_init, 另一个是用golang实现并发。
golang的版本当时忘了close的用法，结果并不太符合题意。
这题没答上来，考官也没为难我。但是心里一直在考虑，直到面试完走到楼下有点明白什么意思了，可能考的是并发，进程线程的应用。所以总结了这篇文章，来讲讲PHP中的并发。
本文大约总结了PHP编程中的五种并发方式，最后的Golang的实现纯属无聊，可以无视。如果有空，会再补充一个libevent的版本。
curl_multi_init 文档中说的是 Allows the processing of multiple cURL handles asynchronously. 确实是异步。这里需要理解的是select这个方法，文档中是这么解释的Blocks until there is activity on any of the curl_multi connections.。了解一下常见的异步模型就应该能理解，select, epoll，都很有名，这里引用一篇非常好的文章，有兴趣看下解释吧。
&amp;lt;?php // build the individual requests as above, but do not execute them $ch_1 = curl_init(&#39;http://www.baidu.com/&#39;); $ch_2 = curl_init(&#39;http://www.baidu.com/&#39;); curl_setopt($ch_1, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch_2, CURLOPT_RETURNTRANSFER, true); // build the multi-curl handle, adding both $ch $mh = curl_multi_init(); curl_multi_add_handle($mh, $ch_1); curl_multi_add_handle($mh, $ch_2); // execute all queries simultaneously, and continue when all are complete $running = null; do { curl_multi_exec($mh, $running); $ch = curl_multi_select($mh); if($ch !</description>
    </item>
    
    <item>
      <title>在Golang中使用Go关键字和Channel实现并行</title>
      <link>https://yushuangqi.com/blog/2016/zai--golang-zhong-shi-yong--go-guan-jian-zi-he--channel-shi-xian-bing-hang.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/zai--golang-zhong-shi-yong--go-guan-jian-zi-he--channel-shi-xian-bing-hang.html</guid>
      <description>Go 关键字和 channel 的用法 go 关键字用来创建 goroutine (协程)，是实现并发的关键。go 关键字的用法如下： //go 关键字放在方法调用前新建一个 goroutine 并让他执行方法体 go GetThingDone(param1, param2); //上例的变种，新建一个匿名方法并执行 go func(param1, param2) { }(val1, val2) //直接新建一个 goroutine 并在 goroutine 中执行代码块 go { //do someting... }  因为 goroutine 在多核 cpu 环境下是并行的。如果代码块在多个 goroutine 中执行，我们就实现了代码并行。那么问题来了，怎么拿到并行的结果呢？这就得用 channel 了。 //resultChan 是一个 int 类型的 channel。类似一个信封，里面放的是 int 类型的值。 var resultChan chan int //将 123 放到这个信封里面，供别人从信封中取用 resultChan &amp;lt;- 123 //从 resultChan 中取值。这个时候 result := 123 result := &amp;lt;- resultChan  使用 go 关键字和 channel 实现非阻塞调用 阻塞的意思是调用方在被调用的代码返回之前必须一直等待，不能处理别的事情。而非阻塞调用则不用等待，调用之后立刻返回。那么返回值如何获取呢？Node.</description>
    </item>
    
    <item>
      <title>Golang并发模式:超时和继续GoConcurrencyPatterns:Timingoutmovingon</title>
      <link>https://yushuangqi.com/blog/2016/golang-bing-fa-mo-shi-chao-shi-he-ji-xu--go-concurrency-patterns-timing-out-moving-on.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:29 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/golang-bing-fa-mo-shi-chao-shi-he-ji-xu--go-concurrency-patterns-timing-out-moving-on.html</guid>
      <description>翻译自 Go Blog。
原文地址：https://blog.golang.org/go-concurrency-patterns-timing-out-and
并发编程有自己的一些习惯用语，超时就是其中之一。虽然 Golang 的管道并没有直接支持超时，但是实现起来并不难。假设遇到了这样一种场景：在从 管道 ch 中取值之前至少等待 1 秒钟。我们可以创建一个管道用来传递信号，开启一个协程休眠一秒钟，然后给管道传递一个值。
timeout := make(chan bool, 1) go func() { time.Sleep(1 * time.Second) timeout &amp;lt;- true }()  然后就可以使用一个 select 语句来从 timeout 或者 ch 管道中获取数据。如果 ch 管道在 1 秒钟之后还没有返回数据，超时的判断条件就会触发 ch 的读操作将会被抛弃掉。
select { case &amp;lt;-ch: // a read from ch has occurred case &amp;lt;-timeout: // the read from ch has timed out }  timeout 管道的缓冲区空间为 1，因此 timeout 协程将会在发送消息到管道之后退出执行。协程并不知道（也不关心）管道中的值是否被接受。因此，即使 ch 管道先于 timeout 管道返回了，timeout 协程也不会永久等待。timeout 管道最终会被垃圾回收机制回收掉。</description>
    </item>
    
    <item>
      <title>Golang 并发模式超时和继续 Go Concurrency Patterns: Timing out moving on</title>
      <link>https://yushuangqi.com/blog/2016/golang-bing-fa-mo-shi-chao-shi-he-ji-xu--go-concurrency-patterns-timing-out-moving-on.html</link>
      <pubDate>Sat, 31 Dec 2016 11:18:42 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/golang-bing-fa-mo-shi-chao-shi-he-ji-xu--go-concurrency-patterns-timing-out-moving-on.html</guid>
      <description>翻译自 Go Blog。
原文地址：https://blog.golang.org/go-concurrency-patterns-timing-out-and
并发编程有自己的一些习惯用语，超时就是其中之一。虽然 Golang 的管道并没有直接支持超时，但是实现起来并不难。假设遇到了这样一种场景：在从 管道 ch 中取值之前至少等待 1 秒钟。我们可以创建一个管道用来传递信号，开启一个协程休眠一秒钟，然后给管道传递一个值。
timeout := make(chan bool, 1) go func() { time.Sleep(1 * time.Second) timeout &amp;lt;- true }()  然后就可以使用一个 select 语句来从 timeout 或者 ch 管道中获取数据。如果 ch 管道在 1 秒钟之后还没有返回数据，超时的判断条件就会触发 ch 的读操作将会被抛弃掉。
select { case &amp;lt;-ch: // a read from ch has occurred case &amp;lt;-timeout: // the read from ch has timed out }  timeout 管道的缓冲区空间为 1，因此 timeout 协程将会在发送消息到管道之后退出执行。协程并不知道（也不关心）管道中的值是否被接受。因此，即使 ch 管道先于 timeout 管道返回了，timeout 协程也不会永久等待。timeout 管道最终会被垃圾回收机制回收掉。</description>
    </item>
    
  </channel>
</rss>