<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐的博客</title>
    <link>https://yushuangqi.com/tags/go-web-framework.xml</link>
    <description>在 虞双齐的博客上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <atom:link href="/tags/go-web-framework.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Go语言net_http包使用模式</title>
      <link>https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:08 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html</guid>
      <description>译注: 这篇文章的内容非常基础，也非常容易理解。原文地址，感觉是最能清晰的讲述了net/http包的用法的一篇，故翻译一下共享之。
一切的基础：ServeMux 和 Handler Go 语言中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。
ServrMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。
处理器（Handler）负责输出HTTP响应的头和正文。任何满足了http.Handler接口的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的ServeHTTP方法即可：
ServeHTTP(http.ResponseWriter, *http.Request)  Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如FileServer，NotFoundHandler 和 RedirectHandler。我们从一个简单具体的例子开始：
$ mkdir handler-example $ cd handler-example $ touch main.go //File: main.go package main import ( &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; ) func main() { mux := http.NewServeMux() rh := http.RedirectHandler(&amp;quot;http://example.org&amp;quot;, 307) mux.Handle(&amp;quot;/foo&amp;quot;, rh) log.Println(&amp;quot;Listening...&amp;quot;) http.ListenAndServe(&amp;quot;:3000&amp;quot;, mux) }  快速地过一下代码：
 在 main 函数中我们只用了 http.NewServeMux 函数来创建一个空的 ServeMux。</description>
    </item>
    
  </channel>
</rss>