<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发</title>
    <link>https://yushuangqi.com/tags/git.xml</link>
    <description>在 虞双齐Golang开发上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <atom:link href="/tags/git.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>150行Go代码实现gitcheckout功能</title>
      <link>https://yushuangqi.com/blog/2016/150hang-godai-ma-shi-xian-git-checkoutgong-neng.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:07 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/150hang-godai-ma-shi-xian-git-checkoutgong-neng.html</guid>
      <description>由于历史原由，git一直是被黑成比较难用的版本控制器。其实近年来git的用户界面已经被简化的非常简单了，配上github、bitbucket等hosting,已接近完美。
git其实挺简单的，本文用了约150行golang代码实现了git checkout功能，阅读代码之前，您应该读过《Git Pro》中的git内部原理一节。
 数据定义： type blob struct { sha1 string filename string } type tree struct { b []*blob name string child []*tree } type commit struct { sha1 string tree *tree parent *commit }
  其中blob定义一个文件 ,sha1是文件的sha1值,filename是不包括路径的文件名。
tree定义相当于目录，b是目录下的文件，name是当前目录名，不包括父路径，child是目录下的目录。
commit是一次提交，sha1是提交的sha1值，tree指向一要树形的根节点，沿此根结点可以检出所有的文件。
对照下面这副图就比较容易理解:
 工具函数 func readSha1FileReader(sha1 string) (reader io.Reader, err error) {
f, err := os.Open(getSha1FilePath(sha1)) if err != nil{ return } return zlib.NewReader(f)  }
func readSha1FileContent(sha1 string) (content []byte, err error) {</description>
    </item>
    
    <item>
      <title>【新功能】GitCafe已经支持Go语言Package托管</title>
      <link>https://yushuangqi.com/blog/2016/xin-gong-neng-gitcafe-yi-jing-zhi-chi--go-yu-yan--package-tuo-guan.html</link>
      <pubDate>Sat, 31 Dec 2016 11:34:36 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/xin-gong-neng-gitcafe-yi-jing-zhi-chi--go-yu-yan--package-tuo-guan.html</guid>
      <description>之前有用户希望 GitCafe 可以支持 go get，使其能够直接导入 GitCafe 上托管的代码。
现在，我们想要告诉各位一个好消息，为了方便更多的开发者，任何托管在 GitCafe 上的 Go 语言 package 都可以直接在项目中使用，通过 go get 工具安装和更新。
例如，我们可以在本机创建一个 hello_world.go 文件，内容如下：
 package main import &amp;quot;gitcafe.com/rainux/go-hello&amp;quot; func main() { hello.World() }  执行 go get -d 命令可以将 GitCafe 上托管的 go-hello 项目源代码安装到 \$GOPATH 中；执行 go run hello_world.go 可以输出经典的 &amp;ldquo;Hello world!&amp;rdquo; 信息。
如下所示：
希望各位开发者都可以在 GitCafe 更加方便地进行开发，现在就开始吧！
Happy Go Programming!
Tips: Go （也叫 &amp;ldquo;golang&amp;rdquo;）是一款由 Google 最初开发的编程语言。它自诞生就有几个设计原则：简单性、安全性和速度。Go 语言发行版拥有各种调试、测试、调优和代码审查工具。
go get 是 golang 默认的包管理工具，它支持通过 git/mercurial 等版本控制工具远程导入包</description>
    </item>
    
    <item>
      <title>独孤九剑(0x00)-我为什么要做Dit</title>
      <link>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x00---wo-wei-shen-me-yao-zuo--dit.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:19 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x00---wo-wei-shen-me-yao-zuo--dit.html</guid>
      <description>又挖了一个深坑，不是没事专坑自己。只是想在无聊的时光里，找点乐子，找点事做。
 小时候，最令我着迷的就是邻家的 DVD。印象中的男主角都会经历三个阶段: 被虐-&amp;gt;上山学艺-&amp;gt;下山报仇。
再长大一点，我成了金庸迷。被金大侠天马行空的想象力所折服，一个人的脑子里，怎么会容得下那么多东西，而且如此的自然，令人信服。巧合的是，那些快意恩仇的大侠们，也都有过独自修练的经历。
后来，我迷上了电脑，“一入侯门深似海，从此萧郎是路人”，不能自拔，开始立志做一名优秀的程序员。我最佩服的神牛有两位：Donald 和 Linus。风靡世界的 Linux 操作系统，虽然没有使用任何 MINIX 和 Unix 的源代码，但是 Linus 至少是研究透了 MINIX 和 Unix 的工作方式的。Donald 花费近十年的时间解决了计算机排版问题，且不说 TeX 逼近圆周率的完美程度，就光十年如一日做只一件事的耐心，就让我钦佩不已。
我也要经历这样一个默默修炼的过程，要修炼就得有剑谱，我心中最喜欢的剑法就是独孤九剑。
独孤九剑 那本看了 1&amp;frasl;3 的《计算机程序设计艺术第1卷》在我柜子里都不知道躺了多少年，一直没有勇气再拾起来，对 Donald 这种神一样的人物，我只能望洋兴叹了。而 Linus 就亲民多了，是个一封邮件就能联系到的大侠。Linux 和 Git 得其一者得天下，而 Linus 同时拥有两者。一般来说，人愈老修为愈深。Git 做为 Linus 后期的作品，让我一接触到就爱不释手，Git 有多牛逼我就不说了，网上一大片的文章。是的，Git 就是我心中的独孤九剑。
Dit 对，接下来我会模仿 Git 实现一个类似的工具 Dit ，来打发无聊的业余时间。我已经为它想好了 logo，大家感受一下：😄
基于以下这几点：
 源于对 git 的爱和对 Linus 的崇拜
 取名 dit (do it together)，希望有更多小伙伴参与
 就算是 git，也不希望耷拉着，要坚挺
 相关的技术会引入下一版本的 opensse</description>
    </item>
    
    <item>
      <title>独孤九剑(0x01)-总决</title>
      <link>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x01---zong-jue.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:19 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x01---zong-jue.html</guid>
      <description>总诀：“归妹趋无妄，无妄趋同人，同人趋大有。甲转丙，丙转庚，庚转癸。子丑之交，辰巳之交，午未之交。风雷是一变，山泽是一变，水火是一变。乾坤相激，震兑相激，离巽相激。三增而成五，五增而成九……”（共三千余字）
 独孤九剑讲究料敌先机，无招胜有招。在程序世界里，需要根据不同的需求不断的迭代。系统不能像剑法一样随手变更，往往需要花费无数个人月「最近体会到可以把变化做成接口，留给用户，来应对一部分需求变更」。程序＝算法＋数据结构, 很少有像 TeX 那样，在算法和数据结构两方面都趋近完美，Donald 独自完成了 99.99%，甚至连 bug 数，都少到了惊人的地步。我认为程序设计最重要的是数据结构，深刻理解数据结构，设计最合适的数据结构，以不变应万变，才能抓住需求的本质，解决用户的痛点，做到在需求变化或者转型时，改变最小。
总决 以不变应万变
 烂程序员关心的是代码。好程序员关心的是数据结构和它们之间的关系。
 数据结构 Git 数据结构设计的非常精良，据说在之后十几年的开发中，feature 扩展了无数，基础数据结构却很少变动。体会一下 Linus 的一段话：
 Git 的设计其实非常的简单，它的数据结构很稳定，并且有丰富的文档描述。事实上，我非常的赞同应该围绕我们的数据结构来设计代码，而不是依据其它的，我认为这也是 Git 之所以成功的原因之一[…], 依我的观点，好程序员和烂程序员之间的差别就在于他们认为是代码更重要还是数据结构更重要。
 心里痒痒的，就让我们来一窥 Git 的奥秘吧。
Git的设计思想  直接记录快照，而非差异比较  Git 不存储文件差异，把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。下图中如果与前一个版本相比文件有改变，则存储新文件(快照)到下一个版本中。如果没有改变，则只存储之前文件的索引，如图虚线框所示。
 近乎所有操作都是本地执行  在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。你能愉快地提交，直到有网络连接时再上传。
 Git 保证完整性  Git 中所有数据在存储前都计算校验和(使用 SHA-1 散列)，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。
 Git 一般只添加数据  你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。</description>
    </item>
    
    <item>
      <title>独孤九剑(0x03)-当前目录缓存篇</title>
      <link>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x03---dang-qian-mu-lu-huan-cun-pian.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:18 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x03---dang-qian-mu-lu-huan-cun-pian.html</guid>
      <description>每个人都会变成自己讨厌的人
 Git 通过二进制文件 .git/index 来缓存当前目录，实现工作目录和仓库数据的快速交换。Git 的缓存却保存在 index 文件里，为什么不是 cache，很奇怪。
Git 当前目录缓存至少应该满足以下功能：
 可随时根据当前仓库(HEAD 状态)生成缓存。
 缓存不一定总是和仓库状态保持一致。
 缓存数据格式固定，可长期被多个 Git 命令解析。
  Git index 文件格式 当前目录缓存文件承担多个 Git 命令之间的数据交换和传递，它的文件格式也比较重要。
Git index (version 2) 使用二进制方式存储，存储内容如下：
详细的格式可以在这里找到 Git index format。
看到了 Linus 在一开始就设计了版本号，为以后 index 的文件格式变动提供方便，值得我们借鉴。
除了 Git object 要求的 flags/size/path name/sha1 之外, 每个index 相还存储了 stat 2 的信息。对 index 文件也使用 sha1 编码，用来验证数据的正确与否。
另外，index 文件的安排和实现，都尽可能少的使用空间，并用二进制方式存储。节约资源是大牛的基本素养！
Dit 选择使用 version 2 版本的 index 文件格式实现。</description>
    </item>
    
    <item>
      <title>独孤九剑(0x04)-测试篇</title>
      <link>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x04---ce-shi-pian.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:17 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/du-gu-jiu-jian-0x04---ce-shi-pian.html</guid>
      <description>《南皮县志·风土志下·歌谣》：“兵马不动，粮草先行”。作战时兵马还没出动，军用粮草的运输要先行一步。在开发新功能之前，先编写测试代码，然后只编写使测试通过的功能代码，这种测试驱动开发的软件开发模式是我非常推荐的。
 对 Dit 的贡献要求需要通过单元测试，编写 Dit 的任意模块，都需要一并编写测试用例。本文先简述一下 Go 对测试的支持，后续会陆续提供 Dit 的测试方案和测试报告。
Go 对测试的支持 Go 自带的测试框架 testing 支持单元测试和性能测试。Go 规定测试文件以 _test.go 为后缀，使用命令 go test 命令自动运行测试用例。
单元测试 以 Test 开头的方法为一个测试用例，并拥有一个参数 *testing.T, 写法如下：
func TestXxx(*testing.T)  Xxx 部分为任意的字母数字组合，首字母不能是小写字母。*testing.T 可记录错误或者标记错误状态。可通过Short判断略过一部分测试，加快测试时间。如下：
func TestTimeConsuming(t *testing.T) { if testing.Short() { t.Skip(&amp;quot;skipping test in short mode.&amp;quot;) } ... }  性能测试 性能测试用例以 Benchmark 开始，参数为 *testing.B, 写法如下：
func BenchmarkXxx(*testing.B)  使用 go test 运行性能测试用例时，需要加上参数 -bench。
在编写性能测试用例时,需牢记在循环体内使用 testing.B.N , 以使测试可以正常的运行:</description>
    </item>
    
    <item>
      <title>深入体验bashonwindows在windows上搭建原生的linux开发环境酷！</title>
      <link>https://yushuangqi.com/blog/2016/shen-ru-ti-yan-bash-on-windowszai-windowsshang-da-jian-yuan-sheng-de-linuxkai-fa-huan-jing-ku-.html</link>
      <pubDate>Sat, 31 Dec 2016 11:33:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/shen-ru-ti-yan-bash-on-windowszai-windowsshang-da-jian-yuan-sheng-de-linuxkai-fa-huan-jing-ku-.html</guid>
      <description>今年微软Build 2016大会最让开发人员兴奋的消息之一，就是在Windows上可以原生运行Linux bash，对开发人员来说，这是一个喜闻乐见的消息。
1 安装 你必须安装开发者预览版本，才能使用windows的linux subsystem功能。
 首先打开你的Windows 10的设置，在&amp;rdquo;更新和安全&amp;rdquo;选项中（我的机器是英文操作系统，但中文操作系统类似），选择&amp;rdquo;开发者&amp;rdquo;，然后选择&amp;rdquo;开发者模式&amp;rdquo;：
 在Windows 更新和安全选项中，选择&amp;rdquo;Windows 更新&amp;rdquo;，在&amp;rdquo;更新设置&amp;rdquo;中选择高级选项，你必须打开&amp;rdquo;内部预览版本&amp;rdquo;选项，并且将内部预览的级别设置为最快：
 在&amp;rdquo;设置&amp;rdquo;-&amp;gt;&amp;ldquo;系统&amp;rdquo;选项中，查看当前系统信息，你的OS版本必须是14316，如果不是这个版本，请运行在线升级，升级到这个版本：
 升级完成后，打开&amp;rdquo;控制面板&amp;rdquo;-》&amp;rdquo;程序&amp;rdquo;，选择&amp;rdquo;打开或者关闭Windows特性&amp;rdquo;，找到Windows Subsystem for Linux(beta)点选并确定，系统会下载更新并提示重启机器：
 重启完成后，进入命令行程序，激动人心的时刻来临了，在命令行下敲bash，会提示你是否继续，选择yes，系统会安装Ubuntu文件系统等待完成后，系统会切换到你熟悉的Linux bash模式，试试你熟悉的ls等命令：
 打开Windows菜单，你会发现系统中多了一个Ubuntu的图标，这个就是bash on Ubuntu on Windows：
 简单测试一下python，perl等语言，发现已经装好了，当然，这个就是Ubuntu的bash，你可以安装Java，Ruby等等：
  下面来实际测试下ubuntu on windows环境！
2 系统检测和更新 2.1 版本检测 运行 uname -a 结果如下
webmaster@FEKETERIGO-PC:~$ uname -a Linux FEKETERIGO-PC 3.4.0+ #1 PREEMPT Thu Aug 1 17:06:05 CST 2013 x86_64 x86_64 x86_64 GNU/Linux webmaster@FEKETERIGO-PC:~$  运行 lsb_release -a 结果如下</description>
    </item>
    
    <item>
      <title>Wecrcker自动部署到Github过程中问题记录</title>
      <link>https://yushuangqi.com/blog/2016/wercker-deploy-github-qa.html</link>
      <pubDate>Thu, 10 Mar 2016 14:21:31 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/wercker-deploy-github-qa.html</guid>
      <description>TMD总算顺利的将项目自动发布github中，这里分享下利用 wercker 自动部署到 github 时遇到的一系列问题。
wercker 配置 deploy: box: samueldebruyn/debian-git steps: - ysqi/git-push: gh_oauth: $GIT_TOKEN basedir: public clean_removed_files: true branch: $GIT_BRANCH repo: $GIT_REPO gh_pages_domain: $GIT_DOMAIN  又麻利又大方地分享下我的设置：
 box 是必须要的，并且要包含 git 环境，尝试了各种 box 最终挑选了 samueldebruyn/debian-git 满足要求。
 __ysqi/git-push __
step 使用我自己的 git-push ，原来鼻祖的leipert/git-push 有问题，报错信息“getAllStepVars: command not found”
source &amp;quot;/pipeline/git-push-36805875-502f-4737-a412-1b6f6880f7a4/run.sh&amp;quot; &amp;lt; /dev/null /pipeline/git-push-36805875-502f-4737-a412-1b6f6880f7a4/run.sh: line 5: getAllStepVars: command not found using github repo &amp;quot;ysqi.github.io&amp;quot; remote URL will be https://oauth-token@github.com/ysqi.github.io.git  这鼻祖没法玩，硬是不合并别人的PR，没法办只能自己动手，我也Fork了一份好好先生的。你也可以用我的 git-push</description>
    </item>
    
    <item>
      <title>hexo部署代码到百度提示:error:RPC failed;result=22,HTTP code=411</title>
      <link>https://yushuangqi.com/blog/2015/hexo-deploy-git-push-error-rpc-411.html</link>
      <pubDate>Mon, 31 Aug 2015 10:01:36 +0000</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2015/hexo-deploy-git-push-error-rpc-411.html</guid>
      <description>终于在 Coding.net 上部署搭建了写作环境,同时提交到我的博客,但在deploy到百度应用时有报错,在这里记录下解决方案.
问题表现 执行hexo deploy 时提示error:RPC failed;result=22,HTTP code=411&#39; 具体错误信息见下
hexo deploy error: RPC failed; result=22, HTTP code = 411 fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly ...... Everything up-to-date  错误原因 新搭建的环境,public 内容初始状态不是来源于 BAE git,而在首次 deploy 时提交的内容过大,而被 BAE 拒绝.
解决方案 修改hexo-doployer-git 下 git 的缓冲区大小,执行代码如下
cd .deploy_git/.git vim config  再在文档中添加或修改配置项,修改到50M
[http] postBuffer = 52428800  再次执行hexo deploy 时成功,一键发布到 BAE!</description>
    </item>
    
  </channel>
</rss>