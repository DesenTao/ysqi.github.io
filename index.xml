<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/index.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <lastBuildDate>Mon, 13 Mar 2017 08:34:22 +0800</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>互联网数据库“跨库分页”架构技术实践</title>
      <link>https://yushuangqi.com/blog/2017/hu-lian-wang-shu-ju-ku-kua-ku-fen-xie-jia-gou-ji-shu-shi-jian.html</link>
      <pubDate>Mon, 13 Mar 2017 08:34:22 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/hu-lian-wang-shu-ju-ku-kua-ku-fen-xie-jia-gou-ji-shu-shi-jian.html</guid>
      <description>一、需求缘起 分页需求 互联网很多业务都有分页拉取数据的需求，例如：
 微信消息过多时，拉取第N页消息。 京东下单过多时，拉取第N页订单。 浏览58同城，查看第N页帖子。  这些业务场景对应的消息表，订单表，帖子表分页拉取需求有这样一些特点：
 有一个业务主键id，例如msg_id，order_id，tiezi_id 分页排序是按照非业务主键id来排序的，业务中经常按照时间time来排序order by  在数据量不大时，可以通过在排序字段time上建立索引，利用SQL提供的offset/limit功能就能满足分页查询需求：
select * from t_msg order by time offset 200 limit 100 select * from t_order order by time offset 200 limit 100 select * from t_tiezi order by time offset 200 limit 100  此处假设一页数据为100条，均拉取第3页数据。
分库需求 高并发大流量的互联网架构，一般通过服务层来访问数据库，随着数据量的增大，数据库需要进行水平切分，分库后将数据分布到不同的数据库实例（甚至物理机器）上，以达到降低数据量，增加实例数的扩容目的。
一旦涉及分库，逃不开“分库依据”patition key的概念，使用哪一个字段来水平切分数据库呢：大部分的业务场景，会使用业务主键id。
确定了分库依据patition key后，接下来要确定的是分库算法：大部分的业务场景，会使用业务主键id取模的算法来分库，这样即能够保证每个库的数据分布是均匀的，又能够保证每个库的请求分布是均匀的，实在是简单实现负载均衡的好方法，此法在互联网架构中应用颇多。
举一个更具体的例子：
用户库user，水平切分后变为两个库，分库依据patition key是uid，分库算法是uid取模：uid%2余0的数据会落到db0，uid%2余1的数据会落到db1。
问题的提出 仍然是上述用户库的例子，如果业务要查询“最近注册的第3页用户”，该如何实现呢？单库上，可以select * from t_user order by time offset 200 limit 100，变成两个库后，分库依据是uid，排序依据是time，数据库层失去了time排序的全局视野，数据分布在两个库上，此时该怎么办呢？</description>
    </item>
    
    <item>
      <title>分布式事务一致性方案</title>
      <link>https://yushuangqi.com/blog/2017/fen-bu-shi-shi-wu-yi-zhi-xing-fang-an.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:10 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/fen-bu-shi-shi-wu-yi-zhi-xing-fang-an.html</guid>
      <description>在OLTP系统领域，我们在很多业务场景下都会面临事务一致性方面的需求，例如最经典的Bob给Smith转账的案例。传统的企业开发，系统往往是以单体应用形式存在的，也没有横跨多个数据库。我们通常只需借助开发平台中特有数据访问技术和框架（例如Spring、JDBC、ADO.NET），结合关系型数据库自带的事务管理机制来实现事务性的需求。关系型数据库通常具有ACID特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。
而大型互联网平台往往是由一系列分布式系统构成的，开发语言平台和技术栈也相对比较杂，尤其是在SOA和微服务架构盛行的今天，一个看起来简单的功能，内部可能需要调用多个“服务”并操作多个数据库或分片来实现，情况往往会复杂很多。单一的技术手段和解决方案，已经无法应对和满足这些复杂的场景了。
分布式系统的特性
对分布式系统有过研究的读者，可能听说过“CAP定律”、“Base理论”等，非常巧的是，化学理论中ACID是酸、Base恰好是碱。这里笔者不对这些概念做过多的解释，有兴趣的读者可以查看相关参考资料。CAP定律如下图：

在分布式系统中，同时满足“CAP定律”中的“一致性”、“可用性”和“分区容错性”三者是不可能的，这比现实中找对象需同时满足“高、富、帅”或“白、富、美”更加困难。在互联网领域的绝大多数的场景，都需要牺牲强一致性来换取系统的高可用性，系统往往只需要保证“最终一致性”，只要这个最终时间是在用户可以接受的范围内即可。
分布式事务
提到分布式系统，必然要提到分布式事务。要想理解分布式事务，不得不先介绍一下两阶段提交协议。先举个简单但不精准的例子来说明：
第一阶段，张老师作为“协调者”，给小强和小明（参与者、节点）发微信，组织他们俩明天8点在学校门口集合，一起去爬山，然后开始等待小强和小明答复。
第二阶段，如果小强和小明都回答没问题，那么大家如约而至。如果小强或者小明其中一人回答说“明天没空，不行”，那么张老师会立即通知小强和小明“爬山活动取消”。
细心的读者会发现，这个过程中可能有很多问题的。如果小强没看手机，那么张老师会一直等着答复，小明可能在家里把爬山装备都准备好了却一直等着张老师确认信息。更严重的是，如果到明天8点小强还没有答复，那么就算“超时”了，那小明到底去还是不去集合爬山呢？
这就是两阶段提交协议的弊病，所以后来业界又引入了三阶段提交协议来解决该类问题。
两阶段提交协议在主流开发语言平台，数据库产品中都有广泛应用和实现的，下面来介绍一下XOpen组织提供的DTP模型图：

XA协议指的是TM（事务管理器）和RM（资源管理器）之间的接口。目前主流的关系型数据库产品都是实现了XA接口的。JTA(Java Transaction API)是符合X/Open DTP模型的，事务管理器和资源管理器之间也使用了XA协议。 本质上也是借助两阶段提交协议来实现分布式事务的，下面分别来看看XA事务成功和失败的模型图：

在JavaEE平台下，WebLogic、Webshare等主流商用的应用服务器提供了JTA的实现和支持。而在Tomcat下是没有实现的（其实笔者并不认为Tomcat能算是JavaEE应用服务器），这就需要借助第三方的框架Jotm**、Automikos等来实现，两者均支持spring事务整合。*而在Windows .NET平台中，则可以借助ado.net中的TransactionScop*API来编程实现，还必须配置和借助Windows操作系统中的MSDTC服务。如果你的数据库使用的mysql，并且mysql是部署在Linux平台上的，那么是无法支持分布式事务的。 由于篇幅关系，这里不展开，感兴趣的读者可以自行查阅相关资料并实践。**总结：这种方式实现难度不算太高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况。但分布式事务对性能的影响会比较大，不适合高并发和高性能要求的场景。**
提供回滚接口
在服务化架构中，功能X，需要去协调后端的A、B甚至更多的原子服务。那么问题来了，假如A和B其中一个调用失败了，那可怎么办呢？
在笔者的工作中经常遇到这类问题，往往提供了一个BFF层来协调调用A、B服务。如果有些是需要同步返回结果的，我会尽量按照“串行”的方式去调用。如果调用A失败，则不会盲目去调用B。如果调用A成功，而调用B失败，会尝试去回滚刚刚对A的调用操作。
当然，有些时候我们不必严格提供单独对应的回滚接口，可以通过传递参数巧妙的实现。
这样的情况，我们会尽量把可提供回滚接口的服务放在前面。举个例子说明：
我们的某个论坛网站，每天登录成功后会奖励用户5个积分，但是积分和用户又是两套独立的子系统服务，对应不同的DB，这控制起来就比较麻烦了。解决思路：
把登录和加积分的服务调用放在BFF层一个本地方法中。
当用户请求登录接口时，先执行加积分操作，加分成功后再执行登录操作
如果登录成功，那当然最好了，积分也加成功了。如果登录失败，则调用加积分对应的回滚接口（执行减积分的操作）。
总结：这种方式缺点比较多，通常在复杂场景下是不推荐使用的，除非是非常简单的场景，非常容易提供回滚，而且依赖的服务也非常少的情况。
这种实现方式会造成代码量庞大，耦合性高。而且非常有局限性，因为有很多的业务是无法很简单的实现回滚的，如果串行的服务很多，回滚的成本实在太高。
本地消息表
这种实现方式的思路，其实是源于ebay，后来通过支付宝等公司的布道，在业内广泛使用。其基本的设计思想是将远程分布式事务拆分成一系列的本地事务。如果不考虑性能及设计优雅，借助关系型数据库中的表即可实现。
举个经典的跨行转账的例子来描述。
第一步伪代码如下，扣款1W，通过本地事务保证了凭证消息插入到消息表中。

第二步，通知对方银行账户上加1W了。那问题来了，如何通知到对方呢？
通常采用两种方式：
采用时效性高的MQ，由对方订阅消息并监听，有消息时自动触发事件
采用定时轮询扫描的方式，去检查消息表的数据。
两种方式其实各有利弊，仅仅依靠MQ，可能会出现通知失败的问题。而过于频繁的定时轮询，效率也不是最佳的（90%是无用功）。所以，我们一般会把两种方式结合起来使用。
解决了通知的问题，又有新的问题了。万一这消息有重复被消费，往用户帐号上多加了钱，那岂不是后果很严重？
仔细思考，其实我们可以消息消费方，也通过一个“消费状态表”来记录消费状态。在执行“加款”操作之前，检测下该消息（提供标识）是否已经消费过，消费完成后，通过本地事务控制来更新这个“消费状态表”。这样子就避免重复消费的问题。
总结：上诉的方式是一种非常经典的实现，基本避免了分布式事务，实现了“最终一致性”。但是，关系型数据库的吞吐量和性能方面存在瓶颈，频繁的读写消息会给数据库造成压力。所以，在真正的高并发场景下，该方案也会有瓶颈和限制的。
MQ（非事务消息）
通常情况下，在使用非事务消息支持的MQ产品时，我们很难将业务操作与对MQ的操作放在一个本地事务域中管理。通俗点描述，还是以上述提到的“跨行转账”为例，我们很难保证在扣款完成之后对MQ投递消息的操作就一定能成功。这样一致性似乎很难保证。
先从消息生产者这端来分析，请看伪代码：

根据上述代码及注释，我们来分析下可能的情况：
操作数据库成功，向MQ中投递消息也成功，皆大欢喜
操作数据库失败，不会向MQ中投递消息了
操作数据库成功，但是向MQ中投递消息时失败，向外抛出了异常，刚刚执行的更新数据库的操作将被回滚
从上面分析的几种情况来看，貌似问题都不大的。那么我们来分析下消费者端面临的问题：
消息出列后，消费者对应的业务操作要执行成功。如果业务执行失败，消息不能失效或者丢失。需要保证消息与业务操作一致
尽量避免消息重复消费。如果重复消费，也不能因此影响业务结果
如何保证消息与业务操作一致，不丢失？
主流的MQ产品都具有持久化消息的功能。如果消费者宕机或者消费失败，都可以执行重试机制的（有些MQ可以自定义重试次数）。
如何避免消息被重复消费造成的问题？
保证消费者调用业务的服务接口的幂等性
通过消费日志或者类似状态表来记录消费状态，便于判断（建议在业务上自行实现，而不依赖MQ产品提供该特性）
总结：这种方式比较常见，性能和吞吐量是优于使用关系型数据库消息表的方案。如果MQ**自身和业务都具有高可用性，理论上是可以满足大部分的业务场景的。不过在没有充分测试的情况下，不建议在交易业务中直接使用。**
MQ（事务消息）
举个例子，Bob向Smith转账，那我们到底是先发送消息，还是先执行扣款操作？
好像都可能会出问题。如果先发消息，扣款操作失败，那么Smith的账户里面会多出一笔钱。反过来，如果先执行扣款操作，后发送消息，那有可能扣款成功了但是消息没发出去，Smith收不到钱。除了上面介绍的通过异常捕获和回滚的方式外，还有没有其他的思路呢？
下面以阿里巴巴的RocketMQ中间件为例，分析下其设计和实现思路。
RocketMQ第一阶段发送Prepared消息时，会拿到消息的地址，第二阶段执行本地事物，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。细心的读者可能又发现问题了，如果确认消息发送失败了怎么办？RocketMQ会定期扫描消息集群中的事物消息，这时候发现了Prepared消息，它会向消息发送者确认，Bob的钱到底是减了还是没减呢？如果减了是回滚还是继续发送确认消息呢？RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。如下图：
**</description>
    </item>
    
    <item>
      <title>GoDoc文档使用</title>
      <link>https://yushuangqi.com/blog/2017/goyu-yan-shi-zhan-bi-ji-san--go-doc-wen-dang.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:09 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/goyu-yan-shi-zhan-bi-ji-san--go-doc-wen-dang.html</guid>
      <description>《Go语言实战》读书笔记，未完待续，欢迎关注公众号flysnow_org，第一时间看后续笔记。
 对于协作开发或者代码共享来说，文档是一个可以帮助开发者快速了解以及使用这些代码的一个教程，文档越全面，越详细，入门越快，效率也会更高。
在Go语言中，Go为我们提供了快速生成文档以及查看文档的工具，让我们可以很容易的编写查看文档。
Go提供了两种查看文档的方式，一种是使用go doc命令在终端查看，这种适用于使用VIM等工具在终端开发的人员，它们不用离开终端，既可以查看想查看的文档，又可以编码。
第二种方式，是使用浏览器查看的方式，通过godoc命令可以在本机启动一个web服务，我们可以通过打开浏览器，访问这个服务来查看我们的Go文档。
从终端查看文档 这种方式适用于在终端开发的，它们一般不像离开终端，查完即可继续编码，这时候使用go doc命令是很不错的选择。
➜ hello go help doc usage: go doc [-u] [-c] [package|[package.]symbol[.method]] Doc prints the documentation comments associated with the item identified by its arguments (a package, const, func, type, var, or method) followed by a one-line summary of each of the first-level items &amp;quot;under&amp;quot; that item (package-level declarations for a package, methods for a type, etc.). Flags: -c Respect case when matching symbols.</description>
    </item>
    
    <item>
      <title>go_js简介及实例演示</title>
      <link>https://yushuangqi.com/blog/2017/go_jsjian-jie-ji-shi-li-yan-shi.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:08 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go_jsjian-jie-ji-shi-li-yan-shi.html</guid>
      <description>GoJS是一个JavaScript库，让你轻松创建现代Web浏览器的交互图。 GoJS支持图形化的模板和图形对象属性数据模型的数据绑定。你只需要保存和恢复模型，包括持有任何性质的应用需求，简单的JavaScript对象。许多预定义的工具和命令执行，大部分的图表所需要的标准的行为。外观和行为的定制是大多设置属性的问题。
下载地址：http://gojs.net/latest/doc/download.html
使用gojs开发的流程图及拓扑图实例：http://gojs.net/latest/samples/index.html
goJS去水印版：http://download.csdn.net/detail/qq_14966339&amp;frasl;9569675
goJS实例演示：
function init() { if (window.goSamples) goSamples(); // init for these samples -- you don&#39;t need to call this var $ = go.GraphObject.make; // for conciseness in defining templates myDiagram = $(go.Diagram, &amp;quot;myDiagramDiv&amp;quot;, // must name or refer to the DIV HTML element { initialContentAlignment: go.Spot.Center, allowDrop: true, // must be true to accept drops from the Palette &amp;quot;LinkDrawn&amp;quot;: showLinkLabel, // this DiagramEvent listener is defined below &amp;quot;LinkRelinked&amp;quot;: showLinkLabel, &amp;quot;animationManager.</description>
    </item>
    
    <item>
      <title>go_js模型样式选择</title>
      <link>https://yushuangqi.com/blog/2017/go_jsmo-xing-yang-shi-shua-ze.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:07 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go_jsmo-xing-yang-shi-shua-ze.html</guid>
      <description>一、使用官方样式 样式（shapes）地址：http://gojs.net/latest/samples/shapes.html
使用方法：
 myDiagram.nodeTemplateMap.add(&amp;quot;End&amp;quot;, $(go.Node, &amp;quot;Spot&amp;quot;, nodeStyle(), $(go.Panel, &amp;quot;Auto&amp;quot;, $(go.Shape, &amp;quot;Circle&amp;quot;, // 在此处设置样式 { minSize: new go.Size(40, 40), fill: &amp;quot;#DC3C00&amp;quot;, stroke: null }), $(go.TextBlock, &amp;quot;End&amp;quot;, { font: &amp;quot;bold 11pt Courier New,Microsoft Yahei&amp;quot;, stroke: lightText }, new go.Binding(&amp;quot;text&amp;quot;)) ), makePort(&amp;quot;T&amp;quot;, go.Spot.Top, false, true), makePort(&amp;quot;L&amp;quot;, go.Spot.Left, false, true), makePort(&amp;quot;R&amp;quot;, go.Spot.Right, false, true) ));  二、自定义样式 通过Shape你可以构建一个几何图形，并且可以控制它的形状和轮廓颜色以及填充色等。
图形 你可以通过Shape.figure属性设置它的形状。让你使用GraphObject.make方法构建时，你可以将形状参数以字符串形式作为第二个参数。你可能还需要通过GraphObject.desiredSize、GraphObject.width、GraphObject.height属性设置Shape的尺寸大小。
下面的例子中列出了一些常用的Shape形状，并且你可以看到它们的名字：
diagram.add( $(go.Part, &amp;quot;Horizontal&amp;quot;, $(go.Shape, &amp;quot;Rectangle&amp;quot;, { width: 40, height: 60, margin: 4, fill: null }), $(go.</description>
    </item>
    
    <item>
      <title>go_js节点字体设置</title>
      <link>https://yushuangqi.com/blog/2017/go_jsjie-dian-zi-ti-she-zhi.html</link>
      <pubDate>Mon, 13 Mar 2017 08:20:07 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go_jsjie-dian-zi-ti-she-zhi.html</guid>
      <description>TextBlock是用于显示文本信息的对象。
通过设置TexkBlock.text属性来显示文本信息，这也是唯一的一个方法。因为TexkBlock继承自GraphObject，所以一些GraphObject的属性也有可能对文本有影响。
字体和颜色 可以通过TexkBlock.font属性设置文本的字体，该属性的值可以使用CSS来设置。
可以通过TextBlock.stroke属性设置文本字体的颜色，同样可以使用CSS来设置。
因为TexkBlock继承自GraphObject，所以GraphObject.background属性也可以作用于TextBlock，可以通过该属性设置文本背景色。
diagram.add( $(go.Part, &amp;quot;Vertical&amp;quot;, $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot; }), $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot;, stroke: &amp;quot;red&amp;quot; }), $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot;, background: &amp;quot;lightblue&amp;quot; }), $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot;, font: &amp;quot;bold 14pt serif&amp;quot; }) ));  结果：

尺寸和裁剪 TexkBlock的自然尺寸是会自适应设置文本的字体以及文本长度的。但是实际上它的尺寸是可大可小的。
下面的例子中首先展示了自然尺寸的TextBlock，然后对其进行明确的尺寸设置，并给与绿色背景：
diagram.add( $(go.Part, &amp;quot;Vertical&amp;quot;, $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot;, background: &amp;quot;lightgreen&amp;quot;, margin: 2 }), $(go.TextBlock, { text: &amp;quot;a Text Block&amp;quot;, background: &amp;quot;lightgreen&amp;quot;, margin: 2, width: 100, height: 33 }), $(go.</description>
    </item>
    
    <item>
      <title>Go配置文件热更新</title>
      <link>https://yushuangqi.com/blog/2017/golangpei-zhi-wen-jian-re-geng-xin.html</link>
      <pubDate>Mon, 13 Mar 2017 07:58:39 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangpei-zhi-wen-jian-re-geng-xin.html</guid>
      <description>配置文件热更新是服务器程序的一个基本功能，通过热更新可以不停机调整程序的配置，特别是在生产环境可以提供极大的便利，比如发现log打得太多了可以动态调高日志等级，业务逻辑参数变化，甚至某个功能模块的开关等都可以动态调整。
每种语言都有自己的热更新实现方式，在golang里面我看到了有人采用了一种错误的实现方式，如下：
type Config struct { Test1 string `json:&amp;quot;Test1&amp;quot;` Test2 int `json:&amp;quot;Test2&amp;quot;` } var ( config *Config ) func loadConfig() { f, err := ioutil.ReadFile(&amp;quot;config.json&amp;quot;) if err != nil { fmt.Println(&amp;quot;load config error: &amp;quot;, err) } err = json.Unmarshal(f, &amp;amp;config) if err != nil { fmt.Println(&amp;quot;Para config failed: &amp;quot;, err) } } func init() { loadConfig() fmt.Println(&amp;quot;Load config: &amp;quot;, *config) s := make(chan os.Signal, 1) signal.Notify(s, syscall.SIGUSR2) go func() { for { &amp;lt;-s loadConfig() fmt.</description>
    </item>
    
    <item>
      <title>如何用Go实现一款类似滴滴优步的网络约车软件(含源码)</title>
      <link>https://yushuangqi.com/blog/2017/ru-he-yong-goshi-xian-yi-kuan-lei-shi-di-di-you-bu-de-wang-lao-yao-che-ruan-jian-han-yuan-ma-.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:25 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ru-he-yong-goshi-xian-yi-kuan-lei-shi-di-di-you-bu-de-wang-lao-yao-che-ruan-jian-han-yuan-ma-.html</guid>
      <description>导读：我们经常使用打车软件出行，也经常思考其架构设计。本文作者在所在国家也负责开发一款打车软件，并且开源了其中大部分代码，可以帮助我们更好了解网络约车软件的架构体系。本文由高可用架构翻译。


各位读者好，本文将给大家分享我们如何通过内存存储实现地图动画车效果。 我们公司也运营了一个类似 Uber 的软件 Namba Taxi，我们需要在客户端主屏幕上显示动画车。 这篇文章是关于功能如何完整实现的文章，主要目的不是介绍 Go 语言。
 开始 
这个故事始于2015年，我们的移动开发人员开发一款软件，工作主题是为出租车司机提供打车服务。 在应用程序中，动画汽车看起来像下面的图中动画那样 [1] 。


我们的第一个挑战是缺乏地图跟踪数据。我们每 15 秒获取一次位置数据。 我们不能简单减小上报间隔，因为当司机端程序上行数据时候，同时需要获取当前订单，下一个订单，以及一些警报功能（一个SOS按钮， 当司机按下它，其他司机就可以帮助他）。当我们减少更新间隔时，系统流量更大。 我们不确认我们是否能够扛住如此大的刷新。
 实现的第一步 
我们第一次的尝试比较简单：

 处理请求并保存坐标。
 创建另一个请求并为汽车设置动画。
  
显而易见，这样做存在一些问题，如大家在一些打车软件所见，我们不能正确地绘制汽车路线，汽车可能跑在田野，森林，湖泊和公寓上，用这种方法后效果看起来是这样的 [2]。


作为问题的解决方案，我们使用 OpenStreetMap Routeing Machine（OSRM）来规划线路并改进我们的算法，并使用相同的超时设置。

 发起请求。
 获取坐标。
 将保存的坐标发送到服务器。
 通过 OSRM 构建路线。
 返回数据到客户端。
  
通过线路规划体系，现在似乎可以工作了，但我们又面临单向道路的问题


例如，司机停留在红点的十字路口。 但他的设备位置准确性有问题，导致数据标记在十字路口的对面。 在客户端，我们获取这些坐标，保存并发送到后端，OSRM 建立一个合法的路线，并返回给应用程序。因为客户端移动得非常快，所以这种情况路线规划很可笑。</description>
    </item>
    
    <item>
      <title>插曲:关于递归</title>
      <link>https://yushuangqi.com/blog/2017/cha-qu-guan-yu-di-gui.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:25 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/cha-qu-guan-yu-di-gui.html</guid>
      <description>1 概述 循环与递归是算法中最常见的控制过程的方法，循环自不必说，只要学过计算机语言，必然都会讲这种控制结构；而对于递归，大家也能写得很漂亮（树算法中和图算法中使用递归的场景也特别多）。
递归的好处也显而易见，代码体积小，容易维护。然而，递归并不是万能钥匙，特别是当运行环境内存空间有限以及要求高性能的场景。下文首先介绍递归的运行原理，然后用实例说明递归的代价，接着讲解递归如何转换成循环及其限制，最后对本文进行总结。
2 递归的运行原理 这里的递归特指递归函数，递归函数在程序中执行的原理是什么（冯诺伊曼体系下）？这是认识递归函数执行效率的关键。下面我们以构建斐波那契数列为例，说明递归函数的执行过程。构建斐波那契数列的递归函数(golang实现)如下：
fun Fib(n int) int{ ret : = 0 if n == 0 || n == 1 { // 1  ret = 1 // 2  } ret = Fib(n - 1) + Fib(n - 2) // 3  return ret }  学过编译原理的童鞋都知道，函数是在栈（对，就是童鞋们在数据结构上学习的栈）上运行的，如果n=4，Fib(4)的原理示意如图1所示：
图1:fib(4)动态示意图
要求fib(4)，必须在栈上求Fib(3)（要求Fib(3),必须再为在栈上求Fib(2)和Fib(1)，要求Fib(2)，在栈上继续求fib(1)和Fib(0)）和Fib(2)（类似fib(3)的过程）。这样的递归算法，必须在栈上记录函内的局部变量、传递参数、返回地址（直到调用结束后回到哪）和上一栈帧的EBP和BP（恢复调用者栈），并且频繁出栈入栈是需要系统开销的，虽然单次入栈出栈开销不大，但是如果要求Fib(1000)这样的函数，恐怕一般的单机估计得跑几十分钟甚至半天了（在笔者的mac本上跑了几分钟都没出来，直接把进程杀了，不能忍）。
为了有个直观的感受，笔者特意做了一个简单的试验（见我的git），分别以递归和非递归求解Fib(10), Fib(20), Fib(30), Fib(40), Fib(50)的运行结果，如下图所示：
图2：递归和非递归试验结果

从运行结果可以看出，当n值较小时（&amp;lt;10）时，递归运行的时间少于非递归运行时间（原因应该是非递归分配slice需要占用相对较长的时间，这种写法有些弱智，其实只需要两个中间变量即可，类似于不用第三个变量实现两变量值交换的思路），当n&amp;gt;=20后，非递归运行时间远低于递归运行时间，n越大，非递归相对递归越高效。
当然，非递归高效运行也不是没有代价的，相比递归函数，编写代码的难度要更高并且更难维护。
3 递归转非递归 那如何将递归函数转换为非递归函数呢？是否所有的递归函数都能换成非递归函数？
首先必须弄清楚递归有哪些种类，递归有两种，一种是单向递归，类似于Fib(n)的这种是一种典型的单向递归（Fib(n)-&amp;gt;Fib(n-1)-&amp;gt;Fib(n-2)-&amp;gt;&amp;hellip;-&amp;gt;Fib(1)）；另一种的递归（不妨称其为交互递归，不一定准确）的形式为：F1(n) -&amp;gt; F2(n) -&amp;gt; F1(n-1) -&amp;gt; F2(n-1) -&amp;gt; &amp;hellip;</description>
    </item>
    
    <item>
      <title>为什么Go语言在中国格外的火</title>
      <link>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:23 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/wei-shen-me-goyu-yan-zai-zhong-guo-ge-wai-de-huo-amp.html</guid>
      <description>go语言推出有几年了，似乎不温不火。但是在中国范围内，确实被关注的一塌糊涂。
这是2017年2月份TIOBE出的编程语言排名：
在拉勾网上搜索go的职位，结果有119个(2017年2月14日搜索结果)，似乎还没有那么火爆：
但是在中国，很多公司，很多程序员都在谈论go语言，也就是说在中国对于go的关注异常火爆。
根据谷歌搜索的统计，如下图： The graph above shows the searches for “golang” by country on Google Trends.
外国人专门写了一篇文章，来分析为什么go在中国如此火： ( 《Why is Golang popular in China?》)http://herman.asia/why-is-go-popular-in-china
下面是知乎的回复： 作者：匿名用户
链接：https://www.zhihu.com/question/30172794/answer/47122000
来源：知乎 著作权归作者所有，转载请联系作者获得授权。
这个“火”字看你怎么理解了。 Go在国内更火只是感觉上的。比如推文，以及谈论的相关话题较多而已(但能有nodejs多么？)，本身中国人口数量就多，按这个衡量的办法去看的话，swift在国内也比在国外火； 实际上Go在国外更火（这里的火是实际的使用情况），对比一下国内和国外使用Go的程度、数量，Go相关的技术大会举办的频率和数量就一目了然了。
Go在国内真正上被全栈使用的就七牛一家，但国外除了docker，coreOS还有很多初创企业。 国内比较有影响力的就一个beego框架，你看看国外的有多少。
去github上搜一下active的Go的project数量，看看Go在国外是不是没人用？我反正在github的trending里面几乎每天都能看到Go的project。hacker news上面有关Go的“xxx writen in Go”的炒作文也不要太多。 这个 dariubs/GoBooks · GitHub 是有人整理的Go相关的书籍，看看是不是国外的书籍比国内的少？8月份K&amp;amp;R中的K也要推出属于Go的圣经了。
另外老有人喜欢说：Google喜欢关闭产品，这玩意儿迟早死掉。可惜golang是开源项目，关不掉的，CloudFlare那个crypto的patch(Gerrit Code Review)以后可能会进Go的标准库，Godep已经成为事实上的包管理标准，这些都是社区自己搞出来的，和google一毛线关系没有。另外就是最近google自己一些主力产品或者平台在优先支持语言上，Go总是和java，c/c++，python一起名列其中，grpc就是一个例子等等。所以，觉得Go只是google的一个玩具的人，你的观点能不能站得住脚，自己掂量吧。
我的个人观点是： Go显示已经站住了脚跟(如果是2013年，我还是不敢说这种话的)，找到了属于自己的空间，但是比起那些主流的甚至nodeJS来说，还是使用的不够广泛。这个语言人为炒作也罢，一些人认为的google光环也罢，实际使用也罢，总之： 这个语言已经站住脚跟了，能用于并且已经用于生产环境了，接下来几年只会一直呈上升势头。
个人观点：
1 一些真正使用go语言的公司：
这些公司在高速发展的同时，Golang也因此在国内逐渐传播开来。在云计算时代，从国内Go 语言发展和应用来看，七牛算是国内第一家选 Go 语言做服务端的公司。早在2011年，当Go语法还没完全稳定下来的情况下，七牛就已经选择将Go作为存储服务端的主题语言。关于这点，七牛CEO许式伟谈到：编程哲学的重塑是 Go 语言独树一帜的根本原因，其它语言仍难以摆脱 OOP 或函数式编程的烙印，只有 Go 完全放弃了这些，对编程范式重新思考，对热门的面向对象编程提供极度简约但却完备的支持。Go 是互联网时代的C语言，不仅会制霸云计算，10 年内将会制霸整个 IT 领域。
2 在中国程序员眼中，谷歌出品必属精品 确实，在互联网世界，在开源世界，Google为我们贡献了太多太多。</description>
    </item>
    
    <item>
      <title>理解Go语言的nil</title>
      <link>https://yushuangqi.com/blog/2017/li-jie-goyu-yan-de-nil.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:22 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/li-jie-goyu-yan-de-nil.html</guid>
      <description>最近在油管上面看了一个视频：Understanding nil，挺有意思，这篇文章就对视频做一个归纳总结，代码示例都是来自于视频。
nil是什么 相信写过Golang的程序员对下面一段代码是非常非常熟悉的了：
if err != nil { // do something.... }  当出现不等于nil的时候，说明出现某些错误了，需要我们对这个错误进行一些处理，而如果等于nil说明运行正常。那什么是nil呢？查一下词典可以知道，nil的意思是无，或者是零值。零值，zero value，是不是有点熟悉？在Go语言中，如果你声明了一个变量但是没有对它进行赋值操作，那么这个变量就会有一个类型的默认零值。这是每种类型对应的零值：
bool -&amp;gt; false numbers -&amp;gt; 0 string -&amp;gt; &amp;quot;&amp;quot; pointers -&amp;gt; nil slices -&amp;gt; nil maps -&amp;gt; nil channels -&amp;gt; nil functions -&amp;gt; nil interfaces -&amp;gt; nil  举个例子，当你定义了一个struct：
type Person struct { AgeYears int Name string Friends []Person } var p Person // Person{0, &amp;quot;&amp;quot;, nil}  变量p只声明但没有赋值，所以p的所有字段都有对应的零值。那么，这个nil到底是什么呢？Go的文档中说到，*nil是预定义的标识符，代表指针、通道、函数、接口、映射或切片的零值*，也就是预定义好的一个变量：
type Type int var nil Type  是不是有点惊讶？nil并不是Go的关键字之一，你甚至可以自己去改变nil的值：</description>
    </item>
    
    <item>
      <title>谢孟军:THESTATEOFGO</title>
      <link>https://yushuangqi.com/blog/2017/xie-meng-jun-the-state-of-go.html</link>
      <pubDate>Fri, 03 Mar 2017 08:36:22 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xie-meng-jun-the-state-of-go.html</guid>
      <description>本月 17 日，Go 1.8 版本火热发布。相较于以往的版本，Go 1.8 具体有哪些新的特性呢？想必这是不少 Gopher 们热切关注和讨论的问题。作为著名的Golang 布道者，Gopher China 社区创始人，谢孟军早在今年一月的 ECUG Con 上就对 Golang 做出了历史版本的回顾和 1.8 版本的分析，本文就是对他的演讲实录。 Gopher China 社区创始人，著名开源框架 beego 开发者，畅销图书《Go Web 编程》作者，同时有 bat、bee 等开源软件。国内 Go 发展的主要推动者之一。
谢孟军：大家好，我是来自 Apple 的工程师，目前主要在从事工业自动化系统的架构和研发，今天很高兴来到这里跟大家分享一下关于 Go 的一些东西。Go 是 Google 的语言，Go 语言已经出来 6 年了，从 1.0 版本到 1.8 版本，今天最主要是跟大家分享一下 Go 在 1.8 版本中带来了哪些新特性。
Go 回顾 2012 年 3 月 Go 1.0 版本发布，这是一个标志性的事件。很多语言发布出来之后再次升级都会有或多或少不兼容的体验，但是 Go 官方团队在发布 1.0 的时候发布申明，后续的版本保证百分之百向前兼容，他们也遵守了当时的承诺。1.0、1.1、1.2、1.3 一直到 1.7，你的代码如果是 1.0 时候写的，现在升级到 1.7，都可以正常编译。其他语言里面我们可能都会有这样的体验，升级了一个新版本之后，需要花很多时间把代码兼容到新升级的版本中。所以对于一个语言来说，特性稳定是非常重要的。 Go 语言基本上保持了半年发布一个版本的节奏： * 2013年的 5 月份发了 1.</description>
    </item>
    
    <item>
      <title>编写地道的Go代码</title>
      <link>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:58 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/bian-xie-de-dao-de-godai-ma.html</guid>
      <description>在阅读本文之前，我先推荐你阅读官方的 Effective Go文档，或者是中文翻译版: 高效Go编程，它提供了很多编写标准而高效的Go代码指导，本文不会再重复介绍这些内容。
最地道的Go代码就是Go的标准库的代码，你有空的时候可以多看看Google的工程师是如何实现的。
本文仅作为一个参考，如果你有好的建议和意见，欢迎添加评论。
注释 可以通过 /* …… */ 或者 // ……增加注释， //之后应该加一个空格。
如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。
 // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. /*Package net provides a portable interface for network I/O, includingTCP/IP, UDP, domain name resolution, and Unix domain sockets....... */ package net......  注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在godoc中容易查找。</description>
    </item>
    
    <item>
      <title>Gonet_http包</title>
      <link>https://yushuangqi.com/blog/2017/go-net_httpbao.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:57 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-net_httpbao.html</guid>
      <description>Go net/http包
Go Http客户端 get请求可以直接http.Get方法
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;log&amp;quot; &amp;quot;reflect&amp;quot; &amp;quot;bytes&amp;quot; ) func main() { resp, err := http.Get(&amp;quot;http://www.baidu.com&amp;quot;) if err != nil { // handle error log.Println(err) return } defer resp.Body.Close() headers := resp.Header for k, v := range headers { fmt.Printf(&amp;quot;k=%v, v=%v\n&amp;quot;, k, v) } fmt.Printf(&amp;quot;resp status %s,statusCode %d\n&amp;quot;, resp.Status, resp.StatusCode) fmt.Printf(&amp;quot;resp Proto %s\n&amp;quot;, resp.Proto) fmt.Printf(&amp;quot;resp content length %d\n&amp;quot;, resp.ContentLength) fmt.Printf(&amp;quot;resp transfer encoding %v\n&amp;quot;, resp.</description>
    </item>
    
    <item>
      <title>Golang学习摘录一:初识</title>
      <link>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</link>
      <pubDate>Fri, 24 Feb 2017 08:31:56 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-yi-chu-shi.html</guid>
      <description>1、Hello Word编写方式 package main import &amp;quot;fmt&amp;quot; func main (){ fmt.Printf(&amp;quot;Hello, world&amp;quot;) }  编译 go build helloworld.go
运行 ./helloworld
2、声明方式 1、普通方式 var a int = 15 var b bool = false 或 var a int var b bool a = 15 b = false 2、 :=会自动匹配类型，只能在函数内使用 a := 15 b := false 3、中括号的形式： var ( x int b bool ) 4、平行赋值 a,b := 20,16 #注意 :Go 的编译器对声明却未使用的变量在报错。 5、常量，只能是数字、字符串或布尔值 const( // 枚举的生成方式 a = iota // a为0 b = iota // b为1，改行的 “=iota”可省略 ) 如果需要,可以明确指定常量的类型: const ( a = 0 b string = &amp;quot;0&amp;quot; )  3、字符串 var s string = &amp;quot;hello&amp;quot; #Go中字符串是不可变的  如果想修改字符需要使用下面的方法</description>
    </item>
    
  </channel>
</rss>