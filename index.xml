<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>极客虞双齐</title>
    <link>https://yushuangqi.com/index.xml</link>
    <description>在 极客虞双齐上关于的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <lastBuildDate>Sun, 02 Jul 2017 21:01:02 +0800</lastBuildDate>
    <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>简述电子邮件发展历史</title>
      <link>https://yushuangqi.com/blog/2017/jian-shu-dian-zi-you-jian-fa-zhan-li-shi.html</link>
      <pubDate>Sun, 02 Jul 2017 21:01:02 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jian-shu-dian-zi-you-jian-fa-zhan-li-shi.html</guid>
      <description>平均每天发送10封邮件，日常工作中邮件是重要的沟通方式。虽然现在也有QQ消息，微信等其他即使通讯工具，但思想都源于电子邮件。
是否有兴趣了解电子邮件的发展历史？这里虞双齐多方收集资料，整理成文，以简述电子邮件发展历史。
电子邮件的启蒙期 70年代计算机已被各研究机构使用，美国军方机构为最。当时美国军方分支机构ARPA「高等研究计划署 （Advanced Research Projects Agency）」为美国军事机构之间的信息交流做防护而设计为异地间的计算机之间进行信息交换的网络ARPANET（阿帕网），此网乃当今互联网的鼻祖。
而当时工作者（科学家）只能通过哑终端(Dumb Terminal)，经串型接口连接到大型计算机工作。哑终端没有内存和硬盘，输入字符指令到主机才能执行计算。
可是，连接到同一个大型计算机的哑终端，是在不同时区的工作者手中。打电话有时候很难联系到人。在1965年麻省理工学院开发了世界第一个用于在同一主机上发消息的程序MailBox。
初期的邮件实际上就是一个有特殊保护的文件夹。其他人可以往文件夹里面存放消息文件，当别人登陆到主机时可看到消息。类似于一个桌面记事本。
电子邮件的诞生 在1967年，一位谦虚的计算机工程师Ray Tomlinson获得麻省理工学院计算机工程博士学位后，到BBN「博尔特·贝拉尼克—纽曼(Bolt Beranek and Newman)」公司从事计算机研究工作。刚好该公司受聘于美国国防部，参与阿帕网（Arpanet）的建设和维护工作。他在这里留下了他在计算机行业的辉煌。
尽管MaiBox能发消息，但仅仅局限在同一计算机下。那么如何才能让不同计算机间能发送消息呢？
1971年的一天，Tomlinson完成了世界上第一封真正名义上的电子邮件发送。他在PDP-10机器上运行的TENEX操作系统上写了一个邮件程序名为SENDMSG，并起草一个简单的文件传输协议CPYNET，来使得SENDMSG程序能将消息从一台计算机发送到另外一台计算机。
他在BBN剑桥办事处并排的两台PDP-10计算机上测试，此两台计算机间仅有的物理连接是都接入到ARPANET。他从一台计算机往另一台计算机发送测试消息给自己。因为测试内容太多，他也不记得第一条测试消息是什么内容。他回忆也许是QWERTYUIOP或类似的消息。
测试成功后，他非常满意，于是给他们组的其他人员发消息告诉他们是如何实现在两台计算机间发生消息的。 尽管第一封电子邮件的内容连Tomlinson本人也记不起来了，但那一刻仍然具备了十足的历史意义：电子邮件诞生了。
在1972年初，TENEX的下一个版本发布，便包括具有网络邮件功能的SNDMSG版本。 CPYNET协议很快就被具有特定邮件处理功能的真正的文件传输协议所取代。
电子邮件中&amp;rsquo;@&amp;lsquo;标识符的来由 Ray Tomlinson因SENDMSG和CPYNET而出名。
在1972年末，他为了实现两台计算机间发消息，将CPYNET的代码并入到了SENDMGS中，以提供区分本地邮件和网络邮件的方式。 应该如何表示呢？如何找一个字符进行区分呢，还不会出现在人名中。他低头盯着电传打印机(Model 33 Teletype)键盘，随后选择了@来进行区分。他表示&amp;rdquo;@&amp;ldquo;不会出现在人名中，也有at(在)的意思。表示某人在其他计算机上，user-name@the-computer-name。当时的他压根就没意识到，他创造了世界无人不晓的&amp;rdquo;@&amp;ldquo;。
后因Tomlinson发明电子邮件 ，他因此入选由被互联网协会（ISOC）评选的首届互联网名人堂，美国《福布斯》杂志曾对汤姆林森评价说：“对他个人来说，‘@’只不过是一件小发明，但对整个世界来讲，则无疑是一件伟大的发明。”
不幸的是，这位电子邮件之父Ray Tomlinson 于2016年3月5日逝世，年享74岁。
电子邮件的成长期 这个“@”被ARPANET的工作人员所接受，开始推广使用电子邮件。在1974年，ARPNET下有一百多人使用电子邮件，电子邮件成为ARPANET的首选沟通方式。
有趣的是，另一个计算机工程师 Larry Roberts 给邮件服务器添加了文件夹功能。初衷是为了方便他老板给电子邮件分类以方便查找邮件。
到1976年，电子邮件开始流行，商业工具也开始涌现。而APRNET计算机间75%的流量都是电子邮件内容。紧随而来的是广告邮件，世界第一封电子邮件广告出现在美国政府和大学的网络上。
1981年 IBM推出IBM5150新款计算机，个人电脑随之诞生。跟随个人电脑的普及，高傲的网络连接费是笔不小的负担，一分钟的电话费需要很多钱。这也促使了电子邮件的一个小进步。名为&amp;rdquo;offline readers&amp;rdquo;软件应世而出，它允许电子邮件用户将邮件存储到个人电脑上。可以随时阅读邮件和回复邮件，在发送邮件时才需要联网。能够离线邮件再联线发送电子邮件是十分节约连接费。
1982年，简单邮件传输协议SMTP(Simple Mail Transfer Protocol)被定制，用于使用统一标准接发电子邮件。 同年电子邮件的世界里也出现了著名的表情符笑脸-:)。
1888年,Steve Dorner开发世界上第一个图形操作界面的电子邮件客户端程序，名为Eudora 1989年，配音员在美国在线录制了为电子邮件录制了“欢迎”、“已完成”、“再见”、“您有新邮件” 等声音。
电子邮件的高速发展期 90年代， 万维网发展，雅虎和Hotmail推出免费WEB版电子邮箱。每个人员极易获得电子邮箱账号，全球几亿人使用电子邮件。 + 1997年，微软花4亿收购Hotmail ，同年推出Outlook。
 1998年，垃圾邮件(spam)一词入选牛津字典。 2004年，“LOL“(互联网缩略语，意为哈哈)和其他缩略语被写入牛津辞典。 2004年，世界多媒体信息服务大会，在维也纳召开。他讲多媒体技术引入到电子邮件使用当中。 2007年，谷歌开放Gmail电子邮件系统 2011年，《美联社写作风格指南》一书中开始讲“e-mail”简写为“email” 2003年，超77亿人使用电子邮件。</description>
    </item>
    
    <item>
      <title>给电脑小白精挑细选的五个免费软件</title>
      <link>https://yushuangqi.com/blog/2017/gei-dian-nao-xiao-bai-jing-tiao-xi-xuan-de-wu-ge-mian-fei-ruan-jian.html</link>
      <pubDate>Wed, 28 Jun 2017 21:01:02 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/gei-dian-nao-xiao-bai-jing-tiao-xi-xuan-de-wu-ge-mian-fei-ruan-jian.html</guid>
      <description>不是每一个人都精通电脑，不是每一个都在为提供办公效率而绞尽脑汁。通过软件助你提供效率，每次操作节约3秒钟，一年可为你节约多少个3秒钟？
下面虞双齐结合日常工作，为大家从13个软件中挑选出5个免费软件，以提升效率。挑选原则： + 免费
+ 提升效率
+ 性能稳定 + 本人亲自使用超过2年
请公账号中回复：工具 两字获取此5个免费软件的下载地址清单。
5个可以提升办公效率的免费软件 1.文件搜索工具：Everything 找不到文件存在哪里？文件藏的太深，需点击N次鼠标才能看到？那就使用Everything来解决痛点，配合快捷键启动。找文档，打开文档超快！
Everything是Windows桌面搜索引擎，实时搜索几乎瞬间完成、占用资源极低 。这些特性在如今磁盘容量越来越大、用户文件越来越多的情况下使得Everything超越了传统桌面搜索工具而广受欢迎，它能在几秒钟内从数百GB的硬盘中精确搜索到需要的内容，支持高级搜索、正则表达式、网络搜索、离线搜索等等。 2. 文件压缩解压工具： 7-zip 还在用破解版的WinRar? 赶快换成高速的7-zip。
7z 是一种全新的压缩格式，它拥有极高的压缩比。通常使用 7-Zip 的 7z 格式能比使用 zip 格式的压缩档案小 30-70%。并且使用 7-Zip 创建的 zip 格式比大多数其它压缩软件创建的都小 2-10%。 3. 文本编辑工具：Notepad++ window中的记事本有一个天生的设计缺陷，有些软件无法读取被你通过记事本修改过的文件。
杜绝窘迫，请使用Notepad++替代记事本。Notepad++是多次获得SourceForge社区最佳开发工具奖，开源软件，知名度极高，来自宝岛台湾。 !(Notepad++)(https://static.yushuangqi.com/blog/2017/28955498546793.png)
4. 远程工具：TeamViewer 想在家远程操控办公室电脑？想iPad远程操控电脑？想IT远程技术支持？
也许你有使过QQ的远程功能，但TeamViewer才是专业的TeamViewer是专业、功能强大，使用简单，对个人用户免费的一个多功能软件，核心功能是执行远程操控和传送文件。可以不注册，但是注册成个人账户后，可方便免密远程操控。 5. 电子书阅读器： Sumatra PDF 想阅读pdf、eBook(ePub,Mobi)、CHM帮助文档 ？
Sumatra 是一款开源免费的 电子书阅读器, 小巧、迅速是其最大的特点。
Sumatra PDF 是你的首选，因为日常以阅读pdf为主，快速的打开和阅读pdf才是办公刚需。即使你在使用福昕阅读器，也赶快再安装Sumatra。深有体会的是福昕从一个简单好用的优秀国产软件变成了一个臃肿的软件。 结束语 给电脑小白的你，精挑细选五个可以提升效率的免费软件。提供办公效率从用好的软件开始，一步实际行动比一打纲领更重要。赶紧在公众号下直接回复“工具”两字，获取下载地址吧！
分享是一种生活的信念，明白了分享的同时，明白了存在的意义。如果本文有给你带来价值，请分享给你的朋友吧！</description>
    </item>
    
    <item>
      <title>终于找到我要的读书方法了</title>
      <link>https://yushuangqi.com/blog/2017/find-the-best-way-to-read-book-for-me.html</link>
      <pubDate>Sun, 25 Jun 2017 20:12:27 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/find-the-best-way-to-read-book-for-me.html</guid>
      <description>自认爱好读书，纸质书，电子书堆积成山。但一直困扰我的是：未能高效Get到知识。
曾遭遇的困惑  买过很多不需要的书，在角落里干灰。 我好像读过这本书。 一口气读完一本书，就没有然后了。  现在买书很克制，不读完并吸收掌握就不继续买。先放到购物车或购书清单中，反正电商的图书活动不断，不怕下次没法优惠购。
如果你有同感请继续看，否则请打道回府，欢迎下次光临🙈。
新招式破解困局 我在《如何有效阅读一本书》中找到了良药：用笔记本管理读书生活 &amp;gt; 一次偶然的机会，在西西弗购物公园店看书时，拿到本日本作家奥野宣之著的《如何有效阅读一本书》。当时看得入迷，时间紧迫。当晚京东下单，接着感受其中的方法论。 &amp;gt; 豆瓣书评传送门：http://t.cn/RJLVnDL 此法乃大简之道，力荐给爱好读书的你。 原始，简单，有效！前后细读两次，越发认为通过笔记管理读书生活有趣而实用。
笔记本 高中时一开学，得买好几个高大上的笔记本。每门各一本，然后在封面写上XX课笔记本虞双齐。好傻包的行为😂。搞得最后是，一上课就找笔记本，期末还每个笔记本一大半纸是空白的&amp;hellip;.
直到现在，也经常给各中东西细分类，没过多久就一团乱有得收拾。其实将东西放在一个筐下也是非常不错的，实际中大部分东西都是大半年用不上。与其分类细放，还不如一个纸箱子全部堆放。自然而然，经常用的东西在最上面。
东西细分类，是在添加心智负担 关于生活、工作、随想、心情都可以通通按时间顺序写到一个普通笔记本上。
字迹潦草无所谓，只要自己能看懂就好，别人才没时间看~~~
用一个普通的笔记本开始我崭新的学习之旅，之前用用过MyBase，Evernote、有道云笔记、为知笔记。在电脑上始终没法体验原始笔记本书写。更何况，我🐢般的打字速度，要命勒，要命勒！！ 所以现在回归到原始，结合为知笔记软件，重新管理我的知识。
功夫不负有心人 耳濡墨染的一个真理，假设一篇文章抄在笔记本上需要花三十分钟时间。而用智能手机拍成照片或扫描成纯文字文档却只要一分钟，想抄写的文字就能永久地保存下来。
那么，只要使用智能手机，读书效率就能提高三十倍吗？ 我想不是的。
即使你使用手机拍照，花三十分钟保存了三十本书的信息，也不如花三十分钟抄写一本书的内容有效。无论在手机里面保存了多少本书，书里面的内容都不会被保存在脑子里。这些内容既不能融入你的身心，也不能变成你无形的财富，与此相反，尽管抄完本也不一定能记住全部内容，但某段文章、某个词、作者的语气和思想等等，都会随着抄写时的身体感觉被深深地刻印在头脑和身体里。
就笔记本抄写文章内容，写感悟，记心情等都是简单有效快捷的方法。当做练字也好，请拾起笔，随便找一个干净的笔记本开始写笔记！ 结尾 一脑的想法，可提笔记录时，却难以下笔。需整理思路，如同和别人对话，得组织语言逻辑。才能让其听明白你所表达的意思。纵有千万灵感，只有用文字记录，让思想书面化，让灵感脱离之前的抽象状态，会更容易将其理解消化，也能促使你把灵感用作创意材料，想用的时候就能信手拈来。
我喜欢将知识，思想形成文字分享给他人。特别是工作内容，只有书面化，才能让自己理清思路完善知识，传播价值。
用笔记管理读书生活是值得一试的读书方法，我已服此良药，你会行动嘛？三个月后呢？</description>
    </item>
    
    <item>
      <title>gRPC服务发现&amp;amp;负载均衡</title>
      <link>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:36 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</guid>
      <description>gRPC服务发现&amp;amp;负载均衡  构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：
 1、集中式LB（Proxy Model） 在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：
 单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；
 服务消费方、提供方之间增加了一级，有一定性能开销。
  2、进程内LB（Balancing-aware Client） 针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：
 开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；
 另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。
  3、独立 LB 进程（External Load Balancing Service） 该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。
不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。 该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。
gRPC服务发现及负载均衡实现 gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。
其基本实现原理：
 服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。
 客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。
 负载均衡策略为每个服务器地址创建一个子通道（channel）。
 当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。
  根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：
1）命名解析实现：resolver.go
package etcdv3 import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; etcd3 &amp;quot;github.com/coreos/etcd/clientv3&amp;quot; &amp;quot;google.golang.org/grpc/naming&amp;quot; ) // resolver is the implementaion of grpc.naming.Resolver type resolver struct { serviceName string // service name to resolve } // NewResolver return resolver with service name func NewResolver(serviceName string) *resolver { return &amp;amp;resolver{serviceName: serviceName} } // Resolve to resolve the service from etcd, target is the dial address of etcd // target example: &amp;quot;http://127.</description>
    </item>
    
    <item>
      <title>Caddy新兴的web服务器caddy</title>
      <link>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</guid>
      <description>caddy 是一个像 Apache, nginx, 或 lighttpd 的web服务器。
你要问nginx已经很好了，为什么要用caddy呢? 我觉得caddy最大的特点是用起来简单，
然后呢，它还有下面这些开箱即用的特性:
 HTTP/2 全自动支持HTTP/2协议，无需任何配置。
 Auto HTTPS Caddy 使用 Let&amp;rsquo;s Encrypt 让你的站点全自动变成全站HTTPS，无需任何配置。当然你想使用自己的证书也是可以的。
 Multi-core 因为caddy是golang写的，所以当然可以合理使用多核啦。
 IPv6 完全支持IPv6环境.
 WebSockets Caddy 对WebSockets有很好的支持.
 Markdown 自动把md转成 HTML ，当然，我后续要给大家介绍更强大的hugo来干这个事情.
 Logging Caddy 对log格式的定义很容易，更好的满足你日志收集的需求。
 Easy Deployment 得益于go的特性，caddy只是一个小小的二进制文件，没有依赖，很好部署。
  那么在什么场景下适合尝试使用caddy呢，我推荐从以下场景开始：
 作为静态页面的webserver
 转发 fastcgi 请求到 php-fpm 服务，比如替换apache或nginx作为wordpress的server
 反向代理，管理多个站点
 微服务的 API gateway ，我会专门写一篇文章。
 有些在nginx上难以开发的需求，为caddy写插件太方便了。
  入门 安装caddy  下载 caddy</description>
    </item>
    
    <item>
      <title>redigo连接池代码分析</title>
      <link>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</guid>
      <description>结构体分析 type Pool struct { // 用来创建redis连接的方法 Dial func() (Conn, error) // 如果设置了给func,那么每次p.Get()的时候都会调用改方法来验证连接的可用性 TestOnBorrow func(c Conn, t time.Time) error // 定义连接池中最大连接数（超过这个数会关闭老的链接，总会保持这个数） MaxIdle int // 当前连接池中可用的链接数. MaxActive int // 定义链接的超时时间，每次p.Get()的时候会检测这个连接是否超时（超时会关闭，并释放可用连接数）. IdleTimeout time.Duration // 当可用连接数为0是，那么当wait=true,那么当调用p.Get()时，会阻塞等待，否则，返回nil. Wait bool // 读写锁控制. mu sync.Mutex // 用来条件控制，这里主要是当链接被关闭时，提醒在等待的进程可以使用了，或者可以自行创建了 cond *sync.Cond // 当前连接池是否已经关闭 closed bool // 当前可用的链接数 active int // 链接存储在一个栈中. idle list.List }  连接池关闭方法 func (p *Pool) Close() error { p.mu.Lock() // 获取连接池所有链接栈 idle := p.</description>
    </item>
    
    <item>
      <title>ngrok从服务端跟踪所有HTTP请求并回放</title>
      <link>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</link>
      <pubDate>Wed, 24 May 2017 09:17:34 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</guid>
      <description>客户端工程师：“xxx 接口坏了，我的程序都没动过”，后端经常会收到这样的质问，但是我们现在如何重现这个问题？有以下几种情况：
一、后端测试了一下发现没有问题
“我这里测试了是好的啊”，就只能让客户端工程师再操作一遍，亲眼看到错误之后就肯定是有问题了，就得去找问题，这时候这台手机，以及这台手机里面的数据都非常重要，因为这些数据可以让 Bug 重现。
二、测试了也有问题
这时候后端就去修改程序了，但是每一次的测试是否有问题都需要在客户端中操作，有时候的操作非常的复杂，在这上面花的时间会比较多。最后使了各种神通才终于找到问题，原来是这个用户的某某数据有异常才会出现这种情况。
以上这种情况屡见不鲜，最麻烦的点就在于，每次都要以出现 Bug 的相同参数去请求，有时候你知道这些请求的参数，可以把它们放到 Postman 这种工具里面，但大部分时候你并不知道它对应的参数 (token)
如果我们可以在服务端跟踪所有的请求：接口地址，Header，Body，后端返回的 Header、Body，这样我们就能查到对应的请求参数和返回值，可以直接填到 Postman 里面，要是还能一键重新请求就好了，因为我们不想修改请求的参数，只是想再以相同的参数请求一遍，这样我们来调试对应的程序。
正好以前用过 ngrok，发现它有一个非常好的 debug 界面，可以达到以上的要求，但现在不需要它的内网穿透功能，于是只能自己写一个程序，只包含以下功能：
 记录接口所有的 Request 和 Response
 可以一键重新请求某个 Request
  基本工作原理
HTTP 客户端 Boast Web 服务器 | GET http://localhost:8080/ | 记录请求并进行反向代理 | Response 200 OK | ---------------------------&amp;gt; | --------------------------&amp;gt; | ------┐ | | | | | | 记录返回信息并转发给客户端 | &amp;lt;----┘ | &amp;lt;--------------------------- | &amp;lt;-------------------------- | ┌----------------------------------------------------------------------------┐ | url: http://localhost:8081 | | ---------------------------------------------------------------------------| | All Transactions ┌ - - - - - - - - - - - - - - - - - - - - - - - ┐ | | ---------------------- | time: 10 hours ago Client: 127.</description>
    </item>
    
    <item>
      <title>协作式go程</title>
      <link>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:33 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</guid>
      <description>协作式go程 为什么要协作式go程 考虑如下开发框架，一组网络接收goroutine接收网络包，解包，然后将逻辑包推送到消息队列，由一个单一的逻辑处理goroutine负责从队列中提取逻辑包并处理(这样主处理逻辑中基本上不用考虑多线程竞争的锁问题了)。
如果逻辑包的处理涉及到调用可能会阻塞的函数调用怎么办，如果在处理函数中直接调用这样的函数将导致逻辑处理goroutine被阻塞，无法继续处理队列中被排队的数据包，这将严重降低服务的处理能力。
一种方式是启动一个新的go程去执行阻塞调用，并注册回调函数，当阻塞调用返回后将回调闭包重新push到消息对列中，由逻辑处理goroutine继续处理后续逻辑。但我本人不大喜欢在逻辑处理上使用回调的方式(node的callback hell)。我希望可以线性的编写逻辑代码。
为了实现这个目的，我需要一个类似lua的单线程协作式coroutine调度机制，单线程让使用者不用担心数据竞争,协作式可以让coroutine在执行异步调用前将执行权交出去，等异步结果返回后再将执行权切换回来，线性的执行后续代码。
但是，goroutine天生就是多线程调度执行的，有办法实现这个目标吗？答案是肯定的。
我们可以实现一个逻辑上的单线程，从全局上看，只有唯一一个goroutine可以执行逻辑处理代码。核心思想就是由调度器从任务队列中提取任务，挑选一个空闲的goroutine,将其唤醒并让自己阻塞，当goroutine需要阻塞时就唤醒调度器并将自己阻塞。这样全局上就只有唯一的goroutine在执行逻辑代码。
下面是一个使用示例：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; &amp;quot;coop-go&amp;quot; ) func main() { count := int32(0) var p *coop.CoopScheduler p = coop.NewCoopScheduler(func (e interface{}){ count++ if count &amp;gt;= 30000000 { p.Close() return } //调用阻塞函数 p.Call(func () { time.Sleep(time.Millisecond * time.Duration(10)) }) //继续投递任务 p.PostEvent(1) }) for i := 0; i &amp;lt; 10000; i++ { //投递任务 p.PostEvent(1) } p.Start() fmt.Printf(&amp;quot;scheduler stop,total taskCount:%d\n&amp;quot;,c2) }  首先用一个任务处理函数作为参数创建调度器。然后向调度器投递任务触发处理循环，最后启动处理。</description>
    </item>
    
    <item>
      <title>Golang里的Future_Promise</title>
      <link>https://yushuangqi.com/blog/2017/golangli-de-future_promise.html</link>
      <pubDate>Wed, 24 May 2017 09:17:32 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangli-de-future_promise.html</guid>
      <description>现如今，应用执行时最普遍存在的瓶颈就是网络请求了。网络请求只要几毫秒，但是等到返回却要百倍的时间。所以，如果你执行多个网络请求，让他们都并行执行就是减少延迟最好的选择了。Future/Promise就是实现这一目的的手段之一。
一个Future就是说“将来”你需要某些东西（一般就是一个网络请求的结果），但是你现在就要发起这样的请求，并且这个请求会异步执行。或者换一个说法，你需要在后台执行一个异步请求。
Future/Promise模式在多种语言都有对应的实现。比如ES2015就有Promise和async-await，Scala内置了Future，最后在Golang里有goroutine和channel可以实现类似的功能。下面给出一个简单的实现。
//RequestFuture, http request promise. func RequestFuture(url string) &amp;lt;-chan []byte { c := make(chan []byte, 1) go func() { var body []byte defer func() { c &amp;lt;- body }() res, err := http.Get(url) if err != nil { return } defer res.Body.Close() body, _ = ioutil.ReadAll(res.Body) }() return c } func main() { future := RequestFuture(&amp;quot;https://api.github.com/users/octocat/orgs&amp;quot;) body := &amp;lt;-future log.Printf(&amp;quot;reponse length: %d&amp;quot;, len(body)) }  RequestFuture方法理科返回一个channel，这个时候http请求还在一个goroutine后台异步运行。main方法可以继续执行其他的代码，比如触发其他的Future等。当需要结果的时候，我们需要从channel里读取结果。如果http请求还没有返回的话就会阻塞当前的goroutine，知道结果返回。
然而，以上的方法还有一点局限。错误无法返回。在上面的例子里，如果http请求出现错误的话，body的值会是nil/empty。但是，由于channel只能返回一个值，你需要创建一个单独的struct来包装两个返回的结果。
修改以后的结果：</description>
    </item>
    
    <item>
      <title>对echo框架进行统一的自定义错误处理</title>
      <link>https://yushuangqi.com/blog/2017/dui--echo-kuang-jia-jin-hang-tong-yi-de-zi-ding-yi-cuo-wu-chu-li.html</link>
      <pubDate>Wed, 24 May 2017 09:17:32 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/dui--echo-kuang-jia-jin-hang-tong-yi-de-zi-ding-yi-cuo-wu-chu-li.html</guid>
      <description>借助移动端的增长，如今 RESTful 风格的 API 已经十分流行，
用各种语言去写后端 API 都有很成熟方便的方案，用 golang 写后端 API 更是生产力的代表，
你可以用不输 python/ruby 这类动态语言的速度，写出性能高出一两个数量级的后端 API 。
ECHO 框架 由于 golang 的标准库在网络方面已经很完善，导致框架发挥余地不大。很多高手都说，
用什么框架，用标准库就写好了，框架只是语法糖而已，还会限制项目的发展。 不过我们并不是高手，语法糖也是糖，用一个趁手的框架还是能提高不少效率的。 要是在半年前，你让我推荐框架，我会说有很多，都各有优缺点，除了 beego 随便选一个就可以。
但是来到2017年，一个叫 Echo 的框架脱颖而出。这是我目前最推荐的框架。 Echo 的宣传语用的是 “高性能，易扩展，极简 Go Web 框架” 。它的一些特性如下图所示：
这些特性里，HTTP/2，Auto HTTPS，听着很熟？这是我之前介绍的 Caddy 也有的特性，
因为 golang 实现这些太容易了。还有 Middleware 里的一大堆功能也差不多。
我们在做微服务的时候，这些通用的东西由 API Gateway 统一实现就好了，
如果你写的是个小的独立应用的后端，这些开箱即用的功能倒是能提供很大的帮助。
其实今天我主要想说说最后一个特性里提到的，“中心化的 HTTP 错误处理”。
RESTful API 错误返回 一个团队应当有一份 RESTful API 的规范，而在规范中应该规范响应格式，包括所有错误响应的格式。
比如微软的规范，
jsonapi.org 推荐规范等等。 大部分时候我们不需要实现的那么繁琐，我们规定一个简单的结构：
STATUS 400 Bad Request { &amp;quot;error&amp;quot;: &amp;quot;InvalidID&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;invalid id in your url query parameters&amp;quot; }  传统的错误响应可能只有一个伴随 HTTP Status code 的 string 类型的 message，</description>
    </item>
    
    <item>
      <title>fasthttp中的协程池实现</title>
      <link>https://yushuangqi.com/blog/2017/fasthttpzhong-de-xie-cheng-chi-shi-xian.html</link>
      <pubDate>Wed, 24 May 2017 09:17:31 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/fasthttpzhong-de-xie-cheng-chi-shi-xian.html</guid>
      <description>https://segmentfault.com/a/
fasthttp中的协程池实现  协程池可以控制并行度，复用协程。fasthttp 比 net/http 效率高很多倍的重要原因，就是利用了协程池。实现并不复杂，我们可以参考他的设计，写出高性能的应用。
 入口 // server.go func (s *Server) Serve(ln net.Listener) error { var lastOverflowErrorTime time.Time var lastPerIPErrorTime time.Time var c net.Conn var err error maxWorkersCount := s.getConcurrency() s.concurrencyCh = make(chan struct{}, maxWorkersCount) wp := &amp;amp;workerPool{ WorkerFunc: s.serveConn, MaxWorkersCount: maxWorkersCount, LogAllErrors: s.LogAllErrors, Logger: s.logger(), } // break-00 wp.Start() for { // break-02 if c, err = acceptConn(s, ln, &amp;amp;lastPerIPErrorTime); err != nil { wp.Stop() if err == io.</description>
    </item>
    
    <item>
      <title>golang使用Nsq</title>
      <link>https://yushuangqi.com/blog/2017/golangshi-yong-nsq.html</link>
      <pubDate>Wed, 24 May 2017 09:17:31 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangshi-yong-nsq.html</guid>
      <description>为什么要使用Nsq 最近一直在寻找一个高性能，高可用的消息队列做内部服务之间的通讯。一开始想到用zeromq，但在查找资料的过程中，意外的发现了Nsq这个由golang开发的消息队列，毕竟是golang原汁原味的东西，功能齐全，关键是性能还不错。其中支持动态拓展，消除单点故障等特性， 都可以很好的满足我的需求
下面上一张Nsq与其他mq的对比图，看上去的确强大。下面简单记录一下Nsq的使用方法
图片来自golang2017开发者大会
Nsq服务端 Nsq服务端简介 在使用Nsq服务之前，还是有必要了解一下Nsq的几个核心组件
整个Nsq服务包含三个主要部分
nsqlookupd 先看看官方的原话是怎么说：
nsqlookupd是守护进程负责管理拓扑信息。客户端通过查询 nsqlookupd 来发现指定话题（topic）的生产者，并且 nsqd 节点广播话题（topic）和通道（channel）信息
简单的说nsqlookupd就是中心管理服务，它使用tcp(默认端口4160)管理nsqd服务，使用http(默认端口4161)管理nsqadmin服务。同时为客户端提供查询功能
总的来说，nsqlookupd具有以下功能或特性
 唯一性，在一个Nsq服务中只有一个nsqlookupd服务。当然也可以在集群中部署多个nsqlookupd，但它们之间是没有关联的
 去中心化，即使nsqlookupd崩溃，也会不影响正在运行的nsqd服务
 充当nsqd和naqadmin信息交互的中间件
 提供一个http查询服务，给客户端定时更新nsqd的地址目录   nsqadmin 官方原话：是一套 WEB UI，用来汇集集群的实时统计，并执行不同的管理任务
总的来说，nsqadmin具有以下功能或特性
 提供一个对topic和channel统一管理的操作界面以及各种实时监控数据的展示，界面设计的很简洁，操作也很简单
 展示所有message的数量，恩&amp;hellip;.装X利器
 能够在后台创建topic和channel，这个应该不常用到
 nsqadmin的所有功能都必须依赖于nsqlookupd，nsqadmin只是向nsqlookupd传递用户操作并展示来自nsqlookupd的数据
  nsqadmin默认的访问地址是http://127.0.0.1:4171/ nsqd 官方原话：nsqd 是一个守护进程，负责接收，排队，投递消息给客户端
简单的说，真正干活的就是这个服务，它主要负责message的收发，队列的维护。nsqd会默认监听一个tcp端口(4150)和一个http端口(4151)以及一个可选的https端口
总的来说，nsqd 具有以下功能或特性
 对订阅了同一个topic，同一个channel的消费者使用负载均衡策略（不是轮询）
 只要channel存在，即使没有该channel的消费者，也会将生产者的message缓存到队列中（注意消息的过期处理）
 保证队列中的message至少会被消费一次，即使nsqd退出，也会将队列中的消息暂存磁盘上(结束进程等意外情况除外)
 限定内存占用，能够配置nsqd中每个channel队列在内存中缓存的message数量，一旦超出，message将被缓存到磁盘中
 topic，channel一旦建立，将会一直存在，要及时在管理台或者用代码清除无效的topic和channel，避免资源的浪费
  这是官方的图，第一个channel(meteics)因为有多个消费者，所以触发了负载均衡机制。后面两个channel由于没有消费者，所有的message均会被缓存在相应的队列里，直到消费者出现
这里想到一个问题是，如果一个channel只有生产者不停的在投递message，会不会导致服务器资源被耗尽？也许nsqd内部做了相应处理，但还是要避免这种情况的出现
Nsq服务端与客户端的关系 了解nsqlookupd，nsqd与客户端中消费者和生产者的关系
消费者 消费者有两种方式与nsqd建立连接
 消费者直连nsqd，这是最简单的方式，缺点是nsqd服务无法实现动态伸缩了(当然，自己去实现一个也是可以的)  消费者通过http查询nsqlookupd获取该nsqlookupd上所有nsqd的连接地址，然后再分别和这些nsqd建立连接(官方推荐的做法)，但是客户端会不停的向nsqlookupd查询最新的nsqd地址目录(不喜欢用http轮询这种方式&amp;hellip;)</description>
    </item>
    
    <item>
      <title>golang使用原始套接字构造UDP包</title>
      <link>https://yushuangqi.com/blog/2017/golangshi-yong-yuan-shi-tao-jie-zi-gou-zao-udpbao.html</link>
      <pubDate>Wed, 24 May 2017 09:17:30 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangshi-yong-yuan-shi-tao-jie-zi-gou-zao-udpbao.html</guid>
      <description>https://segmentfault.com/a/
RAW SOCKET 介绍 TCP/IP协议中，最常见的就是原始(SOCKET_RAW)、tcp(SOCKET_STREAM)、udp(SOCKET_DGRA)三种套接字。原始套接字能够对底层传输进行控制，允许自行组装数据包，比如修改本地IP，发送Ping包，进行网络监听。这里不做详细介绍，要了解更多可以网上自己查询。
实现 这里先看IP头结构：
其中16位总长度包括IP头长度和数据的长度，8位协议填写17，因为UDP协议类型为17。这里要说明一下IP头中的首部校验，这个值只校验IP头部，不包含数据。
这里给出校验算法，IP头和UDP头中使用的校验算法是一样的。
func checkSum(msg []byte) uint16 { sum := 0 for n := 1; n &amp;lt; len(msg)-1; n += 2 { sum += int(msg[n])*256 + int(msg[n+1]) } sum = (sum &amp;gt;&amp;gt; 16) + (sum &amp;amp; 0xffff) sum += (sum &amp;gt;&amp;gt; 16) var ans = uint16(^sum) return ans }  下面开始填充IP头，这里使用了golang.org/x/net下的ipv4包
 //目的IP dst := net.IPv4(192, 168, 1, 2) //源IP src := net.IPv4(192, 168, 1, 3) //填充ip首部 iph := &amp;amp;ipv4.</description>
    </item>
    
    <item>
      <title>关于golang在树莓派下获取ip和mac地址</title>
      <link>https://yushuangqi.com/blog/2017/guan-yu-golangzai-shu-mei-pa-xia-huo-qu-iphe-macde-zhi.html</link>
      <pubDate>Wed, 24 May 2017 09:17:30 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/guan-yu-golangzai-shu-mei-pa-xia-huo-qu-iphe-macde-zhi.html</guid>
      <description>https://segmentfault.com/a/
前言 最近工作需要，需求为获取树莓派以太网ip
地址和mac地址，看了下golang的文档，发现net.InterfaceByName可以完成这个目标。
实现  //以太网网卡名称为eth0 inter, err := net.InterfaceByName(&amp;quot;eth0&amp;quot;) if err != nil { log.Fatalln(err) } //mac地址 fmt.Println(inter.HardwareAddr.String()) addrs, err := inter.Addrs() if err != nil { log.Fatalln(err) } //ip地址一个ip4一个ip6 for _, addr := range addrs { fmt.Println(addr.String()) }  运行结果：
后记 当然，树莓派3代自带无线网卡，名字换为wlan0就可以获取无线网卡ip。</description>
    </item>
    
    <item>
      <title>Go语言暴力入门2-工欲善其事</title>
      <link>https://yushuangqi.com/blog/2017/goyu-yan-bao-li-ru-men-2-gong-yu-shan-ji-shi.html</link>
      <pubDate>Wed, 24 May 2017 09:17:29 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/goyu-yan-bao-li-ru-men-2-gong-yu-shan-ji-shi.html</guid>
      <description>工欲善其事-打造漂亮的Go语言编辑器 关于作者  程序开发人员，不拘泥于语言与技术，目前主要从事PHP和前端开发，使用Laravel和VueJs，App端使用Apicloud混合式开发。合适和够用是永不停息的追求。2017.05.04开始在空闲时间学习Go语言
个人网站：http://www.linganmin.cn
最近刚写了一个手机在线播放的H5电影站：http://www.ifilm.ltd
 关于Gogland  Gogland 是JetBrains专门为Go语言开发的商业化IDE的代号，旨在为Go开发提供符合人体工程学的环境。新的IDE通过针对Go语言的编码协助和工具集成扩展了IntelliJ平台的诸多功能
 目前Gogland还在开发中，已经发布了几版预发行版本，因为是预览版本所以，目前Gogland还是免费的哦
为什么是Gogland 因为笔者本身是做PHP开发的，（请抛开语言之争，PHP很优秀，Go语言也是，任何一门语言存在即合理，合理是因为他们都有自己所擅长的领域，哈哈跑题了），在做PHP开发时一直使用的就是JetBrains他们家的PHPStorm，后来写前端，写JS，写Vue的时候又试了他们家的专注前端的IDEWebstorm,也很喜欢。当前，不可否认，sublime和VS code之类是很优秀的编辑器，而且有丰富的第三方扩展，但是在编写稍微复杂的项目的时候可能就不是那么得心应手了，或者也许是笔者自己有对他们有偏见吧，个人喜好勿喷，哈哈。
鉴于此，在看了Go语言的第二天就去JetBrains官网看了看有没有专门为Go语言发布的IDE，刚好看到了还在预览版的Gogland
Gogland继承了JetBrains家族IDE中诸如database管理的众多优秀的功能，下面就开始安装吧
安装Gogland并安装Material风格主题 Gogland的介绍及下载页面：https://www.jetbrains.com/go/&amp;hellip;
笔者使用的是Windows OS下载的是对应的.exe文件，下载完成双击一路安装下去
安装之后打开编辑器你有木有发现，默认的主题其实是不那么好看，笔者深深迷恋material主题风格，在用的所有编辑器都换成了该主题风格，包括Sublime和VS code,所以怎么会放过Gogland
 将默认主题设置为Darcula  点击左上角的File选项，找到Settings点击，然后找到如下图的选项卡，在右边选项框内选择你喜欢的主题，个人推荐Darcula，然后点击ok,这个主题是IDE导航及选项的主题
 安装material主题  依然是点击上面说到的那个Settings选项，然后Plugins选项点击后如下图，然后在右边输入框搜索material,在你没安装过该主题的时候会在中间出现一句提示`点击提示右边的在线搜索，然后弹出搜索结果，找到Material theme UI `install，安装完成重启一下IDE就可以看到漂亮的IDE界面了</description>
    </item>
    
  </channel>
</rss>