<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>老虞学Golang-函数上 |虞双齐Go语言技术独立咨询顾问</title><meta name="description" content="不可或缺的函数，在Go中定义函数的方式如下：
func (p myType ) funcName ("><meta name="keywords" content="Go, 笔记, 教程, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Go语言技术独立咨询顾问"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"><meta property="og:title" content="老虞学Golang-函数上"><meta property="og:type" content="article"><meta property="article:published_time" content="2013-04-07 00:00:00"><meta property="article:modified_time" content="2013-04-07 00:00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="笔记"><meta property="article:tag" content="教程"><meta name="og:description" content="不可或缺的函数，在Go中定义函数的方式如下：
func (p myType ) funcName ("><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html">老虞学Golang-函数上</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://yushuangqi.com"><span itemprop="name">虞双齐</span></a> </span></span><span class="right"><time itemprop="datePublished" datetime="2013-04-07">2013年04月07日</time></span></p></header><div itemprop="articleBody"><p>不可或缺的函数，在Go中定义函数的方式如下：</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span><span style="color:#007020;font-weight:700">func</span> (p myType ) funcName ( a, b <span style="color:#902000">int</span> , c <span style="color:#902000">string</span> ) ( r , s <span style="color:#902000">int</span> ) {
	<span style="color:#007020;font-weight:700">return</span>
}
</pre></div><p>通过函数定义，我们可以看到Go中函数和其他语言中的共性和特性</p><h3 id="共性">共性</h3><ul><li>关键字——func</li><li>方法名——funcName</li><li>入参——— a,b int,b string</li><li>返回值—— r,s int</li><li>函数体—— {}</li></ul><h3 id="特性">特性</h3><p>Go中函数的特性是非常酷的，给我们带来不一样的编程体验。</p><h4 id="为特定类型定义函数-即为类型对象定义方法">为特定类型定义函数，即为类型对象定义方法</h4><p>在Go中通过给函数标明所属类型，来给该类型定义方法，上面的 <code>p myType</code> 即表示给myType声明了一个方法， <code>p myType</code> 不是必须的。如果没有，则纯粹是一个函数，通过包名称访问。packageName.funcationName</p><p>如：</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#60a0b0;font-style:italic">//定义新的类型double，主要目的是给float64类型扩充方法</span>
	<span style="color:#007020;font-weight:700">type</span> double <span style="color:#902000">float64</span>

	<span style="color:#60a0b0;font-style:italic">//判断a是否等于b</span>
	<span style="color:#007020;font-weight:700">func</span> (a double) IsEqual(b double) <span style="color:#902000">bool</span> {
		<span style="color:#007020;font-weight:700">var</span> r = a <span style="color:#666">-</span> b
		<span style="color:#007020;font-weight:700">if</span> r <span style="color:#666">==</span> <span style="color:#40a070">0.0</span> {
			<span style="color:#007020;font-weight:700">return</span> <span style="color:#007020;font-weight:700">true</span>
		} <span style="color:#007020;font-weight:700">else</span> <span style="color:#007020;font-weight:700">if</span> r &lt; <span style="color:#40a070">0.0</span> {
			<span style="color:#007020;font-weight:700">return</span> r &gt; <span style="color:#666">-</span><span style="color:#40a070">0.0001</span>
		}
		<span style="color:#007020;font-weight:700">return</span> r &lt; <span style="color:#40a070">0.0001</span>
	}

	<span style="color:#60a0b0;font-style:italic">//判断a是否等于b</span>
	<span style="color:#007020;font-weight:700">func</span> IsEqual(a, b <span style="color:#902000">float64</span>) <span style="color:#902000">bool</span> {
		<span style="color:#007020;font-weight:700">var</span> r = a <span style="color:#666">-</span> b
		<span style="color:#007020;font-weight:700">if</span> r <span style="color:#666">==</span> <span style="color:#40a070">0.0</span> {
			<span style="color:#007020;font-weight:700">return</span> <span style="color:#007020;font-weight:700">true</span>
		} <span style="color:#007020;font-weight:700">else</span> <span style="color:#007020;font-weight:700">if</span> r &lt; <span style="color:#40a070">0.0</span> {
			<span style="color:#007020;font-weight:700">return</span> r &gt; <span style="color:#666">-</span><span style="color:#40a070">0.0001</span>
		}
		<span style="color:#007020;font-weight:700">return</span> r &lt; <span style="color:#40a070">0.0001</span>
	}

	<span style="color:#007020;font-weight:700">func</span> main() {
		<span style="color:#007020;font-weight:700">var</span> a double = <span style="color:#40a070">1.999999</span>
		<span style="color:#007020;font-weight:700">var</span> b double = <span style="color:#40a070">1.9999998</span>
		fmt.Println(a.IsEqual(b))
		fmt.Println(a.IsEqual(<span style="color:#40a070">3</span>))
		fmt.Println( IsEqual( (<span style="color:#902000">float64</span>)(a), (<span style="color:#902000">float64</span>)(b) ) )

	D}
</pre></div><p>上述示例为 float64 基本类型扩充了方法IsEqual，该方法主要是解决精度问题。 其方法调用方式为： <code>a.IsEqual(double)</code> ，如果不扩充方法，我们只能使用函数<code>IsEqual(a, b float64)</code></p><h4 id="入参中-如果连续的参数类型一致-则可以省略连续多个参数的类型-只保留最后一个类型声明">入参中，如果连续的参数类型一致，则可以省略连续多个参数的类型，只保留最后一个类型声明。</h4><p>如 <code>func IsEqual(a, b float64) bool</code> 这个方法就只保留了一个类型声明,此时入参a和b均是float64数据类型。 这样也是可以的： <code>func IsEqual(a, b float64, accuracy int) bool</code></p><h4 id="变参-入参支持变参-即可接受不确定数量的同一类型的参数">变参：入参支持变参,即可接受不确定数量的同一类型的参数</h4><p>如 <code>func Sum(args ...int)</code> 参数args是的slice，其元素类型为int 。经常使用的fmt.Printf就是一个接受任意个数参数的函数 <code>fmt.Printf(format string, args ...interface{})</code></p><h4 id="支持多返回值">支持多返回值</h4><p>前面我们定义函数时返回值有两个r,s 。这是非常有用的，我在写C#代码时，常常为了从已有函数中获得更多的信息，需要修改函数签名，使用out ,ref 等方式去获得更多返回结果。而现在使用Go时则很简单，直接在返回值后面添加返回参数即可。</p><p>如,在C#中一个字符串转换为int类型时逻辑代码</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#902000">int</span> v=<span style="color:#40a070">0</span>;
	<span style="color:#007020;font-weight:700">if</span> ( <span style="color:#902000">int</span>.TryPase(<span style="color:#4070a0">&quot;123456&quot;</span>,out v) )
	{
		<span style="color:#60a0b0;font-style:italic">//code</span>
	}
</pre></div><p>而在Go中，则可以这样实现,逻辑精简而明确</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#007020;font-weight:700">if</span> v,isOk <span style="color:#666">:=</span><span style="color:#902000">int</span>.TryPase(<span style="color:#4070a0">&quot;123456&quot;</span>) ; isOk {
		<span style="color:#60a0b0;font-style:italic">//code</span>
	}
</pre></div><p>同时在Go中很多函数充分利用了多返回值</p><ul><li>func (file *File) Write(b []byte) (n int, err error)</li><li>func Sincos(x float64) (sin, cos float64)</li></ul><p>那么如果我只需要某一个返回值，而不关心其他返回值的话，我该如何办呢？ 这时可以简单的使用符号下划线”_“ 来忽略不关心的返回值。如：</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	_, cos = math.Sincos(<span style="color:#40a070">3.1415</span>) <span style="color:#60a0b0;font-style:italic">//只需要cos计算的值</span>
</pre></div><h4 id="命名返回值">命名返回值</h4><p>前面我们说了函数可以有多个返回值，这里我还要说的是，在函数定义时可以给所有的返回值分别命名，这样就能在函数中任意位置给不同返回值复制，而不需要在return语句中才指定返回值。同时也能增强可读性，也提高godoc所生成文档的可读性</p><p>如果不支持命名返回值，我可能会是这样做的</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#007020;font-weight:700">func</span> ReadFull(r Reader, buf []<span style="color:#902000">byte</span>) (<span style="color:#902000">int</span>, <span style="color:#902000">error</span>) {
		<span style="color:#007020;font-weight:700">var</span> n <span style="color:#902000">int</span>
		<span style="color:#007020;font-weight:700">var</span> err <span style="color:#902000">error</span>

	    <span style="color:#007020;font-weight:700">for</span> <span style="color:#007020">len</span>(buf) &gt; <span style="color:#40a070">0</span>  {
	        <span style="color:#007020;font-weight:700">var</span> nr <span style="color:#902000">int</span>
	        nr, err = r.Read(buf)
	        n <span style="color:#666">+=</span> nr
			<span style="color:#007020;font-weight:700">if</span> err <span style="color:#666">!=</span><span style="color:#007020;font-weight:700">nil</span> {
				<span style="color:#007020;font-weight:700">return</span> n,err
			}
	        buf = buf[nr:]
	    }
	    <span style="color:#007020;font-weight:700">return</span> n,err
	}
</pre></div><p>但支持给返回值命名后，实际上就是省略了变量的声明，return时无需写成<code>return n,err</code> 而是将直接将值返回</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#007020;font-weight:700">func</span> ReadFull(r Reader, buf []<span style="color:#902000">byte</span>) (n <span style="color:#902000">int</span>, err <span style="color:#902000">error</span>) {
	    <span style="color:#007020;font-weight:700">for</span> <span style="color:#007020">len</span>(buf) &gt; <span style="color:#40a070">0</span> <span style="color:#666">&amp;&amp;</span> err <span style="color:#666">==</span> <span style="color:#007020;font-weight:700">nil</span> {
	        <span style="color:#007020;font-weight:700">var</span> nr <span style="color:#902000">int</span>
	        nr, err = r.Read(buf)
	        n <span style="color:#666">+=</span> nr
	        buf = buf[nr:]
	    }
	    <span style="color:#007020;font-weight:700">return</span>
	}
</pre></div><h4 id="函数也是-值">函数也是“值”</h4><p>和Go中其他东西一样，函数也是值，这样就可以声明一个函数类型的变量，将函数作为参数传递。</p><p>声明函数为值的变量(匿名函数:可赋值个变量，也可直接执行)</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#60a0b0;font-style:italic">//赋值</span>
	fc <span style="color:#666">:=</span> <span style="color:#007020;font-weight:700">func</span>(msg <span style="color:#902000">string</span>) {
		fmt.Println(<span style="color:#4070a0">&quot;you say :&quot;</span>, msg)
	}
	fmt.Printf(<span style="color:#4070a0">&quot;%T \n&quot;</span>, fc)
	fc(<span style="color:#4070a0">&quot;hello,my love&quot;</span>)
	<span style="color:#60a0b0;font-style:italic">//直接执行</span>
	<span style="color:#007020;font-weight:700">func</span>(msg <span style="color:#902000">string</span>) {
		fmt.Println(<span style="color:#4070a0">&quot;say :&quot;</span>, msg)
	}(<span style="color:#4070a0">&quot;I love to code&quot;</span>)
</pre></div><p>输出结果如下，这里表明fc 的类型为：func(string)</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">func</span>(<span style="color:#902000">string</span>)
	you say : hello,my love
	say : I love to code
</pre></div><p>将函数作为入参（回调函数），能带来便利。如日志处理，为了统一处理，将信息均通过指定函数去记录日志，且是否记录日志还有开关</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#007020;font-weight:700">func</span> Log(title <span style="color:#902000">string</span>, getMsg <span style="color:#007020;font-weight:700">func</span>() <span style="color:#902000">string</span>) {
		<span style="color:#60a0b0;font-style:italic">//如果开启日志记录,则记录日志</span>
		<span style="color:#007020;font-weight:700">if</span> <span style="color:#007020;font-weight:700">true</span> {
			fmt.Println(title, <span style="color:#4070a0">&quot;:&quot;</span>, getMsg())
		}
	}
    <span style="color:#60a0b0;font-style:italic">//---------调用--------------</span>
	count <span style="color:#666">:=</span> <span style="color:#40a070">0</span>
	msg <span style="color:#666">:=</span> <span style="color:#007020;font-weight:700">func</span>() <span style="color:#902000">string</span> {
		count<span style="color:#666">++</span>
		<span style="color:#007020;font-weight:700">return</span> <span style="color:#4070a0">&quot;您没有即使提醒我,已触犯法律&quot;</span>
	}
	Log(<span style="color:#4070a0">&quot;error&quot;</span>, msg)
	Log(<span style="color:#4070a0">&quot;warring&quot;</span>, msg)
	Log(<span style="color:#4070a0">&quot;info&quot;</span>, msg)
	fmt.Println(count)
</pre></div><p>这里输出结果如下，count 也发生了变化</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#902000">error</span> : 您没有即使提醒我,已触犯法律
	warring : 您没有即使提醒我,已触犯法律
	info : 您没有即使提醒我,已触犯法律
</pre></div><h4 id="函数也是-类型">函数也是“类型”</h4><p>你有没有注意到上面示例中的 <code>fc := func(msg string)...</code> ，既然匿名函数可以赋值给一个变量，同时我们经常这样给int赋值 <code>value := 2</code> ,是否我们可以声明func(string) 类型 呢，当然是可以的。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#60a0b0;font-style:italic">//一个记录日志的类型：func(string)</span>
	<span style="color:#007020;font-weight:700">type</span> saveLog <span style="color:#007020;font-weight:700">func</span>(msg <span style="color:#902000">string</span>)

	<span style="color:#60a0b0;font-style:italic">//将字符串转换为int64,如果转换失败调用saveLog</span>
	<span style="color:#007020;font-weight:700">func</span> stringToInt(s <span style="color:#902000">string</span>, log saveLog) <span style="color:#902000">int64</span> {

		<span style="color:#007020;font-weight:700">if</span> value, err <span style="color:#666">:=</span> strconv.ParseInt(s, <span style="color:#40a070">0</span>, <span style="color:#40a070">0</span>); err <span style="color:#666">!=</span> <span style="color:#007020;font-weight:700">nil</span> {
			log(err.Error())
			<span style="color:#007020;font-weight:700">return</span> <span style="color:#40a070">0</span>
		} <span style="color:#007020;font-weight:700">else</span> {
			<span style="color:#007020;font-weight:700">return</span> value
		}
	}

	<span style="color:#60a0b0;font-style:italic">//记录日志消息的具体实现</span>
	<span style="color:#007020;font-weight:700">func</span> myLog(msg <span style="color:#902000">string</span>) {
		fmt.Println(<span style="color:#4070a0">&quot;Find Error:&quot;</span>, msg)
	}

	<span style="color:#007020;font-weight:700">func</span> main() {
		stringToInt(<span style="color:#4070a0">&quot;123&quot;</span>, myLog) <span style="color:#60a0b0;font-style:italic">//转换时将调用mylog记录日志</span>
		stringToInt(<span style="color:#4070a0">&quot;s&quot;</span>, myLog)
	}
</pre></div><p>这里我们定义了一个类型，专门用作记录日志的标准接口。在stringToInt函数中如果转换失败则调用我自己定义的接口函数进行日志处理，至于最终执行的哪个函数，则无需关心。</p><h4 id="defer-延迟函数">defer 延迟函数</h4><p>defer 又是一个创新，它的作用是：延迟执行，在声明时不会立即执行，而是在函数return后时按照后进先出的原则依次执行每一个defer。这样带来的好处是，能确保我们定义的函数能百分之百能够被执行到，这样就能做很多我们想做的事，如释放资源，清理数据，记录日志等</p><p>这里我们重点来说明下defer的执行顺序</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	<span style="color:#007020;font-weight:700">func</span> deferFunc() <span style="color:#902000">int</span> {
		index <span style="color:#666">:=</span> <span style="color:#40a070">0</span>

		fc <span style="color:#666">:=</span> <span style="color:#007020;font-weight:700">func</span>() {

			fmt.Println(index, <span style="color:#4070a0">&quot;匿名函数1&quot;</span>)
			index<span style="color:#666">++</span>

			<span style="color:#007020;font-weight:700">defer</span> <span style="color:#007020;font-weight:700">func</span>() {
				fmt.Println(index, <span style="color:#4070a0">&quot;匿名函数1-1&quot;</span>)
				index<span style="color:#666">++</span>
			}()
		}

		<span style="color:#007020;font-weight:700">defer</span> <span style="color:#007020;font-weight:700">func</span>() {
			fmt.Println(index, <span style="color:#4070a0">&quot;匿名函数2&quot;</span>)
			index<span style="color:#666">++</span>
		}()

		<span style="color:#007020;font-weight:700">defer</span> fc()

		<span style="color:#007020;font-weight:700">return</span> <span style="color:#007020;font-weight:700">func</span>() <span style="color:#902000">int</span> {
			fmt.Println(index, <span style="color:#4070a0">&quot;匿名函数3&quot;</span>)
			index<span style="color:#666">++</span>
			<span style="color:#007020;font-weight:700">return</span> index
		}()
	}

	<span style="color:#007020;font-weight:700">func</span> main() {
		deferFunc()
	}
</pre></div><p>这里输出结果如下，</p><pre><code>0 匿名函数3
1 匿名函数1
2 匿名函数1-1
3 匿名函数2
</code></pre><p>有如下结论：</p><ul><li>defer 是在执行完return 后执行</li><li>defer 后进先执行</li></ul><p>另外，我们常使用defer去关闭IO,在正常打开文件后，就立刻声明一个defer，这样就不会忘记关闭文件，也能保证在出现异常等不可预料的情况下也能关闭文件。而不像其他语言：<code>try-catch</code> 或者 <code>using()</code> 方式进行处理。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>	file , err <span style="color:#666">:=</span>os.Open(file)
	<span style="color:#007020;font-weight:700">if</span> err <span style="color:#666">!=</span> <span style="color:#007020;font-weight:700">nil</span> {
		<span style="color:#007020;font-weight:700">return</span> err
	}
	<span style="color:#007020;font-weight:700">defer</span> file.Close()
	<span style="color:#60a0b0;font-style:italic">//dosomething with file</span>
</pre></div><p>后续，我将讨论： 作用域、传值和传指针 以及 保留函数init(),main()</p><p>本笔记中所写代码存储位置：</p><ul><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/defer.go">defer.go</a></li><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/defineFunctionType.go">defineFunctionType.go</a></li><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/function.go">function.go</a></li></ul><p><a href="https://github.com/devYu/GoLangStudy/blob/master/myNotes/controlStructures.md">上篇-控制语句</a></p></div><aside id="meta"><meta itemprop="wordCount" content="571"><meta itemprop="url" content="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/go.html" rel="tag">Go</a> <a href="/tags/%E6%95%99%E7%A8%8B.html" rel="tag">教程</a> <a href="/tags/%E7%AC%94%E8%AE%B0.html" rel="tag">笔记</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2013/ysqi-golang-if-for-select-switch.html">老虞学Golang-控制语句</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2013/ysqi-golang-string.html">老虞学golang-字符串</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="d411a2cacc3e9b482f97ea61f7f17a40" data-title="老虞学Golang-函数上" data-url="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，Go语言技术独立咨询顾问。为国内客户提供Go语言开发、技术实战、架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Go语言技术独立咨询顾问">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2013%2fysqi-golang-function-1.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2013%2fysqi-golang-function-1.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Go语言技术独立咨询顾问。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>