<!DOCTYPE html><html lang="zh" id="doc" class="no-js"><head><title>老虞学Golang-函数上 |虞双齐Go语言开发</title><meta name="description" content=""><meta name="keywords" content="Go, 笔记, 教程, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:type" content="article"><meta property="og:description" content=""><meta property="og:title" content="老虞学Golang-函数上 : https://yushuangqi.com"><meta property="og:site_name" content="虞双齐Go语言开发"><meta property="og:url" content="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"><meta property="og:locale" content="zh"><meta property="article:published_time" content="2013-04-07 00:00:00"><meta property="article:modified_time" content="2013-04-07 00:00:00"><meta property="article:tag" content="Go"><meta property="article:tag" content="笔记"><meta property="article:tag" content="教程"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20160318"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h2 itemprop="headline"><a rel="bookmark">老虞学Golang-函数上</a></h2><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/<a href="https://yushuangqi.com"> <span itemprop="name">虞双齐</span></a> </span></span><span class="right"><time itemprop="datePublished" datetime="2013-04-07">2013年04月07日</time></span></p></header><div itemprop="articleBody"><p>不可或缺的函数，在Go中定义函数的方式如下：</p><pre><code class="language-golang">func (p myType ) funcName ( a, b int , c string ) ( r , s int ) {
	return
}
</code></pre><p>通过函数定义，我们可以看到Go中函数和其他语言中的共性和特性</p><h3 id="共性">共性</h3><ul><li>关键字——func</li><li>方法名——funcName</li><li>入参——— a,b int,b string</li><li>返回值—— r,s int</li><li>函数体—— {}</li></ul><h3 id="特性">特性</h3><p>Go中函数的特性是非常酷的，给我们带来不一样的编程体验。</p><h4 id="为特定类型定义函数-即为类型对象定义方法">为特定类型定义函数，即为类型对象定义方法</h4><p>在Go中通过给函数标明所属类型，来给该类型定义方法，上面的 <code>p myType</code> 即表示给myType声明了一个方法， <code>p myType</code> 不是必须的。如果没有，则纯粹是一个函数，通过包名称访问。packageName.funcationName</p><p>如：</p><pre><code class="language-golang">	//定义新的类型double，主要目的是给float64类型扩充方法
	type double float64

	//判断a是否等于b
	func (a double) IsEqual(b double) bool {
		var r = a - b
		if r == 0.0 {
			return true
		} else if r &lt; 0.0 {
			return r &gt; -0.0001
		}
		return r &lt; 0.0001
	}

	//判断a是否等于b
	func IsEqual(a, b float64) bool {
		var r = a - b
		if r == 0.0 {
			return true
		} else if r &lt; 0.0 {
			return r &gt; -0.0001
		}
		return r &lt; 0.0001
	}

	func main() {
		var a double = 1.999999
		var b double = 1.9999998
		fmt.Println(a.IsEqual(b))
		fmt.Println(a.IsEqual(3))
		fmt.Println( IsEqual( (float64)(a), (float64)(b) ) )

	D}
</code></pre><p>上述示例为 float64 基本类型扩充了方法IsEqual，该方法主要是解决精度问题。 其方法调用方式为： <code>a.IsEqual(double)</code> ，如果不扩充方法，我们只能使用函数<code>IsEqual(a, b float64)</code></p><h4 id="入参中-如果连续的参数类型一致-则可以省略连续多个参数的类型-只保留最后一个类型声明">入参中，如果连续的参数类型一致，则可以省略连续多个参数的类型，只保留最后一个类型声明。</h4><p>如 <code>func IsEqual(a, b float64) bool</code> 这个方法就只保留了一个类型声明,此时入参a和b均是float64数据类型。 这样也是可以的： <code>func IsEqual(a, b float64, accuracy int) bool</code></p><h4 id="变参-入参支持变参-即可接受不确定数量的同一类型的参数">变参：入参支持变参,即可接受不确定数量的同一类型的参数</h4><p>如 <code>func Sum(args ...int)</code> 参数args是的slice，其元素类型为int 。经常使用的fmt.Printf就是一个接受任意个数参数的函数 <code>fmt.Printf(format string, args ...interface{})</code></p><h4 id="支持多返回值">支持多返回值</h4><p>前面我们定义函数时返回值有两个r,s 。这是非常有用的，我在写C#代码时，常常为了从已有函数中获得更多的信息，需要修改函数签名，使用out ,ref 等方式去获得更多返回结果。而现在使用Go时则很简单，直接在返回值后面添加返回参数即可。</p><p>如,在C#中一个字符串转换为int类型时逻辑代码</p><pre><code class="language-golang">    int v=0;
	if ( int.TryPase(&quot;123456&quot;,out v) )
	{
		//code
	}
</code></pre><p>而在Go中，则可以这样实现,逻辑精简而明确</p><pre><code class="language-golang">	if v,isOk :=int.TryPase(&quot;123456&quot;) ; isOk {
		//code
	}
</code></pre><p>同时在Go中很多函数充分利用了多返回值</p><ul><li>func (file *File) Write(b []byte) (n int, err error)</li><li>func Sincos(x float64) (sin, cos float64)</li></ul><p>那么如果我只需要某一个返回值，而不关心其他返回值的话，我该如何办呢？ 这时可以简单的使用符号下划线”_“ 来忽略不关心的返回值。如：</p><pre><code class="language-golang">	_, cos = math.Sincos(3.1415) //只需要cos计算的值
</code></pre><h4 id="命名返回值">命名返回值</h4><p>前面我们说了函数可以有多个返回值，这里我还要说的是，在函数定义时可以给所有的返回值分别命名，这样就能在函数中任意位置给不同返回值复制，而不需要在return语句中才指定返回值。同时也能增强可读性，也提高godoc所生成文档的可读性</p><p>如果不支持命名返回值，我可能会是这样做的</p><pre><code class="language-golang">	func ReadFull(r Reader, buf []byte) (int, error) {
		var n int
		var err error

	    for len(buf) &gt; 0  {
	        var nr int
	        nr, err = r.Read(buf)
	        n += nr
			if err !=nil {
				return n,err
			}
	        buf = buf[nr:]
	    }
	    return n,err
	}
</code></pre><p>但支持给返回值命名后，实际上就是省略了变量的声明，return时无需写成<code>return n,err</code> 而是将直接将值返回</p><pre><code class="language-golang">	func ReadFull(r Reader, buf []byte) (n int, err error) {
	    for len(buf) &gt; 0 &amp;&amp; err == nil {
	        var nr int
	        nr, err = r.Read(buf)
	        n += nr
	        buf = buf[nr:]
	    }
	    return
	}
</code></pre><h4 id="函数也是-值">函数也是“值”</h4><p>和Go中其他东西一样，函数也是值，这样就可以声明一个函数类型的变量，将函数作为参数传递。</p><p>声明函数为值的变量(匿名函数:可赋值个变量，也可直接执行)</p><pre><code class="language-golang">	//赋值
	fc := func(msg string) {
		fmt.Println(&quot;you say :&quot;, msg)
	}
	fmt.Printf(&quot;%T \n&quot;, fc)
	fc(&quot;hello,my love&quot;)
	//直接执行
	func(msg string) {
		fmt.Println(&quot;say :&quot;, msg)
	}(&quot;I love to code&quot;)
</code></pre><p>输出结果如下，这里表明fc 的类型为：func(string)</p><pre><code class="language-golang">    func(string)
	you say : hello,my love
	say : I love to code
</code></pre><p>将函数作为入参（回调函数），能带来便利。如日志处理，为了统一处理，将信息均通过指定函数去记录日志，且是否记录日志还有开关</p><pre><code class="language-golang">	func Log(title string, getMsg func() string) {
		//如果开启日志记录,则记录日志
		if true {
			fmt.Println(title, &quot;:&quot;, getMsg())
		}
	}
    //---------调用--------------
	count := 0
	msg := func() string {
		count++
		return &quot;您没有即使提醒我,已触犯法律&quot;
	}
	Log(&quot;error&quot;, msg)
	Log(&quot;warring&quot;, msg)
	Log(&quot;info&quot;, msg)
	fmt.Println(count)
</code></pre><p>这里输出结果如下，count 也发生了变化</p><pre><code class="language-golang">	error : 您没有即使提醒我,已触犯法律
	warring : 您没有即使提醒我,已触犯法律
	info : 您没有即使提醒我,已触犯法律
</code></pre><h4 id="函数也是-类型">函数也是“类型”</h4><p>你有没有注意到上面示例中的 <code>fc := func(msg string)...</code> ，既然匿名函数可以赋值给一个变量，同时我们经常这样给int赋值 <code>value := 2</code> ,是否我们可以声明func(string) 类型 呢，当然是可以的。</p><pre><code class="language-golang">	//一个记录日志的类型：func(string)
	type saveLog func(msg string)

	//将字符串转换为int64,如果转换失败调用saveLog
	func stringToInt(s string, log saveLog) int64 {

		if value, err := strconv.ParseInt(s, 0, 0); err != nil {
			log(err.Error())
			return 0
		} else {
			return value
		}
	}

	//记录日志消息的具体实现
	func myLog(msg string) {
		fmt.Println(&quot;Find Error:&quot;, msg)
	}

	func main() {
		stringToInt(&quot;123&quot;, myLog) //转换时将调用mylog记录日志
		stringToInt(&quot;s&quot;, myLog)
	}
</code></pre><p>这里我们定义了一个类型，专门用作记录日志的标准接口。在stringToInt函数中如果转换失败则调用我自己定义的接口函数进行日志处理，至于最终执行的哪个函数，则无需关心。</p><h4 id="defer-延迟函数">defer 延迟函数</h4><p>defer 又是一个创新，它的作用是：延迟执行，在声明时不会立即执行，而是在函数return后时按照后进先出的原则依次执行每一个defer。这样带来的好处是，能确保我们定义的函数能百分之百能够被执行到，这样就能做很多我们想做的事，如释放资源，清理数据，记录日志等</p><p>这里我们重点来说明下defer的执行顺序</p><pre><code class="language-golang">	func deferFunc() int {
		index := 0

		fc := func() {

			fmt.Println(index, &quot;匿名函数1&quot;)
			index++

			defer func() {
				fmt.Println(index, &quot;匿名函数1-1&quot;)
				index++
			}()
		}

		defer func() {
			fmt.Println(index, &quot;匿名函数2&quot;)
			index++
		}()

		defer fc()

		return func() int {
			fmt.Println(index, &quot;匿名函数3&quot;)
			index++
			return index
		}()
	}

	func main() {
		deferFunc()
	}
</code></pre><p>这里输出结果如下，</p><pre><code>0 匿名函数3
1 匿名函数1
2 匿名函数1-1
3 匿名函数2
</code></pre><p>有如下结论：</p><ul><li>defer 是在执行完return 后执行</li><li>defer 后进先执行</li></ul><p>另外，我们常使用defer去关闭IO,在正常打开文件后，就立刻声明一个defer，这样就不会忘记关闭文件，也能保证在出现异常等不可预料的情况下也能关闭文件。而不像其他语言：<code>try-catch</code> 或者 <code>using()</code> 方式进行处理。</p><pre><code class="language-golang">	file , err :=os.Open(file)
	if err != nil {
		return err
	}
	defer file.Close()
	//dosomething with file
</code></pre><p>后续，我将讨论： 作用域、传值和传指针 以及 保留函数init(),main()</p><p>本笔记中所写代码存储位置：</p><ul><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/defer.go">defer.go</a></li><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/defineFunctionType.go">defineFunctionType.go</a></li><li><a href="https://github.com/devYu/GoLangStudy/tree/master/codeDemo/function.go">function.go</a></li></ul><p><a href="https://github.com/devYu/GoLangStudy/blob/master/myNotes/controlStructures.md">上篇-控制语句</a></p></div><aside id="meta"><div class="share_sec2"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><ul class="rel_links"><li class="rel_linksli"><a href="">老虞学golang-字符串</a></li><li class="rel_linksli"><a href="">老虞学Golang-常量</a></li><li class="rel_linksli"><a href="">老虞学Golang-数组和切片</a></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2013/ysqi-golang-if-for-select-switch.html">老虞学Golang-控制语句</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2013/ysqi-golang-string.html">老虞学golang-字符串</a></li><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E5%BC%80%E5%8F%91.html" rel="category">开发</a> </span><span id="tags">标签: <a href="/tags/go.html" rel="tag">Go</a> <a href="/tags/%E6%95%99%E7%A8%8B.html" rel="tag">教程</a> <a href="/tags/%E7%AC%94%E8%AE%B0.html" rel="tag">笔记</a></span></li></ul><aside id="comments"><div><h5 style="border-left:4px solid #ee9d05">评论</h5><div class="ds-thread" data-thread-key="d411a2cacc3e9b482f97ea61f7f17a40" data-title="老虞学Golang-函数上" data-url="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，个人承接Golang语言开发。专注Golang、开源协作、微信平台开发和工作经验的分享。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在<a href="https://yushuangqi.com" title="虞双齐Golang开发博客">个人博客</a>上 ，分享经验。</p></section></div><meta itemprop="wordCount" content="571"><meta itemprop="url" content="https://yushuangqi.com/blog/2013/ysqi-golang-function-1.html"></aside></article></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2013%2fysqi-golang-function-1.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2013%2fysqi-golang-function-1.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐产品设计与软件开发，个人诚接软件开发外包。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>