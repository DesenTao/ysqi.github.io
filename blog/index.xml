<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog-rsses on 虞双齐的博客</title>
    <link>https://yushuangqi.com/blog.xml</link>
    <description>在 虞双齐的博客上关于in Blog-rsses 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>ysqi@yushuangqi.com (虞双齐)</managingEditor>
    <webMaster>ysqi@yushuangqi.com (虞双齐)</webMaster>
    <lastBuildDate>Mon, 14 Aug 2017 18:52:10 +0800</lastBuildDate>
    <atom:link href="/blog.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Golang Generate命令说明与使用</title>
      <link>https://yushuangqi.com/blog/2017/go-command-generate.html</link>
      <pubDate>Mon, 14 Aug 2017 18:52:10 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-command-generate.html</guid>
      <description>前期有专门利用go generate自动生成Go代码，今日在查看Go源代码时发现有大量使用此命令已生成各类代码。故在此特写文章说明generate命令的神奇之处。
命令诉求 通用计算有一特性——图灵完备。是一个计算机程序能编写一个计算机程序。既能写程序的程序。按规则定义描述内容，则可以根据描述生成程序代码。10年时刚做项目便以增删改查为主，代码生成器生成代码那是杠杠的。
通过定义便可高效生成代码，无需手工编码。如当定义一个枚举后，为了打印友好内容，我们经常手工定义String方法。
type Status int const ( Offline Status = iota Online Disable Deleted ) var statusText = []string{&amp;quot;Offline&amp;quot;, &amp;quot;Online&amp;quot;, &amp;quot;Desable&amp;quot;, &amp;quot;Deleted&amp;quot;} func (s Status) String() string { v := int(s) if v &amp;lt; 0 || v &amp;gt; len(statusText) { return fmt.Sprintf(&amp;quot;Status(%d)&amp;quot;, s) } return statusText[v] }  当遇到枚举调整时，则必须要再同步修改statusText，而此事常容被忽视。
Generate命令说明 早在Go1.4版本实现，所以你现在可以看到Go源码中大量含有的该命令使用。
如：在unicode包中生产Unicode表，为encoding/gob创建有效的编解码方法，在time包中创建时区数据等等
go generate用于一键式批量执行任何命令，创建或更新Go文件或者输出结果。
Generate 命令和其他go build、go get、go test等没半毛钱关系。需特定执行，命令如下：
go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.</description>
    </item>
    
    <item>
      <title>Go读取通达信历史日线数据</title>
      <link>https://yushuangqi.com/blog/2017/go-du-qu-tong-da-xin-li-shi-ri-xian-shu-ju.html</link>
      <pubDate>Wed, 26 Jul 2017 10:32:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-du-qu-tong-da-xin-li-shi-ri-xian-shu-ju.html</guid>
      <description>突然间想使用Go从通达信读取A股历史行情信息，其实也蛮简单的。从通达信获取数据难点在于分析数据结构，而读取则各类语言分分钟搞定。
准备工作  下载安装通达信,通达信官网 下载历史行情数据  下载操作路径：系统-&amp;gt;盘后数据下载
下载后数据按股票市场分别存放：
 上海交易所：{通达信安装目录}\vipdoc\sh\lday\*.day 深圳交易所：{通达信安装目录}\vipdoc\sz\lday\*.day  通达信历史日线数据文件格式 每只股票一个day文件，如：sh000001.day。文件中每一天数据总共32字节。其中每32字节数据格式如下：
   数据含义 数据类型 数据长度 举例 单位     日期 Integer 4 20170703    开盘价 Integer 4 2476 当前值/100,元   最高价 Integer 4 2520 当前值 /100,元   最低价 Integer 4 2436 当前值 / 100,元   收盘价 Integer 4 2457 当前值 / 100,元   成交金额 single 4 1317335898 元   成交量 Integer 4 45293799 股   保留 Integer 4      注意，因为价格均是两位小数，故文件中的价格放大100倍，以便按数字存储。</description>
    </item>
    
    <item>
      <title>希腊八日游游记</title>
      <link>https://yushuangqi.com/blog/2017/%E5%B8%8C%E8%85%8A%E5%85%AB%E6%97%A5%E6%B8%B8%E6%B8%B8%E8%AE%B0.html</link>
      <pubDate>Mon, 24 Jul 2017 07:32:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/%E5%B8%8C%E8%85%8A%E5%85%AB%E6%97%A5%E6%B8%B8%E6%B8%B8%E8%AE%B0.html</guid>
      <description>一、前期准备 1、申根签证 （深圳希腊签证中心可直接送签，地址是福田区福华一路大中华国际交易广场北门西区，上班时间为9：00-15：00）： （1）申根签申请表（网上下载打印好爱你按照模板填写） （2）境外保险单（淘宝、携程等都可以购买，出单后打印出来） （3）机票预定单 （4）酒店预定单（在Booking英文版上订住宿，需要用到信用卡，订好了之后，把确认信息页保存为PDF格式，然后再把订单取消，要找取消订单不收费的酒店。） （5）行程单 （6）银行卡近三个月流水单（银行网点有自助机打印，听说卡里余额要三万以上，我一万也通过了） （7）在职证明 （8）公司或单位营业执照复印件 （9）户口簿复印件 （10）护照原件及复印件 Ps ：酒店预定单和行程单这两个我们嫌麻烦，都是找万能的淘宝搞定的。</description>
    </item>
    
    <item>
      <title>Go面试题答案与解析</title>
      <link>https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html</link>
      <pubDate>Thu, 20 Jul 2017 12:58:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golang-mian-shi-ti-da-an-yujie-xi.html</guid>
      <description>昨天AstaXie发布GoCN每日新闻(2017-07-19)含一篇Go面试题。阅读和评论量挺高，是测试面试者对Go本身基础概念理解掌握程度，以及Go实战经验。这也是在Go中容易遇到的坑，我也曾遇到过。于是快马加鞭，抢在原作者前发布Go面试题答案和解析说明，供大家参考。如有错误请指出，谢谢。
1、写出下面代码输出内容。 package main import ( &amp;quot;fmt&amp;quot; ) func main() { defer_call() } func defer_call() { defer func() { fmt.Println(&amp;quot;打印前&amp;quot;) }() defer func() { fmt.Println(&amp;quot;打印中&amp;quot;) }() defer func() { fmt.Println(&amp;quot;打印后&amp;quot;) }() panic(&amp;quot;触发异常&amp;quot;) }  在线运行
答： 输出内容为：
打印后 打印中 打印前 panic: 触发异常  解析：
考察对defer的理解，defer函数属延迟执行，延迟到调用者函数执行 return 命令前被执行。多个defer之间按LIFO先进后出顺序执行。
故考题中，在Panic触发时结束函数运行，在return前先依次打印:打印后、打印中、打印前 。最后由runtime运行时抛出打印panic异常信息。
需要注意的是，函数的return value 不是原子操作.而是在编译器中分解为两部分：返回值赋值 和 return 。而defer刚好被插入到末尾的return前执行。故可以在derfer函数中修改返回值。如下示例：
package main import ( &amp;quot;fmt&amp;quot; ) func main() { fmt.Println(doubleScore(0)) //0 fmt.Println(doubleScore(20.0)) //40 fmt.Println(doubleScore(50.0)) //50 } func doubleScore(source float32) (score float32) { defer func() { if score &amp;lt; 1 || score &amp;gt;= 100 { //将影响返回值 score = source } }() score = source * 2 return //或者 //return source * 2 }  在线运行</description>
    </item>
    
    <item>
      <title>你误会蟑螂了</title>
      <link>https://yushuangqi.com/blog/2017/ni-wu-hui-zhang-liang-le.html</link>
      <pubDate>Sat, 15 Jul 2017 09:32:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ni-wu-hui-zhang-liang-le.html</guid>
      <description>一说蟑螂，就鸡皮疙瘩一顿爆。其实你误会蟑螂了！
对蟑螂的普遍看法
 恶心 南方蟑螂大，会飞 跑得快 有传染病  其实你的偏见都是来自于出没于居家环境中的蟑螂。
蟑螂的种类约有6000多种，只有约数十种才会入侵家居环境，其他的都被作为宠物饲养、或在野外山涧树林、或昆虫博客管中。只有30种能算得上是害虫。这少数的30种害虫使整个蟑螂类群蒙上了污名。而在国内南北方家居环境中常见的是：德国小镰。
在开始为蟑螂正名之前，先来个愉快的心情： 
蟑螂名 蟑螂是俗称，学名为“蜚蠊目”昆虫。其俗名有：
 黄嚓（客家方言） 小强（广东香港地区） 曱甴（yuēyóu，粤语、闽南语、客家话均同，粤语拼作gaat6 zaat6，潮州话拼作ga1zuah8） 黄婆娘、骚甲（桂林方言） 油夹虫（溆浦方言） 偷油婆（四川话） 焕嚓（梅州话） 活朗额（大连方言） 灶妈子（武汉方言） 油灶婆（衡阳方言） 扎（zhā）马（mā）虫（云南方言）  原来全世界都有蟑螂 以前总认为蟑螂是广东特产，原来蟑螂是这个星球上最古老的昆虫之一，曾与恐龙生活在同一时代。与恐龙相比，蟑螂是更早的地球定居者，蟑螂要先于恐龙数百万年出现在地球上。
亿万年来它的外貌并没什么大的变化，但生命力和适应力却越来越顽强，一直繁衍到今天，广泛分布在世界各个角落。
原来繁殖力牛逼 一对儿德国小蠊如果条件合适一年可生产一千万只。
一只被摘头的蟑螂可以存活9天，9天后死亡的原因则是过度饥饿。
如果有一天地球上发生了全球核子大战，在影响区内的所有生物包括人类和甚至鱼类等都会消失殆尽，只有蟑螂会继续它们的生活！
不是打不死，而是蟑螂的繁殖能力很强！！！
原来蟑螂不会传播疾病 由于缺乏有效传播途径，至今没有蟑螂传播疾病的案例。实际上蟑螂仅仅是携带病源。
但也别在家吃蟑螂呀，不是不卫生而是蟑螂的分泌物、排泄物、呕吐物可以引起人体的过敏反应。如果有易过敏家人，则尽量消灭蟑螂。
实际上蟑螂有用作药材和食用的。当然食用的野生蟑螂，贝爷就是洗干净煮着吃滴。 原来蟑螂在国外很流行当宠物 6000多种蟑螂，还不少难得一见。奇葩的是，把蟑螂当宠物的也是很多的。
在美国10岁的小萝莉对蟑螂钟爱无比，不但和蟑螂同吃同睡，而且还养了1000多只蟑螂陪伴自己，任由蟑螂在自己身上爬来爬去。 这可不是家里的小强，它是马岛发声蟑螂，在西方也是普及度非常高的宠物；在美国是博物馆动物园学校等教育机构进行昆虫学科普的首选动物之一。
澳大利亚一年一度的赛蟑螂大赛是澳大利亚国庆日最大的一个娱乐项目之一。 用于赛跑的是美洲大蠊，大家也乐在其中。
“鲜花会凋谢，烛光会熄灭，只有小强才是永远。” 参与这项活动的是动物园饲养的马达加斯加发声蟑螂。这是纽约布朗克斯动物园的情人节传统：只要献祭一小笔金钱，就可以用爱人——或者不那么爱的人——的名字来命名动物园里的一只小强。园方称，蟑螂不被大众所理解，它们其实是情深义重的好情侣。
昆虫学家Naskrecki的万圣节博文称：人类喜欢用的吓人方式之一是随便找个又小又无害的生物，硬说它们很危险；蝙蝠/蜘蛛/蟑螂都是常见的受害者。在任何情况下，我都更愿意撞上这些小东西，而不是黑白相间的巨大怪兽（熊猫）。 来自虫爷ChenZ的话 如果没有大熊猫，自然只是会失去一丝色彩；但如果没有苍蝇蟑螂秃鹫蜣螂等等清除垃圾腐肉粪便的生物，这个星球就会变成一个令人作呕的垃圾堆。
虽然可以在一定程度上理解人类文化对于这类动物的习惯性丑化，但是我无法接受。
仔细想想，地球上的人类每天排泄9亿公斤的粪便，同时将不计其数的动物变成尸体，远超自己能吃下去的量。这个地球上最大的粪便和腐尸生产机器居然认为那些清理粪便和尸体的清洁工们肮脏又恶心？
 虫爷ChenZ：一位沉迷虫子和续命的绅士，微博科学科普帐号@虫爷ChenZ
 结尾 居家环境中放肆的蟑螂还是得消灭，但这仅仅是蟑螂世界里的极小的一部分。就像人类也有善恶之分，不要一棍子敲死所有人。 已知的蟑螂中，只有不到1%的种类会给人类的生活带来困扰，但几乎没人愿意进一步了解剩下的99%。</description>
    </item>
    
    <item>
      <title>如何提高邮件件打开率和回复率</title>
      <link>https://yushuangqi.com/blog/2017/ru-he-ti-gao-you-jian-da-kai-li-he-hui-fu-li.html</link>
      <pubDate>Sun, 09 Jul 2017 22:32:00 +0000</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ru-he-ti-gao-you-jian-da-kai-li-he-hui-fu-li.html</guid>
      <description>现在虽有即时通讯软件，但邮件依旧是日常办公必备的沟通方式。那么如何写出牛哄哄的、得体的、打开率高、回复即时的邮件呢？ 小编我虞双齐结合实际工作，总结出四个字：礼貌、清晰 。
 凡人之所以贵于禽兽者，以有礼也。 ——《晏子春秋》
 写好开场白 谁会讨厌礼貌地人儿？礼多人不怪，礼貌性的称呼是邮件不可或缺的内容。
在适合的场景下，使用合适的开场白，能让收件人舒心的开始阅读邮件。而不会感觉别扭或被冒犯。
   关系 举例 说明     平级同事 双齐，你好 尽量不要带姓，直接称呼名。
如果写成“虞双齐，你好”便显得有距离感，生硬   上级领导 黎总，你好 所有上级都是xx总，谁不爱听呢？ 但不建议使用尊称“您”，显得做作。除非是写给顶级Boss   不了解 黎经理，你好 知道职称时，可以按职称称呼   不了解 黎总，你好 不清楚职称时   不了解 黎老师，你好 国企总爱称呼为老师    当然也有许多人并不关心你如何称呼他， 但我们得保持礼貌。
语气友好 根据收件人同自己的熟络程度、等级关系，以及内容性质等，选择恰当的语气进行论述，以免引起对方不适。
同时对别人的意见做出谨慎而客观的评论，谨记邮件可轻易转发，防止陷入“邮件门”。
 理性论述，少感性激动 少用感叹号，也许会互掐 少用语气词 “啊”，“咦”等 改“要求语气”为“请求语气” 慎用表情符，使用不当被曲解  写好落款 什么样的落款最好？因人而异，实际没有人关注你结尾的问候语，但你可以在结尾给收件人留下联系方式。
当收件人想同你电话沟通时，立马可拨号给你。而不至于还得翻看通讯录，白白浪费时间，也许会取消给你电话的冲动。
主题明了 主题应简短并能含有关键信息。 如下： 前后对比，孰优孰劣，一看便知。
特别是给Boss发邮件，即使他们不看邮件内容，也能知晓大概。</description>
    </item>
    
    <item>
      <title>简述电子邮件发展历史</title>
      <link>https://yushuangqi.com/blog/2017/jian-shu-dian-zi-you-jian-fa-zhan-li-shi.html</link>
      <pubDate>Sun, 02 Jul 2017 21:01:02 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jian-shu-dian-zi-you-jian-fa-zhan-li-shi.html</guid>
      <description>平均每天发送10封邮件，日常工作中邮件是重要的沟通方式。虽然现在也有QQ消息，微信等其他即使通讯工具，但思想都源于电子邮件。
是否有兴趣了解电子邮件的发展历史？这里虞双齐多方收集资料，整理成文，以简述电子邮件发展历史。
电子邮件的启蒙期 70年代计算机已被各研究机构使用，美国军方机构为最。当时美国军方分支机构ARPA「高等研究计划署 （Advanced Research Projects Agency）」为美国军事机构之间的信息交流做防护而设计为异地间的计算机之间进行信息交换的网络ARPANET（阿帕网），此网乃当今互联网的鼻祖。
而当时工作者（科学家）只能通过哑终端(Dumb Terminal)，经串型接口连接到大型计算机工作。哑终端没有内存和硬盘，输入字符指令到主机才能执行计算。
可是，连接到同一个大型计算机的哑终端，是在不同时区的工作者手中。打电话有时候很难联系到人。在1965年麻省理工学院开发了世界第一个用于在同一主机上发消息的程序MailBox。
初期的邮件实际上就是一个有特殊保护的文件夹。其他人可以往文件夹里面存放消息文件，当别人登陆到主机时可看到消息。类似于一个桌面记事本。
电子邮件的诞生 在1967年，一位谦虚的计算机工程师Ray Tomlinson获得麻省理工学院计算机工程博士学位后，到BBN「博尔特·贝拉尼克—纽曼(Bolt Beranek and Newman)」公司从事计算机研究工作。刚好该公司受聘于美国国防部，参与阿帕网（Arpanet）的建设和维护工作。他在这里留下了他在计算机行业的辉煌。
尽管MaiBox能发消息，但仅仅局限在同一计算机下。那么如何才能让不同计算机间能发送消息呢？
1971年的一天，Tomlinson完成了世界上第一封真正名义上的电子邮件发送。他在PDP-10机器上运行的TENEX操作系统上写了一个邮件程序名为SENDMSG，并起草一个简单的文件传输协议CPYNET，来使得SENDMSG程序能将消息从一台计算机发送到另外一台计算机。
他在BBN剑桥办事处并排的两台PDP-10计算机上测试，此两台计算机间仅有的物理连接是都接入到ARPANET。他从一台计算机往另一台计算机发送测试消息给自己。因为测试内容太多，他也不记得第一条测试消息是什么内容。他回忆也许是QWERTYUIOP或类似的消息。
测试成功后，他非常满意，于是给他们组的其他人员发消息告诉他们是如何实现在两台计算机间发生消息的。 尽管第一封电子邮件的内容连Tomlinson本人也记不起来了，但那一刻仍然具备了十足的历史意义：电子邮件诞生了。
在1972年初，TENEX的下一个版本发布，便包括具有网络邮件功能的SNDMSG版本。 CPYNET协议很快就被具有特定邮件处理功能的真正的文件传输协议所取代。
电子邮件中&amp;rsquo;@&amp;lsquo;标识符的来由 Ray Tomlinson因SENDMSG和CPYNET而出名。
在1972年末，他为了实现两台计算机间发消息，将CPYNET的代码并入到了SENDMGS中，以提供区分本地邮件和网络邮件的方式。 应该如何表示呢？如何找一个字符进行区分呢，还不会出现在人名中。他低头盯着电传打印机(Model 33 Teletype)键盘，随后选择了@来进行区分。他表示&amp;rdquo;@&amp;ldquo;不会出现在人名中，也有at(在)的意思。表示某人在其他计算机上，user-name@the-computer-name。当时的他压根就没意识到，他创造了世界无人不晓的&amp;rdquo;@&amp;ldquo;。
后因Tomlinson发明电子邮件 ，他因此入选由被互联网协会（ISOC）评选的首届互联网名人堂，美国《福布斯》杂志曾对汤姆林森评价说：“对他个人来说，‘@’只不过是一件小发明，但对整个世界来讲，则无疑是一件伟大的发明。”
不幸的是，这位电子邮件之父Ray Tomlinson 于2016年3月5日逝世，年享74岁。
电子邮件的成长期 这个“@”被ARPANET的工作人员所接受，开始推广使用电子邮件。在1974年，ARPNET下有一百多人使用电子邮件，电子邮件成为ARPANET的首选沟通方式。
有趣的是，另一个计算机工程师 Larry Roberts 给邮件服务器添加了文件夹功能。初衷是为了方便他老板给电子邮件分类以方便查找邮件。
到1976年，电子邮件开始流行，商业工具也开始涌现。而APRNET计算机间75%的流量都是电子邮件内容。紧随而来的是广告邮件，世界第一封电子邮件广告出现在美国政府和大学的网络上。
1981年 IBM推出IBM5150新款计算机，个人电脑随之诞生。跟随个人电脑的普及，高傲的网络连接费是笔不小的负担，一分钟的电话费需要很多钱。这也促使了电子邮件的一个小进步。名为&amp;rdquo;offline readers&amp;rdquo;软件应世而出，它允许电子邮件用户将邮件存储到个人电脑上。可以随时阅读邮件和回复邮件，在发送邮件时才需要联网。能够离线邮件再联线发送电子邮件是十分节约连接费。
1982年，简单邮件传输协议SMTP(Simple Mail Transfer Protocol)被定制，用于使用统一标准接发电子邮件。 同年电子邮件的世界里也出现了著名的表情符笑脸-:)。
1888年,Steve Dorner开发世界上第一个图形操作界面的电子邮件客户端程序，名为Eudora 1989年，配音员在美国在线录制了为电子邮件录制了“欢迎”、“已完成”、“再见”、“您有新邮件” 等声音。
电子邮件的高速发展期 90年代， 万维网发展，雅虎和Hotmail推出免费WEB版电子邮箱。每个人员极易获得电子邮箱账号，全球几亿人使用电子邮件。 + 1997年，微软花4亿收购Hotmail ，同年推出Outlook。
 1998年，垃圾邮件(spam)一词入选牛津字典。 2004年，“LOL“(互联网缩略语，意为哈哈)和其他缩略语被写入牛津辞典。 2004年，世界多媒体信息服务大会，在维也纳召开。他讲多媒体技术引入到电子邮件使用当中。 2007年，谷歌开放Gmail电子邮件系统 2011年，《美联社写作风格指南》一书中开始讲“e-mail”简写为“email” 2003年，超77亿人使用电子邮件。</description>
    </item>
    
    <item>
      <title>给电脑小白精挑细选的五个免费软件</title>
      <link>https://yushuangqi.com/blog/2017/gei-dian-nao-xiao-bai-jing-tiao-xi-xuan-de-wu-ge-mian-fei-ruan-jian.html</link>
      <pubDate>Wed, 28 Jun 2017 21:01:02 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/gei-dian-nao-xiao-bai-jing-tiao-xi-xuan-de-wu-ge-mian-fei-ruan-jian.html</guid>
      <description>不是每一个人都精通电脑，不是每一个都在为提供办公效率而绞尽脑汁。通过软件助你提供效率，每次操作节约3秒钟，一年可为你节约多少个3秒钟？
下面虞双齐结合日常工作，为大家从13个软件中挑选出5个免费软件，以提升效率。挑选原则： + 免费
+ 提升效率
+ 性能稳定 + 本人亲自使用超过2年
请公账号中回复：工具 两字获取此5个免费软件的下载地址清单。
5个可以提升办公效率的免费软件 1.文件搜索工具：Everything 找不到文件存在哪里？文件藏的太深，需点击N次鼠标才能看到？那就使用Everything来解决痛点，配合快捷键启动。找文档，打开文档超快！
Everything是Windows桌面搜索引擎，实时搜索几乎瞬间完成、占用资源极低 。这些特性在如今磁盘容量越来越大、用户文件越来越多的情况下使得Everything超越了传统桌面搜索工具而广受欢迎，它能在几秒钟内从数百GB的硬盘中精确搜索到需要的内容，支持高级搜索、正则表达式、网络搜索、离线搜索等等。 2. 文件压缩解压工具： 7-zip 还在用破解版的WinRar? 赶快换成高速的7-zip。
7z 是一种全新的压缩格式，它拥有极高的压缩比。通常使用 7-Zip 的 7z 格式能比使用 zip 格式的压缩档案小 30-70%。并且使用 7-Zip 创建的 zip 格式比大多数其它压缩软件创建的都小 2-10%。 3. 文本编辑工具：Notepad++ window中的记事本有一个天生的设计缺陷，有些软件无法读取被你通过记事本修改过的文件。
杜绝窘迫，请使用Notepad++替代记事本。Notepad++是多次获得SourceForge社区最佳开发工具奖，开源软件，知名度极高，来自宝岛台湾。 !(Notepad++)(https://static.yushuangqi.com/blog/2017/28955498546793.png)
4. 远程工具：TeamViewer 想在家远程操控办公室电脑？想iPad远程操控电脑？想IT远程技术支持？
也许你有使过QQ的远程功能，但TeamViewer才是专业的TeamViewer是专业、功能强大，使用简单，对个人用户免费的一个多功能软件，核心功能是执行远程操控和传送文件。可以不注册，但是注册成个人账户后，可方便免密远程操控。 5. 电子书阅读器： Sumatra PDF 想阅读pdf、eBook(ePub,Mobi)、CHM帮助文档 ？
Sumatra 是一款开源免费的 电子书阅读器, 小巧、迅速是其最大的特点。
Sumatra PDF 是你的首选，因为日常以阅读pdf为主，快速的打开和阅读pdf才是办公刚需。即使你在使用福昕阅读器，也赶快再安装Sumatra。深有体会的是福昕从一个简单好用的优秀国产软件变成了一个臃肿的软件。 结束语 给电脑小白的你，精挑细选五个可以提升效率的免费软件。提供办公效率从用好的软件开始，一步实际行动比一打纲领更重要。赶紧在公众号下直接回复“工具”两字，获取下载地址吧！
分享是一种生活的信念，明白了分享的同时，明白了存在的意义。如果本文有给你带来价值，请分享给你的朋友吧！</description>
    </item>
    
    <item>
      <title>终于找到我要的读书方法了</title>
      <link>https://yushuangqi.com/blog/2017/find-the-best-way-to-read-book-for-me.html</link>
      <pubDate>Sun, 25 Jun 2017 20:12:27 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/find-the-best-way-to-read-book-for-me.html</guid>
      <description>自认爱好读书，纸质书，电子书堆积成山。但一直困扰我的是：未能高效Get到知识。
曾遭遇的困惑  买过很多不需要的书，在角落里干灰。 我好像读过这本书。 一口气读完一本书，就没有然后了。  现在买书很克制，不读完并吸收掌握就不继续买。先放到购物车或购书清单中，反正电商的图书活动不断，不怕下次没法优惠购。
如果你有同感请继续看，否则请打道回府，欢迎下次光临🙈。
新招式破解困局 我在《如何有效阅读一本书》中找到了良药：用笔记本管理读书生活 &amp;gt; 一次偶然的机会，在西西弗购物公园店看书时，拿到本日本作家奥野宣之著的《如何有效阅读一本书》。当时看得入迷，时间紧迫。当晚京东下单，接着感受其中的方法论。 &amp;gt; 豆瓣书评传送门：http://t.cn/RJLVnDL 此法乃大简之道，力荐给爱好读书的你。 原始，简单，有效！前后细读两次，越发认为通过笔记管理读书生活有趣而实用。
笔记本 高中时一开学，得买好几个高大上的笔记本。每门各一本，然后在封面写上XX课笔记本虞双齐。好傻包的行为😂。搞得最后是，一上课就找笔记本，期末还每个笔记本一大半纸是空白的&amp;hellip;.
直到现在，也经常给各中东西细分类，没过多久就一团乱有得收拾。其实将东西放在一个筐下也是非常不错的，实际中大部分东西都是大半年用不上。与其分类细放，还不如一个纸箱子全部堆放。自然而然，经常用的东西在最上面。
东西细分类，是在添加心智负担 关于生活、工作、随想、心情都可以通通按时间顺序写到一个普通笔记本上。
字迹潦草无所谓，只要自己能看懂就好，别人才没时间看~~~
用一个普通的笔记本开始我崭新的学习之旅，之前用用过MyBase，Evernote、有道云笔记、为知笔记。在电脑上始终没法体验原始笔记本书写。更何况，我🐢般的打字速度，要命勒，要命勒！！ 所以现在回归到原始，结合为知笔记软件，重新管理我的知识。
功夫不负有心人 耳濡墨染的一个真理，假设一篇文章抄在笔记本上需要花三十分钟时间。而用智能手机拍成照片或扫描成纯文字文档却只要一分钟，想抄写的文字就能永久地保存下来。
那么，只要使用智能手机，读书效率就能提高三十倍吗？ 我想不是的。
即使你使用手机拍照，花三十分钟保存了三十本书的信息，也不如花三十分钟抄写一本书的内容有效。无论在手机里面保存了多少本书，书里面的内容都不会被保存在脑子里。这些内容既不能融入你的身心，也不能变成你无形的财富，与此相反，尽管抄完本也不一定能记住全部内容，但某段文章、某个词、作者的语气和思想等等，都会随着抄写时的身体感觉被深深地刻印在头脑和身体里。
就笔记本抄写文章内容，写感悟，记心情等都是简单有效快捷的方法。当做练字也好，请拾起笔，随便找一个干净的笔记本开始写笔记！ 结尾 一脑的想法，可提笔记录时，却难以下笔。需整理思路，如同和别人对话，得组织语言逻辑。才能让其听明白你所表达的意思。纵有千万灵感，只有用文字记录，让思想书面化，让灵感脱离之前的抽象状态，会更容易将其理解消化，也能促使你把灵感用作创意材料，想用的时候就能信手拈来。
我喜欢将知识，思想形成文字分享给他人。特别是工作内容，只有书面化，才能让自己理清思路完善知识，传播价值。
用笔记管理读书生活是值得一试的读书方法，我已服此良药，你会行动嘛？三个月后呢？</description>
    </item>
    
    <item>
      <title>gRPC服务发现&amp;amp;负载均衡</title>
      <link>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:36 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/grpcfu-wu-fa-xian-ampampfu-zai-jun-heng.html</guid>
      <description>gRPC服务发现&amp;amp;负载均衡  构建高可用、高性能的通信服务，通常采用服务注册与发现、负载均衡和容错处理等机制实现。根据负载均衡实现所在的位置不同，通常可分为以下三种解决方案：
 1、集中式LB（Proxy Model） 在服务消费者和服务提供者之间有一个独立的LB，通常是专门的硬件设备如 F5，或者基于软件如 LVS，HAproxy等实现。LB上有所有服务的地址映射表，通常由运维配置注册，当服务消费方调用某个目标服务时，它向LB发起请求，由LB以某种策略，比如轮询（Round-Robin）做负载均衡后将请求转发到目标服务。LB一般具备健康检查能力，能自动摘除不健康的服务实例。 该方案主要问题：
 单点问题，所有服务调用流量都经过LB，当服务数量和调用量大的时候，LB容易成为瓶颈，且一旦LB发生故障影响整个系统；
 服务消费方、提供方之间增加了一级，有一定性能开销。
  2、进程内LB（Balancing-aware Client） 针对第一个方案的不足，此方案将LB的功能集成到服务消费方进程里，也被称为软负载或者客户端负载方案。服务提供方启动时，首先将服务地址注册到服务注册表，同时定期报心跳到服务注册表以表明服务的存活状态，相当于健康检查，服务消费方要访问某个服务时，它通过内置的LB组件向服务注册表查询，同时缓存并定期刷新目标服务地址列表，然后以某种负载均衡策略选择一个目标服务地址，最后向目标服务发起请求。LB和服务发现能力被分散到每一个服务消费者的进程内部，同时服务消费方和服务提供方之间是直接调用，没有额外开销，性能比较好。该方案主要问题：
 开发成本，该方案将服务调用方集成到客户端的进程里头，如果有多种不同的语言栈，就要配合开发多种不同的客户端，有一定的研发和维护成本；
 另外生产环境中，后续如果要对客户库进行升级，势必要求服务调用方修改代码并重新发布，升级较复杂。
  3、独立 LB 进程（External Load Balancing Service） 该方案是针对第二种方案的不足而提出的一种折中方案，原理和第二种方案基本类似。
不同之处是将LB和服务发现功能从进程内移出来，变成主机上的一个独立进程。主机上的一个或者多个服务要访问目标服务时，他们都通过同一主机上的独立LB进程做服务发现和负载均衡。该方案也是一种分布式方案没有单点问题，一个LB进程挂了只影响该主机上的服务调用方，服务调用方和LB之间是进程内调用性能好，同时该方案还简化了服务调用方，不需要为不同语言开发客户库，LB的升级不需要服务调用方改代码。 该方案主要问题：部署较复杂，环节多，出错调试排查问题不方便。
gRPC服务发现及负载均衡实现 gRPC开源组件官方并未直接提供服务注册与发现的功能实现，但其设计文档已提供实现的思路，并在不同语言的gRPC代码API中已提供了命名解析和负载均衡接口供扩展。
其基本实现原理：
 服务启动后gRPC客户端向命名服务器发出名称解析请求，名称将解析为一个或多个IP地址，每个IP地址标示它是服务器地址还是负载均衡器地址，以及标示要使用那个客户端负载均衡策略或服务配置。
 客户端实例化负载均衡策略，如果解析返回的地址是负载均衡器地址，则客户端将使用grpclb策略，否则客户端使用服务配置请求的负载均衡策略。
 负载均衡策略为每个服务器地址创建一个子通道（channel）。
 当有rpc请求时，负载均衡策略决定那个子通道即grpc服务器将接收请求，当可用服务器为空时客户端的请求将被阻塞。
  根据gRPC官方提供的设计思路，基于进程内LB方案（即第2个案，阿里开源的服务框架 Dubbo 也是采用类似机制），结合分布式一致的组件（如Zookeeper、Consul、Etcd），可找到gRPC服务发现和负载均衡的可行解决方案。接下来以GO语言为例，简单介绍下基于Etcd3的关键代码实现：
1）命名解析实现：resolver.go
package etcdv3 import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;strings&amp;quot; etcd3 &amp;quot;github.com/coreos/etcd/clientv3&amp;quot; &amp;quot;google.golang.org/grpc/naming&amp;quot; ) // resolver is the implementaion of grpc.naming.Resolver type resolver struct { serviceName string // service name to resolve } // NewResolver return resolver with service name func NewResolver(serviceName string) *resolver { return &amp;amp;resolver{serviceName: serviceName} } // Resolve to resolve the service from etcd, target is the dial address of etcd // target example: &amp;quot;http://127.</description>
    </item>
    
    <item>
      <title>Caddy新兴的web服务器caddy</title>
      <link>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xin-xing-de-webfu-wu-qi-caddy.html</guid>
      <description>caddy 是一个像 Apache, nginx, 或 lighttpd 的web服务器。
你要问nginx已经很好了，为什么要用caddy呢? 我觉得caddy最大的特点是用起来简单，
然后呢，它还有下面这些开箱即用的特性:
 HTTP/2 全自动支持HTTP/2协议，无需任何配置。
 Auto HTTPS Caddy 使用 Let&amp;rsquo;s Encrypt 让你的站点全自动变成全站HTTPS，无需任何配置。当然你想使用自己的证书也是可以的。
 Multi-core 因为caddy是golang写的，所以当然可以合理使用多核啦。
 IPv6 完全支持IPv6环境.
 WebSockets Caddy 对WebSockets有很好的支持.
 Markdown 自动把md转成 HTML ，当然，我后续要给大家介绍更强大的hugo来干这个事情.
 Logging Caddy 对log格式的定义很容易，更好的满足你日志收集的需求。
 Easy Deployment 得益于go的特性，caddy只是一个小小的二进制文件，没有依赖，很好部署。
  那么在什么场景下适合尝试使用caddy呢，我推荐从以下场景开始：
 作为静态页面的webserver
 转发 fastcgi 请求到 php-fpm 服务，比如替换apache或nginx作为wordpress的server
 反向代理，管理多个站点
 微服务的 API gateway ，我会专门写一篇文章。
 有些在nginx上难以开发的需求，为caddy写插件太方便了。
  入门 安装caddy  下载 caddy</description>
    </item>
    
    <item>
      <title>redigo连接池代码分析</title>
      <link>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</link>
      <pubDate>Wed, 24 May 2017 09:17:35 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/redigo-lian-jie-chi-dai-ma-fen-xi.html</guid>
      <description>结构体分析 type Pool struct { // 用来创建redis连接的方法 Dial func() (Conn, error) // 如果设置了给func,那么每次p.Get()的时候都会调用改方法来验证连接的可用性 TestOnBorrow func(c Conn, t time.Time) error // 定义连接池中最大连接数（超过这个数会关闭老的链接，总会保持这个数） MaxIdle int // 当前连接池中可用的链接数. MaxActive int // 定义链接的超时时间，每次p.Get()的时候会检测这个连接是否超时（超时会关闭，并释放可用连接数）. IdleTimeout time.Duration // 当可用连接数为0是，那么当wait=true,那么当调用p.Get()时，会阻塞等待，否则，返回nil. Wait bool // 读写锁控制. mu sync.Mutex // 用来条件控制，这里主要是当链接被关闭时，提醒在等待的进程可以使用了，或者可以自行创建了 cond *sync.Cond // 当前连接池是否已经关闭 closed bool // 当前可用的链接数 active int // 链接存储在一个栈中. idle list.List }  连接池关闭方法 func (p *Pool) Close() error { p.mu.Lock() // 获取连接池所有链接栈 idle := p.</description>
    </item>
    
    <item>
      <title>ngrok从服务端跟踪所有HTTP请求并回放</title>
      <link>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</link>
      <pubDate>Wed, 24 May 2017 09:17:34 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/fen-xiang-yi-ge-xiao-gong-ju--boastru-he-cong-fu-wu-duan-gen-zong-suo-you--http-qing-qiu-bing-fang.html</guid>
      <description>客户端工程师：“xxx 接口坏了，我的程序都没动过”，后端经常会收到这样的质问，但是我们现在如何重现这个问题？有以下几种情况：
一、后端测试了一下发现没有问题
“我这里测试了是好的啊”，就只能让客户端工程师再操作一遍，亲眼看到错误之后就肯定是有问题了，就得去找问题，这时候这台手机，以及这台手机里面的数据都非常重要，因为这些数据可以让 Bug 重现。
二、测试了也有问题
这时候后端就去修改程序了，但是每一次的测试是否有问题都需要在客户端中操作，有时候的操作非常的复杂，在这上面花的时间会比较多。最后使了各种神通才终于找到问题，原来是这个用户的某某数据有异常才会出现这种情况。
以上这种情况屡见不鲜，最麻烦的点就在于，每次都要以出现 Bug 的相同参数去请求，有时候你知道这些请求的参数，可以把它们放到 Postman 这种工具里面，但大部分时候你并不知道它对应的参数 (token)
如果我们可以在服务端跟踪所有的请求：接口地址，Header，Body，后端返回的 Header、Body，这样我们就能查到对应的请求参数和返回值，可以直接填到 Postman 里面，要是还能一键重新请求就好了，因为我们不想修改请求的参数，只是想再以相同的参数请求一遍，这样我们来调试对应的程序。
正好以前用过 ngrok，发现它有一个非常好的 debug 界面，可以达到以上的要求，但现在不需要它的内网穿透功能，于是只能自己写一个程序，只包含以下功能：
 记录接口所有的 Request 和 Response
 可以一键重新请求某个 Request
  基本工作原理
HTTP 客户端 Boast Web 服务器 | GET http://localhost:8080/ | 记录请求并进行反向代理 | Response 200 OK | ---------------------------&amp;gt; | --------------------------&amp;gt; | ------┐ | | | | | | 记录返回信息并转发给客户端 | &amp;lt;----┘ | &amp;lt;--------------------------- | &amp;lt;-------------------------- | ┌----------------------------------------------------------------------------┐ | url: http://localhost:8081 | | ---------------------------------------------------------------------------| | All Transactions ┌ - - - - - - - - - - - - - - - - - - - - - - - ┐ | | ---------------------- | time: 10 hours ago Client: 127.</description>
    </item>
    
    <item>
      <title>协作式go程</title>
      <link>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</link>
      <pubDate>Wed, 24 May 2017 09:17:33 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/xie-zuo-shi-gocheng.html</guid>
      <description>协作式go程 为什么要协作式go程 考虑如下开发框架，一组网络接收goroutine接收网络包，解包，然后将逻辑包推送到消息队列，由一个单一的逻辑处理goroutine负责从队列中提取逻辑包并处理(这样主处理逻辑中基本上不用考虑多线程竞争的锁问题了)。
如果逻辑包的处理涉及到调用可能会阻塞的函数调用怎么办，如果在处理函数中直接调用这样的函数将导致逻辑处理goroutine被阻塞，无法继续处理队列中被排队的数据包，这将严重降低服务的处理能力。
一种方式是启动一个新的go程去执行阻塞调用，并注册回调函数，当阻塞调用返回后将回调闭包重新push到消息对列中，由逻辑处理goroutine继续处理后续逻辑。但我本人不大喜欢在逻辑处理上使用回调的方式(node的callback hell)。我希望可以线性的编写逻辑代码。
为了实现这个目的，我需要一个类似lua的单线程协作式coroutine调度机制，单线程让使用者不用担心数据竞争,协作式可以让coroutine在执行异步调用前将执行权交出去，等异步结果返回后再将执行权切换回来，线性的执行后续代码。
但是，goroutine天生就是多线程调度执行的，有办法实现这个目标吗？答案是肯定的。
我们可以实现一个逻辑上的单线程，从全局上看，只有唯一一个goroutine可以执行逻辑处理代码。核心思想就是由调度器从任务队列中提取任务，挑选一个空闲的goroutine,将其唤醒并让自己阻塞，当goroutine需要阻塞时就唤醒调度器并将自己阻塞。这样全局上就只有唯一的goroutine在执行逻辑代码。
下面是一个使用示例：
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; &amp;quot;coop-go&amp;quot; ) func main() { count := int32(0) var p *coop.CoopScheduler p = coop.NewCoopScheduler(func (e interface{}){ count++ if count &amp;gt;= 30000000 { p.Close() return } //调用阻塞函数 p.Call(func () { time.Sleep(time.Millisecond * time.Duration(10)) }) //继续投递任务 p.PostEvent(1) }) for i := 0; i &amp;lt; 10000; i++ { //投递任务 p.PostEvent(1) } p.Start() fmt.Printf(&amp;quot;scheduler stop,total taskCount:%d\n&amp;quot;,c2) }  首先用一个任务处理函数作为参数创建调度器。然后向调度器投递任务触发处理循环，最后启动处理。</description>
    </item>
    
    <item>
      <title>Golang里的Future_Promise</title>
      <link>https://yushuangqi.com/blog/2017/golangli-de-future_promise.html</link>
      <pubDate>Wed, 24 May 2017 09:17:32 +0800</pubDate>
      <author>ysqi@yushuangqi.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangli-de-future_promise.html</guid>
      <description>现如今，应用执行时最普遍存在的瓶颈就是网络请求了。网络请求只要几毫秒，但是等到返回却要百倍的时间。所以，如果你执行多个网络请求，让他们都并行执行就是减少延迟最好的选择了。Future/Promise就是实现这一目的的手段之一。
一个Future就是说“将来”你需要某些东西（一般就是一个网络请求的结果），但是你现在就要发起这样的请求，并且这个请求会异步执行。或者换一个说法，你需要在后台执行一个异步请求。
Future/Promise模式在多种语言都有对应的实现。比如ES2015就有Promise和async-await，Scala内置了Future，最后在Golang里有goroutine和channel可以实现类似的功能。下面给出一个简单的实现。
//RequestFuture, http request promise. func RequestFuture(url string) &amp;lt;-chan []byte { c := make(chan []byte, 1) go func() { var body []byte defer func() { c &amp;lt;- body }() res, err := http.Get(url) if err != nil { return } defer res.Body.Close() body, _ = ioutil.ReadAll(res.Body) }() return c } func main() { future := RequestFuture(&amp;quot;https://api.github.com/users/octocat/orgs&amp;quot;) body := &amp;lt;-future log.Printf(&amp;quot;reponse length: %d&amp;quot;, len(body)) }  RequestFuture方法理科返回一个channel，这个时候http请求还在一个goroutine后台异步运行。main方法可以继续执行其他的代码，比如触发其他的Future等。当需要结果的时候，我们需要从channel里读取结果。如果http请求还没有返回的话就会阻塞当前的goroutine，知道结果返回。
然而，以上的方法还有一点局限。错误无法返回。在上面的例子里，如果http请求出现错误的话，body的值会是nil/empty。但是，由于channel只能返回一个值，你需要创建一个单独的struct来包装两个返回的结果。
修改以后的结果：</description>
    </item>
    
  </channel>
</rss>