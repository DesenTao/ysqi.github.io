<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog-rsses on 虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/blog.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于in Blog-rsses 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <lastBuildDate>Fri, 17 Feb 2017 08:17:16 +0800</lastBuildDate>
    <atom:link href="/blog.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>TiDB架构的演进和开发哲学</title>
      <link>https://yushuangqi.com/blog/2017/tidb-jia-gou-de-yan-jin-he-kai-fa-zhe-xue.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:16 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/tidb-jia-gou-de-yan-jin-he-kai-fa-zhe-xue.html</guid>
      <description>https://segmentfault.com/a/
 本文来自 CSDN《程序员》2017 年 2 月的封面报道。
对于一个从零开始的数据库来说：选择什么语言，整体架构怎么做，要不要开源，如何去测试…太多的问题需要去考量。
 在本篇文章中，PingCAP 联合创始人兼 CTO 黄东旭对 TiDB 的开发历程进行了详细简介，为大家还原 TiDB 的架构演进全过程。
在大约两年前，我有一次做 MySQL 分库分表和中间件的经历，那时在中间件里做 sharding，把 16 个节点的 MySQL 扩到 32 节点，差不多要提前一个月做演练，再用一个礼拜来上线。我就在想，能不能有一个数据库可以让我们不再想分库分表这些东西？当时我们也刚刚做完 Codis，觉得分布式是个比较合适的解决方案。另外我一直在关注学术圈关于分布式数据库的最新进展，有看到谷歌在 2013 年发的 Spanner 和 F1 的论文，所以决定干脆就重新开始写一个数据库，从根本上解决 MySQL 扩展性的问题。
而决定之后发现面对的问题非常复杂：选择什么语言，整个架构怎么做，到底要不要开源……做基础软件有一个很重要的事情：写出来并不难，难的是你怎么保证这个东西写对了。尤其是对于业务方，他们所有的业务正确性是构建在基础软件的正确性上。所以，对于分布式系统来说，什么是写对了，怎么去测试，这都是很重要的问题。关于这些我想了很久。
一开始总是要起步的。当时就决定冷静一下，先确定一个目标：解决 MySQL 的问题。MySQL 是单机型数据库，它没有办法做全扩展，我们选择 MySQL 兼容，首先选择在协议和语法层面的兼容，因为已有的社区里边很多的海量的测试。第二点是用户的迁移成本，能让用户迁移得很顺畅。第三是因为万事开头难，必须得有一个明确的目标，选定一个目标去做，对开发人员来说心理的压力最小。确定目标以后，我们 3 个人的创始团队从原来的公司出来，拿了一笔比较大的风险投资，开始正式做这件事情。
兼容 MySQL 最简单的方案，就是直接用 MySQL。为了让这个东西尽快地做起来，我们一开始做了一个最简单的版本，复用 MySQL前端 代码，做一个分布式的存储引擎就可以了，这个事情想想还是蛮简单的，所以非常乐观，觉得这个战略很完美。
上图是我在 2015 年 4 月份用六个礼拜完成的第一个版本的框架，但是后来没好意思开源出来，虽然能跑，但是在性能上完全无法接受。我就想这个东西为什么这么慢？一步一步去看每一层，就想动手改，但是发现工程量巨大，比如 MySQL 的 SQL 优化器， 事务模型等等，完全没有办法下手。就像这个架构图里看到的，因为在 MySQL Engine 这一层，我们能做的事情太少了，所以就没有办法。
第一版实验到此宣告失败，现在看起来写 SQL parser 和优化器等这些已经是绕不开了，我们索性决定从头开始写，唯一给我安慰的就是终于可以使用我们最爱的编程语言了，就是 Go。
我们跟其他做这种软件的工程师的思路相反，选择了从上往下写，先写最顶层的 SQL 的接口 SQL Layer，我要保证这个东西长得跟 MySQL 一模一样，包括网络协议和语法层。从 TiDB 网络协议、SQL 的语法解析器、到 SQL 的优化器、执行器等基本从上到下写了一遍。这个阶段持续了大概三个月左右。从这个阶段开始，我们慢慢摸索出了几个实践中深有体会的开发哲学。</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:token</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-token.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:15 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-token.html</guid>
      <description>https://segmentfault.com/a/
前言 token package 包含了 golang 词法分析相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/token
token.go 源代码中的注释很赞！
Token type Token is the set of lexical tokens of the Go programming language
type Token int  tokens The list of tokens（token ids）
const ( // Special tokens ILLEGAL Token = iota EOF COMMENT literal_begin ... literal_end operator_beg ... operator_end keyword_beg ... keyword_end )  使用 const 定义了 Go 语言 tokens，这里有一个地方值得学习：使用 xxx_beg 和 xxx_end 这一对伪 token 作为不同的 token group 分界，方便快速判断 token 类型，比如判断 token id 是否是一个关键字</description>
    </item>
    
    <item>
      <title>Jsoniter0_9_8发布:JSON性能对标Protobuf</title>
      <link>https://yushuangqi.com/blog/2017/jsoniter-0_9_8-fa-bu--json-xing-neng-dui-biao--protobuf.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:15 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jsoniter-0_9_8-fa-bu--json-xing-neng-dui-biao--protobuf.html</guid>
      <description>Jsoniter 是一款快且灵活的 JSON 解析器，同时提供 Java 和 Go 两个版本。
最近发布的 0.9.8 版本对性能对标 Jackson 和 Protobuf 进行了详细的评测： https://github.com/json-itera&amp;hellip; 。性能优化的原理会近期会发布于 infoq 中文站，尽请期待。
同时提供 PHP 一般的体验。在 PHP 里，你只需要记得 json_decode ，什么文档都可以解析。现在在 Java 里，你也可以这么做了。
Any any = Jsoniter.deserialize(input); // deserialize 返回 &amp;quot;Any&amp;quot;，实际的解析是延迟在读取时才做的 any.get(&amp;quot;items&amp;quot;, &#39;*&#39;, &amp;quot;name&amp;quot;, 0); // 抽取所有 items 的第一个 name any.get(&amp;quot;size&amp;quot;).toLong(); // 不管是 &amp;quot;100&amp;quot; 还是 100 ，都给转成 long 类型，就像弱类型一样 any.bindTo(Order.class); // 把 JSON 绑定到对象 for (Any element : any) {} // 遍历集合， Any 实现了 iterable 接口  项目网站： http://jsoniter.</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:scanner</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-scanner.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:14 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-scanner.html</guid>
      <description>https://segmentfault.com/a/
前言 scanner package 包含了 golang 词法分析器相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/scanner
example_test.go example_test.go 包含了一个使用 scanner 包的示例方法，该方法对 Euler 公式进行词法扫描
func ExampleScanner_Scan() { // src is the input that we want to tokenize. src := []byte(&amp;quot;cos(x) + 1i*sin(x) // Euler&amp;quot;) // Initialize the scanner. var s scanner.Scanner fset := token.NewFileSet() // positions are relative to fset file := fset.AddFile(&amp;quot;&amp;quot;, fset.Base(), len(src)) // register input &amp;quot;file&amp;quot; s.Init(file, src, nil /* no error handler */, scanner.ScanComments) // Repeated calls to Scan yield the token sequence found in the input.</description>
    </item>
    
    <item>
      <title>使用Homebrew安装配置golang环境</title>
      <link>https://yushuangqi.com/blog/2017/shi-yong-homebrewan-zhuang-pei-zhi-golanghuan-jing.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:14 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shi-yong-homebrewan-zhuang-pei-zhi-golanghuan-jing.html</guid>
      <description>安装Homebrew 在Homebrew复制安装命令，在控制台运行完成安装
安装golnag $ brew update &amp;amp;&amp;amp; brew upgrade $ brew install go  PATH配置 创建一个目录作为gopath,在目录创建三个目录bin、src、pkg
$ cd ~ $ vim .bash_profile  编辑.bash_profile文件并保存，文件内容如下
export GOROOT=/usr/local/opt/go/libexec # GOPAT为上面创建的目录路径 export GOPATH=/Users/deweixu/coding/Go/go_path export PATH=$PATH:$GOROOT/bin:$GOPATH/bin  运行source .bash_profile使配置的PATH生效。
安装完成 运行go env查看安装效果：
$ go env GOARCH=&amp;quot;amd64&amp;quot; GOBIN=&amp;quot;&amp;quot; GOEXE=&amp;quot;&amp;quot; GOHOSTARCH=&amp;quot;amd64&amp;quot; GOHOSTOS=&amp;quot;darwin&amp;quot; GOOS=&amp;quot;darwin&amp;quot; GOPATH=&amp;quot;/Users/deweixu/coding/Go/go_path&amp;quot; GORACE=&amp;quot;&amp;quot; GOROOT=&amp;quot;/usr/local/opt/go/libexec&amp;quot; GOTOOLDIR=&amp;quot;/usr/local/opt/go/libexec/pkg/tool/darwin_amd64&amp;quot; CC=&amp;quot;clang&amp;quot; GOGCCFLAGS=&amp;quot;-fPIC -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/q3/kxp92gk548z_y9pc1n3qsztw0000gn/T/go-build078494854=/tmp/go-build -gno-record-gcc-switches -fno-common&amp;quot; CXX=&amp;quot;clang++&amp;quot; CGO_ENABLED=&amp;quot;1&amp;quot;  enjoy golang</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:cmdgo</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-cmd-go.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:13 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-cmd-go.html</guid>
      <description>https://segmentfault.com/a/
前言 命令行工具 go 相关的代码在 &amp;lt;go-src&amp;gt;/src/cmd/go，目录结构
&amp;lt;go-src&amp;gt;/src/cmd/go internal testdata alldocs.go go11.go go_test.go go_unix_test.go go_windows_test.go main.go mkalldocs.sh note_test.sh note_test.go vendor_test.go   main.go，入口函数
 *_test.go，单元测试代码
 internal，go 内部实现相关代码
  internal 目录下基本上按照 go &amp;ldquo;子命令&amp;rdquo; 进行组织，可以看到常用的子命令比如 help, list, run .etc
&amp;lt;go-src&amp;gt;/src/cmd/go internal base bug get help list run ...  main.go main.go 是 go 命令的入口，为了优雅的支持各种 &amp;ldquo;子命令&amp;rdquo;，main.go 将各个子命令对象保存在数组里，通过遍历数组找到具体的子命令，然后调用各个子命令的 run 方法
for _, cmd := range base.Commands { if cmd.Name() == args[0] &amp;amp;&amp;amp; cmd.</description>
    </item>
    
    <item>
      <title>Go1_8rc3源代码学习:parser</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-parser.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:13 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8rc3-yuan-dai-ma-xue-xi-parser.html</guid>
      <description>https://segmentfault.com/a/
前言 parser package 包含了 golang 语法分析相关的数据结构和方法，源代码位于 &amp;lt;go-src&amp;gt;/src/go/parser
之前大概看了点 PHP 和 Ruby 的源代码，感叹 go 确实如宣传的一样，简洁如 C，parser.go 代码总共 几千行（Ruby 语法规则定义文件有 1w 多行），使用递归下降语法分析方法（感觉 go 语言的语法规则很适合递归下降）
example_test.go parser package 里面也有一个示例 example_test.go，如何使用 parser
func ExampleParseFile() { fset := token.NewFileSet() // positions are relative to fset // Parse the file containing this very example // but stop after processing the imports. f, err := parser.ParseFile(fset, &amp;quot;example_test.go&amp;quot;, nil, parser.ImportsOnly) if err != nil { fmt.Println(err) return } // Print the imports from the file&#39;s AST.</description>
    </item>
    
    <item>
      <title>golang在编译时用ldflags设置变量的值</title>
      <link>https://yushuangqi.com/blog/2017/golangzai-bian-yi-shi-yong-ldflagsshe-zhi-bian-liang-de-zhi.html</link>
      <pubDate>Fri, 17 Feb 2017 08:17:12 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golangzai-bian-yi-shi-yong-ldflagsshe-zhi-bian-liang-de-zhi.html</guid>
      <description>我们经常会在一些程序的输出中看到程序版本、编译时间、Git的commit id等信息，比如docker
ming@vultr:~$ docker version Client: Version: 1.12.5 API version: 1.24 Go version: go1.6.4 Git commit: 7392c3b Built: Fri Dec 16 02:42:17 2016 OS/Arch: linux/amd64 ...  我们可以提供一个配置文件version.conf，程序运行时从version.conf取得这些信息进行显示。但是在部署程序时，除了二进制文件还需要额外的配置文件，不是很方便。 或者将这些信息写入代码中，这样不需要额外的version.conf，但要在每次编译时修改代码文件，也够麻烦的了。 有一种更好的办法是在编译时使用参数-ldflags -X importpath.name=value，官方解释如下
 -X importpath.name=value Set the value of the string variable in importpath named name to value. Note that before Go 1.5 this option took two separate arguments. Now it takes one argument split on the first = sign.</description>
    </item>
    
    <item>
      <title>老司机带你用Go语言实现Raft分布式一致性协议</title>
      <link>https://yushuangqi.com/blog/2017/lao-si-ji-dai-ni-yong--go-yu-yan-shi-xian--raft-fen-bu-shi-yi-zhi-xing-xie-yi.html</link>
      <pubDate>Wed, 08 Feb 2017 13:41:20 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/lao-si-ji-dai-ni-yong--go-yu-yan-shi-xian--raft-fen-bu-shi-yi-zhi-xing-xie-yi.html</guid>
      <description>老司机带你用 Go 语言实现 Raft 分布式一致性协议  随着大型网站的各种高并发访问、海量数据处理等场景越来越多，如何实现网站的高可用、易伸缩、可扩展、安全等目标就显得越来越重要。
 为了解决这样一系列问题，大型网站的架构也在不断发展。提高大型网站的高可用架构，不得不提的就是分布式。任何一个分布式系统都无法同时满足 Consistency（一致性），Availability（可用性），Partition tolerance（分区容错性）这三个基本需求，最多只能满足其中两项。 但是，一个分布式系统无论在 CAP 三者之间如何权衡，都无法彻底放弃一致性（Consistency），如果真的放弃一致性，那么就说明这个系统中的数据根本不可信，数据也就没有意义，那么这个系统也就没有任何价值可言。所以，无论如何，分布式系统的一致性问题都需要重点关注。
 Raft 适用于一个管理日志一致性的协议，相比于 Paxos 协议 Raft 更易于理解和去实现它。
上车  Raft 通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目，把日志条目复制到其他服务器上，并且当保证安全性的时候告诉其他的服务器应用日志条目到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如：领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可以宕机，可以和其他服务器失去连接，这时一个新的领导人会被选举出来。
 Raft 把时间分割成任意长度的任期，任期用连续的整数标记。每一段任期从一次选举开始，一个或者多个候选人尝试成为领导者。如果一个候选人赢得选举，然后他就在接下来的任期内充当领导人的职责。在某些情况下，一次选举过程会造成选票的瓜分。在这种情况下，这一任期会以没有领导人结束；一个新的任期（和一次新的选举）会很快重新开始。Raft 保证了在一个给定的任期内，最多只有一个领导者。
 要实现 Raft 协议，参见下图：
 Raft 协议将整个过程分为主要3个步骤：
 领导者：和其他一致性算法相比，Raft 使用一种更强的领导能力形式。比如，日志条目只从领导者发送给其他的服务器。这种方式简化了对复制日志的管理并且使得 Raft 算法更加易于理解。
 领导选举：Raft 算法使用一个随机计时器来选举领导者。这种方式只是在任何一致性算法都必须实现的心跳机制上增加了一点机制。在解决冲突的时候会更加简单快捷。
 关系调整：Raft 使用一种共同一致的方法来处理集群成员变换的问题，在这种方法中，两种不同的配置都要求的大多数机器会重叠。这就使得集群在成员变换的时候依然可以继续工作。
   后面将通过这3个主要过程进行展开。
发车（领导的选举）  Raft 使用一种心跳机制来触发领导人选举。当服务器程序启动时，他们都是跟随者身份。如果一个跟随者在一段时间里没有接收到任何消息，也就是选举超时，然后他就会认为系统中没有可用的领导者然后开始进行选举以选出新的领导者。要开始一次选举过程，跟随者先要增加自己的当前任期号并且转换到候选人状态。然后他会并行的向集群中的其他服务器节点发送请求投票的 RPCs 来给自己投票。候选人的状态维持直到发生以下任何一个条件发生的时候，(a) 他自己赢得了这次的选举，(b) 其他的服务器成为领导者，&amp;copy; 一段时间之后没有任何一个获胜的人。当一个候选人从整个集群的大多数服务器节点获得了针对同一个任期号的选票，那么他就赢得了这次选举并成为领导人。每一个服务器最多会对一个任期号投出一张选票，按照先来先服务的原则。
 Raft 使用投票的方式来阻止候选人赢得选举除非这个候选人包含了所有已经提交的日志条目。候选人为了赢得选举必须联系集群中的大部分节点，这意味着每一个已经提交的日志条目肯定在这些服务器节点中至少存在一个上面。如果候选人的日志至少和大多数的服务器节点一样新，那么他一定持有了所有已经提交的日志条目。请求投票 RPC 实现了这样的限制： RPC 中包含了候选人的日志信息，然后投票人会拒绝掉那些日志没有自己新的投票请求。
 Raft 通过比较两份日志中最后一条日志条目的索引值和任期号定义谁的日志比较新。如果两份日志最后的条目的任期号不同，那么任期号大的日志更加新。如果两份日志最后的条目任期号相同，那么日志比较长的那个就更加新。</description>
    </item>
    
    <item>
      <title>GB(一)</title>
      <link>https://yushuangqi.com/blog/2017/gbyi-.html</link>
      <pubDate>Wed, 08 Feb 2017 13:41:19 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/gbyi-.html</guid>
      <description>gb go语言基于项目的编译工具
  安装 =======  1.1 约束 gb 依赖Go1.4以上版本
1.2 安装 通过以下命令安装
go get github.com/constabulary/gb...  1.3 升级 gb 依然处于开发状态，通过以下命令升级到最新版本
go get -u github.com/constabulary/gb/...  1.4 多版本go的情况 对每一个go版本都安装gb
1.5 注意 安装完毕后的gb命令和oh-my-zsh配置的 git branch 简写命令有冲突，采用 ~/.zshrc中
unalias gb  来屏蔽
 项目 =======  gb基于项目。一个gb工程为一个编译单元，每个gb工程目录含有一个src/子目录，没有配置文件的设置，以下文档我们统称工程的目录为$PROJECT
2.1 自己的代码，第三方的代码 gb项目区分自己的代码和依赖的第三方代码。gb项目内，自己的代码放在
$PROJECT/src/  第三方代码放在
$PROJECT/vendor/src/  2.2 项目不在\$GOPATH下进行配置 gb项目不会跟$GOPATH有关系，
gb也不会采用go get来下载管理依赖；依赖的第三方库代码都应放在$PROJECT/vendor/src/ 目录下
gb项目也可以用go get来获取，但不能由go tools工具来构建，因为gb项目不遵循go get的约定
2.3 创建项目 创建一个gb项目也就是创建一个普通的文件目录：
% mkdir -p $HOME/code/demo-project  这个目录将作为gb项目的根目录，现在创建src/子目录来存放你自己的项目代码：</description>
    </item>
    
    <item>
      <title>Gox:简单实在的Go平台交叉编译工具</title>
      <link>https://yushuangqi.com/blog/2016/gox--jian-chan-shi-zai-de-goping-tai-jiao-cha-bian-yi-gong-ju.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:12 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/gox--jian-chan-shi-zai-de-goping-tai-jiao-cha-bian-yi-gong-ju.html</guid>
      <description>Gox 是一个简单的，不花俏的Go平台交叉编译工具，它的用处就和标准的 go build 一样。Gox 会并行地为多种平台编译。Gox 同时也提供了一套交叉编译工具链。
Gox 项目地址：https://github.com/mitchellh/gox
安装 为了安装 Gox，请使用 go get。我们已经为版本打上了标签，所以可以随便切换标签进行编译：
 \$ go get github.com/mitchellh/gox
&amp;hellip;
\$ gox -h
&amp;hellip;
 用法 在你使用 Gox 之前，你必须先有一套交叉编译工具链。Gox 可以自动帮你完成这个。你需要做的只是运行(每次更新 Go 都要这样做这步)：
 \$ gox -build-toolchain
&amp;hellip;
 当你完成这个，你可以已经准备好进行交叉编译了。
如果你知道怎么去使用 go build, 那么你也知道怎么去使用 Gox 了。例如，编译当前的项目，无需提供参数，只需要调用 gox。Gox 就会根据 CPU 的数量并行地为各个平台编译：
 \$ gox
Number of parallel builds: 4
&amp;ndash;&amp;gt; darwin/386: github.com/mitchellh/gox
&amp;ndash;&amp;gt; darwin/amd64: github.com/mitchellh/gox
&amp;ndash;&amp;gt; linux/386: github.com/mitchellh/gox
&amp;ndash;&amp;gt; linux/amd64: github.com/mitchellh/gox</description>
    </item>
    
    <item>
      <title>MacOS10_9[Mavericks]编译支持ZeroMQ4_0_1版本的gozmq</title>
      <link>https://yushuangqi.com/blog/2016/mac-os-10_9-mavericks-bian-yi-zhi-chi--zeromq-4_0_1-ban-ben-de--gozmq.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:12 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/mac-os-10_9-mavericks-bian-yi-zhi-chi--zeromq-4_0_1-ban-ben-de--gozmq.html</guid>
      <description>https://segmentfault.com/a/
下载 4.0.1 版本的 ZeroMQ 代码后解压到任意目录。
tar -xzvf zeromq-4.0.1.tar.gz cd zeromq-4.0.1 ./configure --prefix=/usr make make install go get -tags zmq_4_x github.com/alecthomas/gozmq  测试程序
package main import ( &amp;quot;fmt&amp;quot; zmq &amp;quot;github.com/alecthomas/gozmq&amp;quot; &amp;quot;os&amp;quot; ) func main() { major, minor, patch := zmq.Version() fmt.Printf(&amp;quot;Current 0MQ version is %d.%d.%d\n&amp;quot;, major, minor, patch) os.Exit(0) }  运行测试程序
$ go run version.go $ Current 0MQ version is 4.0.1  </description>
    </item>
    
    <item>
      <title>使用Go语言编写的跨平台的emlog整站(首页&#43;文章)静态化工具</title>
      <link>https://yushuangqi.com/blog/2016/shi-yong-goyu-yan-bian-xie-de-kua-ping-tai-de-emlogzheng-zhan-shou-xie-wen-zhang-jing-tai-hua-gon.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:12 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/shi-yong-goyu-yan-bian-xie-de-kua-ping-tai-de-emlogzheng-zhan-shou-xie-wen-zhang-jing-tai-hua-gon.html</guid>
      <description> emlog_static.go 项目地址： https://github.com/johnlui/emlog_static.go ====================
功能  新闻博客类非数据交互网站通用首页静态化 emlog博客系统文章页静态化 使用Go语言编写，跨平台  条件  需要能够管理服务器，需要编译、运行软件 需要Go语言编译环境，请去The Go Programming Language 下载  使用方法  两个文件单独编译，分别运行 emlog_static_homepage 首页静态化 使用方法为：
./emlog_static_homepage -url=http://example.com/index.php -t=30
t为间隔时间，单位是秒
 emlog_static_articles 文章页静态化 使用方法为：
./emlog_static_articles -url=http://example.com/index.php -c=10 -n=100
c为并发数，n为总文章数，即文章id最大值
  </description>
    </item>
    
    <item>
      <title>使用golang在与数据库访问过程中的一点想法</title>
      <link>https://yushuangqi.com/blog/2016/shi-yong-golangzai-yu-shu-ju-ku-fang-wen-guo-cheng-zhong-de-yi-dian-xiang-fa.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:11 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/shi-yong-golangzai-yu-shu-ju-ku-fang-wen-guo-cheng-zhong-de-yi-dian-xiang-fa.html</guid>
      <description> https://segmentfault.com/a/
遇到的问题 golang对于基本类型初始化的处理，是自动给基本类型赋值为默认值。比如：
var i int//在这里如果不对i做任何赋值，那么i的值为零  这个特性在很多地方能够避免访问到未初始化变量的尴尬，但是由此也引出了另外一个问题，就是在进行数据库访问操作时应该如果对待这样的默认值。
现在我们假设一个场景，表A有3个字段{AID int,AField1 string,AField2 string}，表B也有3个字段{ID int,BField1 string,REF_AID int}，其中表B中的REF_AID是外键对应表A中的AID。对应在GO中的数据结构应该为：
type A struct{ AID int//主键 AField1 string AField2 string } type B struct{ BID int//主键 BField1 string REF_AID int//外键，对应AID }  在new对象B的时候，B中的三个值就分别被默认的初始化为{0,&amp;ldquo;&amp;rdquo;,0}，如果此时不对内容做任何操作，直接执行插入，问题就可能会变得很严重，因为A中很可能并没有任何一条记录的ID值为0，数据库报错，这条插入是一定会失败。但是仅仅在数据库层面上来看，数据库的结构是没问题的，表B中的REF_AID可以为空，在其他的语言中，如果没有对具体数据进行初始化，该属性会为空，对应插入的时候也会为空，但是在golang中，由于语言级别的默认初始化，使得这个插入过程会有大量的0的存在，触犯到原本表的约束规则而导致插入失败。
在orm中也没有看到能够解决这个问题的办法，可能是我用的不够仔细，这个留待以后再说。
自己的一点想法  把所有的数据库中相关的表都添加一条默认的以0为id的记录，该记录不需要有意义，只是用来防止歧义以及违反约束引起的操作失败，特别是一些ref_表，因为其中数据变动不大，却经常与其他一些表存在外键关系。这样做会给数据库带来一些额外的开销，但是作为一个临时的解决办法似乎还不错，至少能让数据处理流程正确的运行。 从orm中解决问题。这个只是一个想法，不过这很可能变成一种无理的要求，因为这需要orm去判断你的Field中存放的这个0到底是你自己就想指定的0值，还是你不想要却被语言默认初始化出来的0。 自己写SQL语句执行，这可能是最傻的一种方法了，不过却能保证事情完全按照自己的想法执行。  </description>
    </item>
    
    <item>
      <title>深入GoPlayground内幕</title>
      <link>https://yushuangqi.com/blog/2016/shen-ru--go-playground-nei-mu.html</link>
      <pubDate>Sat, 31 Dec 2016 11:35:10 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2016/shen-ru--go-playground-nei-mu.html</guid>
      <description>简介 2010年9月，我们介绍了Go Playground，这是一个完全由Go代码组成和返回程序运行结果的web服务器。
如果你是一位Go程序员，那你很可能已经通过阅读Go教程或执行Go文档中的示例程序的途径使用过Go Playground了。
你也可以通过点击 talks.golang.org上幻灯片中的“Run” 按钮或某个博客上的程序(比如最近一篇关于字符串的blog)而使用之.
本文我们将学习Go playground是如何实现并与其它服务整合的。其实现涉及到不同的操作系统和运行时间，这里我们假设大家用来编写Go的系统都基本相同。
概览 
playground服务有三部分：
* 一个运行于Google服务之上的后端。它接收RPC请求，使用gc工具编译用户程序，执行，并将程序的输出（或编译错误）作为RPC响应返回。
* 一个运行在 GAE上的前端。它接收来自客户端的HTTP请求并生成相应的RPC请求到后端。它也做一些缓存。
* 一个JavaScript客户端实现的用户界面，并生成到前端的HTTP请求。
后端 后端程序本身很简单，所以这里我们不讨论它的实现。有趣的部分是我们如何在一个安全环境下安全地执行任意用户代码，于此同时还提供如时间、网络及文件系统等的核心功能。
为从Google的基础设施隔离用户程序，后端将它们运行在原生客户端（或“NaCl”）中，原生客户端（NaCl）—一个Google开发的技术，允许x86程序在Web浏览器中安全执行。后端使用一个能生成NaCl可执行文件的特殊版gc工具。
（这个特殊的工具将合并到Go 1.3中。想了解更多，阅读设计文档。如果你想提前体验NaCl，你可以检出一个包含所有变更的分支。）
本地客户端会限制程序占用CPU和RAM的使用量,此外还会阻止程序访问网络和文件系统。然而这会导致一个问题，Go程序的许多关键优势，比如并发和网络访问。此外访问文件系统，对于许多程序也是至关重要的。我们需要时间功能，才展现高效的并发性能。显然我们需要网络和文件系统，才能显示出来访问网络和文件系统方面的优势。
尽管现在这些功能都被支持了，但是2010年发布的第一版playground时，没有一项被支持的。当前时间功能是在2009年11月10的被支持的，可是 time.Sleep 却不能使用，而且多数与系统和网络有关的包都不被支持的
一年后，我们在playground上面实现了一个伪时间，这才使得程序可以有个正确的休眠行为。较新的playground更新引入了伪网络和伪文件系统，这使得playground的工具链与正常的Go工具链相同。这些新引入的功能会在下面具体阐述。
伪时间 playground里面的程序可用CPU时间和内存都是有限的。除此以外程序实际使用时间也是有限制的。这是因为每个运行在playground的程序都消耗着后台资源，以及占据客户端和后台间的基础设施。限制每个程序的运行时间让我们的维护更加可遇见，而且可以保护我们免受拒绝服务攻击。
但是当程序使用时间功能函数的时候，这些限制将变得非常不合适。在 Go Concurrency Patterns 讲话中通过一个例子来演示这个糟糕的问题。这是一个使用时间功能函数比如 time.Sleep 和time.After的例子程序，当运行在早期的playground中时，这些程序的休眠会失效而且行为很奇怪（有时甚至出现错误）
通过使用一个高明的小把戏，我们可以使得Go程序认为它是在休眠，而实际上这个休眠没有花费任何时间。在介绍这个小把戏之前，我们需要了解调度程序是管理goroutine的休眠的原理。
当一个goroutine调用time.Sleep（或者其他相似函数），调度器会在挂起的计时器堆中添加中增加一个计时器，并让goroutine休眠。在这期间，一个特殊的goroutine计算器管理着这个堆。当这个特殊的goroutine计算器开始工作时，首先，它告诉调度器，当堆中的下一个挂起的计时器准备计时的时候唤醒自己，然后它自己就开始休眠了。当这个特殊计时器被唤醒后首先是检测是否有计时器超时了，如果有那么就唤醒相应的goroutine，然后又回到休眠状态。
明白了这个原理后，那个小把戏只是改变唤醒goroutine的计时器的条件。调度器并不是经过一段时间后进行唤醒，而且仅仅等待一个所有goroutines 都阻塞的死锁产生后就进行唤醒。
playground运行时版本中维护着一个内部时钟。当修改后的调度器检测到一个死锁，那么它将检查是否有一些挂起的计时器。如果有的话，它会将内部时钟的时间调整到最早计时器的促发时间，然后唤醒goroutine计时器。这样一直循环往复，程序都认为时间过去了，而实际上休眠几乎没有耗时。
这些调度器的改变细节详见 proc.c 和 time.goc。
伪时间解决了后台资源耗尽的问题，但是程序的输出该怎么办呢？看见一个在休眠的程序，却几乎不耗时地正确完成工作了，这是得多么的奇怪啊！
下面的程序每秒输出当前时间，然后三秒后退出.试着运行一下。
func main() { stop := time.After(3 * time.Second) tick := time.NewTicker(1 * time.Second) defer tick.Stop() for { select { case &amp;lt;-tick.</description>
    </item>
    
  </channel>
</rss>