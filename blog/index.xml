<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog-rsses on 虞双齐Golang开发与SRE运维</title>
    <link>https://yushuangqi.com/blog.xml</link>
    <description>在 虞双齐Golang开发与SRE运维上关于in Blog-rsses 的内容</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <managingEditor>devysq@gmail.com (虞双齐)</managingEditor>
    <webMaster>devysq@gmail.com (虞双齐)</webMaster>
    <lastBuildDate>Tue, 21 Feb 2017 13:20:04 +0800</lastBuildDate>
    <atom:link href="/blog.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>深度学习第一课</title>
      <link>https://yushuangqi.com/blog/2017/shen-du-xue-xi-di-yi-ke.html</link>
      <pubDate>Tue, 21 Feb 2017 13:20:04 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shen-du-xue-xi-di-yi-ke.html</guid>
      <description>近几年深度学习的概念非常火，我们很幸运赶上并见证了这一波大潮的兴起。记得2012年之前提及深度学习，大部分人并不熟悉，而之后一段时间里，也有些人仍旧持怀疑的态度，觉得这一波浪潮或许与之前sparse coding类似，或许能持续火个两三年，但终究要被某个新技术新方法所取代，再后来，无论是学术界还是工业界，总有些研究者为自己没有在第一时间跟进这波浪潮感到后悔莫及。确实，从2012年AlexNet取得ImageNet的冠军开始，五年过去了，深度学习的方法仍旧占领着人工智能这片领域。
随着这波浪潮，有些人作为弄潮儿，兴起一波波巨浪，引领各个领域从传统方法到深度学习方法的转变，并希望能够通过了解其他领域的方法改进自己所从事的领域；有些人辛勤地工作，利用深度学习的方法为公司提高业绩，希望实时跟进并实现最新的技术；有些校园中的研究僧，一方面需要了解最新技术及其背后原理，另一方面还有发文章和找工作的压力；有些相关从业者，如编辑、记者，经常报道AI领域新闻，却从没有时间仔细研究深度学习；还有些非技术人员，总会在这些新闻后惊恐地询问“天网是否能在有生之年建成?”或是“AI对人类的威胁到了什么程度?”。
仅仅通过一节课程，或是一本书来解决以上所有问题明显是不可能的。鉴于国内机器学习资料还是偏少，而且大多是理论性质，并没有实践模块，我们从去年年底开始着手写一本深度学习相关的tutorial，并希望通过一章章真实的案例来带大家熟悉深度学习、掌握深度学习。这个tutorial中每一章内容都围绕着一个真实问题，从背景介绍到使用PaddlePaddle平台进行代码实验，完整地让大家了解整个问题如何用深度学习来解决，从此告别纸上谈兵。参加本次活动之前，没有想到这次报名人数之多。看了下报名群中的同学不乏一些高端用户，于是我知道本篇课程必然要要一些同学失望了，因为这一讲作为第一讲，只能考虑到大多数用户，设计成难度适中的课程，为大家提供一些深度学习最基本的概念，以便更轻松地入门深度学习。如果您是高端用户(能自己run起来深度学习模型或做过一些常识)，建议您可以直接移步tutorial自学，当然如果感兴趣，欢迎继续关注我们系列的后续课程。
首先，对这个系列的后续深度学习课程做一个预告。在这份tutorial中，我们将覆盖如下内容：
 新手入门 识别数字 图像分类 词向量 情感分析 文本序列标注 机器翻译 个性化推荐 图像自动生成  本节课程中，我们主要带大家了解深度学习，通过它的一些有用或有趣的应用了解深度学习的基本原理和工作方式。
一、深度学习是什么 传统的机器学习中，我们要为每种任务定义其特定的解决方案。对于图像，曾经人们耗费大量精力设计各种描述子进行图像特征描述；对于文本，单单一个机器翻译任务就动辄多个模型的设计：如词语对齐、分词或符号化（tokenization）、规则抽取、句法分析等，每一步的错误都会积累到下一步，导致整个翻译结果不可信，且要追查一个错误会非常复杂。 深度学习的优势，就是可以弥补以上问题，一方面减少了对大量手工特征的依赖，对于图像文本等领域可以直接从原数据进行建模；另一方面通过端到端的网络模型（即一个网络直接从输入到输出建模，而不需要中间步骤）减少了多步骤中错误累积的问题。
深度学习采用多层神经网络的方法，依赖大数据和强硬件。
 大数据
在这个数据爆发的时代，普遍的认知是，大数据并不是问题。但实际上也不完全是这样。从领域角度，图像的通用分类和语言模型的训练或许可以从搜索引擎中获取大量样本，但对于细粒度图像分类（如不同类型的花的分类）或是 专业领域的对话数据（如法律咨询类）的数据就比较稀缺；从应用方法角度，图像、文本和语音都方便获取，但如果希望进行有监督训练，就必须有对应的标记（label），如标明一段语音对应的人，或是一段语音对应的文本，这就是个大工程了。这就需要我们利用已有资源，最简单的方法比如可以先利用大量无标记数据学习数据的特征，就可以减少数据标注规模。
 强硬件
由于深度学习需要强计算处理能力，因此需要GPU显卡进行并行加速，拼硬件已经成为学界和工业界在研究深度学习网络时的一大共识。在2016年期间，英伟达和AMD的股票价格都实现了飞涨，如下图是GPU制造商英伟达(NVIDIA)公司今年的股价趋势。可以说这种跳跃式增长得益于GPU芯片在游戏、虚拟现实、自动驾驶、数据中心等各个高性能计算需求领域的应用。
GPU的每个显卡具有多个（通常是几十个）多处理器(Streaming Multiprocessors, SMs)，每个多处理器中有上百个CUDA核。一个多线程程序的一个kernel实例在一个SM上执行，一个kernel实例上的操作会分配到不同cuda核中独立执行。所以只要程序分配得当，GPU中的处理器越多执行越快。如Titan X(GM100)显卡拥有24个多处理器，每个多处理器拥有128个CUDA核，整个显卡有3072个CUDA核， 其相对16核Xeon E5 CPU处理器要加速5.3~6.7倍[1]，这对于实时性要求较高的应用意义非凡。
  二、深度学习的应用 深度学习可以涵盖很多应用范围，我们这里可以先以几个有意思的应用，给大家一个基本概念， 工业界常用的例子会在后续课程中详细地举例。
极简版无人车 无人车概念近几年很火，从传统领域到互联网企业都多少有这个方向的研究者。对于初步接触神经网络的同学，我们先引入一个小任务。如下图所示为一个可遥控小车在车道上的运行轨迹，小车上方搭载GoPro摄像头。图中蓝线表示垂直基准线，红线表示每一时刻小车应驶方向。我们的目标是，基于人为操控小车的行驶方向和当前图像数据，给出其驾驶方案。
这里，可以用神经网络指定网络的输入输出分别是当前图像和应走的方向，整体作为一个回归问题来处理，其中输入图像用多层卷积神经网络来解析。这里可能有朋友会说，其实我只需要用基本图像处理技术（比如二值化图像后再检测连通域）找出来左右两条车道，再向前方车道线中点位置方向走不就行了吗？确实是可以这么干的，我们这里只是为了说明深度学习的端到端训练，举例个最简版的无人车，有清晰的车道线，并且没有红绿灯、障碍物等干扰。实际情况中，需要考虑跟踪前车、车道保持、障碍物检测、红绿灯检测等多种情况，因此需要多模型的设计和集成。单就最简单情况下车道检测的这个事情来说， 确实可以仅通过图像处理+人工策略达成目的，也不需要什么训练数据，但这就要求程序员每遇到一个badcase都需要人工修改策略，这样等下一位程序员接手这段代码的时候，就只能呜呜呜了。
拍摄照片油画化 2015年的一篇文章[5]，将艺术家梵高和深度学习联系在了一起，文中实现了将艺术画style附体于日常拍摄照片，从而得到“艺术照”的效果。其做法是设计一个神经网络，定义该网络的损失函数为Diff(拍摄照片，生成作品) 与 Diff(艺术画，生成作品)这两个Diff的加权和。其中Diff表示两幅图片的差异。但如果通过每个像素的差异来计算这个Diff的话，显然不合理，对于拍摄照片和生成作品而言，像素值必然已经大变，而对于艺术画和生成作品而言，可能色调相似，但靠单个像素值去比就肯定是相差甚远了。所以我们其实想要的只是一个抽象的概念，如下图的例子，我们只需要生成的图包含“猫”，且画风和中间的艺术照相似。于是采用了神经网络的隐层作为度量他们Diff的空间。
图片转载自： http://phunter.farbox.com/post/mxnet-tutorial2
机器翻译 刚才的两个例子都是深度学习在图像中的应用，其在文本中同样意义重大。和图像不同的是，文本作为一个序列化信息，深度神经网络对这样数据的的处理和图像不太相同，但除此之外的基本思路就可以相互迁移了。比如已经了解了通过深度学习进行图像分类的方法，那么文本分类只是变化一下，将一短文本映射成特征向量从而进行分类，这可以通过将理解图片的卷积神经网络改为处理序列信息的循环神经网络完成。类似地，机器翻译（用计算机来进行不同语言之间的翻译）也可以通过类似的方法。以通过深度学习进行中译英为例，首先通过一个循环神经网络理解一句汉语（映射为文本语义信息，可以是一个向量，也可以是一个时序信息），称此过程为“编码”，再将这个文本语义信息通过另一个循环神经网络，每个时刻输出一个英语单词，称此过程为“解码”，通过这样的编码-解码结构即完成了机器翻译。我这里只是白话说出了机器翻译的大概思想，感兴趣的同学可以参考机器翻译一章的tutorial或追踪后续课程。
为你写诗 看完以上内容，如果想让你根据一个词创作一首诗，你想能怎么做呢？恐怕已经有同学想到了：用翻译的做法写诗。不错，机器翻译其实可以用到很多地方，只需要修改数据集就ok，如果我们想根据一个词，让机器“创作”一首诗，只需要将翻译模型的输入设置为这个词，而输出是诗句即可。不过，通常这么做是有问题的，因为这样做导致输入序列很短而输出很长，其间的依赖并不能充分发挥出来，硬将这样的两个序列绑在一起可能导致机器强硬地“背”下来如输入语料而没有真正理解语义。因此，有的工作中用短语生成第一句诗词，用第一句去生成第二句……；或者可以用前n-1句生成第n句诗词。感兴趣的同学可以自己试一下，也可以试用一下度秘里面写诗模块。
商品推荐 商品推荐是电商和新闻客户端们的关注热点，他们都关注用户兴趣的把控，其推荐系统的好坏往往会对用户留存和购买情况有较大影响。这里我们可以想见，最基本的推荐策略是爆款推荐（全民热点），和已浏览或是购买/收藏了的项目。对于大量用户没有过浏览记录的项目，传统推荐方法一般采用协同过滤，即推荐给用户相似用户的兴趣项，另一种方法是通过基于内容过滤推荐，即推荐给用户浏览项目的相似项，这其中就涉及到用户相似度和产品/项目相似度的获取。一方面，我们可以利用深度学习进行其相似度的建模，另一方面，我们还可以将用户特征和产品/项目特征映射到一个相同的空间进行特征比较，也就是将下图A（协同过滤）和B（基于内容过滤）策略改为C。
三、深度学习的缺陷 说过了神经网络的牛逼之处，我们再来看看它的一些缺陷，至少是目前难以解决的问题。
特斯拉事件 关注特斯拉的同学应该都有注意到，去年一位23岁的中国男青年，在驾驶特斯拉电动汽车沿京港澳高速河北邯郸段公路行驶时，前车躲避障碍物后，该男子躲闪不及撞上了道路清扫车，发生严重车祸导致死亡。
特斯拉官方并没有公布过其内部算法，我们只知道特斯拉的自动驾驶系统Autopolit中曾有以色列Mobileye公司提供的技术。Mobileye是一家基于视觉帮助减少交通事故的公司，其研发多年的高级驾驶辅助系统（ADAS）处于业内领先，主要基于单目摄像头传回的图像，通过深度神经网络进行车辆检测、车道识别等[3]。但Mobileye自己也表示曾经提醒过特斯拉公司，他们的这套系统只能起辅助作用， 并不完善，也不能完全保障车主。虽然特斯拉官方声明由于车主家属不愿提供更多信息，导致具体Autopolit错误原因无从定位，但原因或是因为中国独有的道路清扫车不曾出现在单目视觉的训练数据集，或是因为光照等特殊因素导致的图像质量问题，都说明无法仅通过视觉技术保障自动驾驶的安全性。我们不能将这起事故归结于是深度学习的缺陷，但在实际系统中， 我们目前确实难从一个端到端的系统中完全定位并解决问题，大家还可以看下面的例子进一步理解。
可解释性 在之前的“深度学习是什么”这一节中，我们讲到深度学习可以利用端到端的学习避免一些多步骤积累错误导致的问题，然而这其实也是一种缺陷。我们无从定位问题出在哪里。下面就以图像分类的一个badcase为例进行说明。
ImageNet竞赛2012年冠军工作AlexNet的作者Krizhevsky 曾提出，虽然AlexNet效果很棒，但为了最优化该数据集上的效果，不得不建立这样一个含有非常多参数的深度神经网络，而这样的网络非常容易过拟合。在15年的CVPR会议中，Anh Nguyen提出了一种生成样本的方法，该方法生成的样本可以“愚弄” 用于图像识别的深度神经网络[4]，如下图所示的8幅图下面标注的文字分别为ImageNet竞赛数据集上效果最好的网络对该图的识别结果（置信度高于99.6%）， 该网络将我们认为的这些波纹分别识别成了王企鹅、海星、棒球、电吉他、火车车厢、遥控器、孔雀、非洲灰鹦鹉。这种很容易“愚弄”神经网络的样本，被称为对抗样本。</description>
    </item>
    
    <item>
      <title>架构感悟-从美国宪法学习架构设计原则</title>
      <link>https://yushuangqi.com/blog/2017/wo-de-jia-gou-gan-wu-cong-mei-guo-xian-fa-xue-xi-jia-gou-she-ji-yuan-ze.html</link>
      <pubDate>Tue, 21 Feb 2017 13:20:00 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/wo-de-jia-gou-gan-wu-cong-mei-guo-xian-fa-xue-xi-jia-gou-she-ji-yuan-ze.html</guid>
      <description>2017年1月20日注定是一个会在历史上留下记录的日子，美国第45任总统Donald Trump宣誓就职。他的就职宣誓词非常简短：
 I do solemnly swear that I will faithfully execute the office of President of the United States, and will to the best of my ability, preserve, protect and defend the Constitution of the United States.
 令人惊讶的是，自从1787年美国宪法在费城制宪会议通过以来，在宪法第二条第一款中规定的总统宣誓词，竟然历经230年，从未变化。
从一个架构师的角度来看：合众国宪法作为美国这个国家的基础架构，从发布到现在200多年，美国也从13个州发展成50个州，人口从380万增长到3.2亿，时代早已发生剧变，但是美国政治的核心架构基本未变，这个系统的运行状况堪称良好。当年那群“架构师”，实在是了不起。（虽然他们当年的底气相当不足，华盛顿认为，这部宪法能维持20年就不错了）
如果，我们想要设计出这样的一个架构，能够长期适应需求与环境变化，能够历久弥新并始终稳定可靠，那么了解一下美国宪法的制定过程，其实是一件非常有价值的事情。
重构都是被逼的 有几个时间点，现在看来，其实颇为令人诧异：1776年7月4日，美国以发布《独立宣言》为标志宣布独立。1783年9月3日英美签订《巴黎和约》，独立战争结束。但是一直到1787年9月15日，一众国父们才在费城签署了《美利坚合众国宪法》。也就是说：一个独立的国家，在运行了11年后，才有了自己的宪法！而且又过了2年，直到1789年这部宪法获得各州的批准之后，华盛顿才被依法选为第一任美国总统。
可以说，在长达13年的时间里，这个国家没有总统，没有中央政府，没有一点国家的样子。我们不禁要问一句：早干嘛去了？打仗期间忙不过来，尚且可以理解。战争结束之后的6年，他们在干嘛？
事实上，1777年11月19日大陆会议通过的《邦联条例》，可以算是这个国家的beta版架构。但在上线运行10年之后，实在是撑不住了。首要的问题，是因为钱，独立战争结束，各州拖欠了士兵数百万美元的军饷，同时还拖欠了一些欧洲国家的钱，但是，这个国家一穷二白没办法还钱（还记得技术债务吗？）。这个国家也没有全国性的货币体系，在不同的州，一美元的价值竟相差4倍！由此引发的，是很多人破产甚至被投入监狱。退伍士兵谢司领导了一场起义，兵力甚至高达1万5千人，虽然最后被镇压了。但是，整个国家都陷入了严重的恐慌，一个新兴的、刚刚独立的国家，是不是就要完蛋了？
用架构师的语言描述就是：一个临时性的架构勉强上线运行，如果再不做架构改造，推出新版本，这个系统就要彻底宕机了。虽然大家都不清楚新版本应该是什么样子，但是必须得有一个新版本了！然而当时的美国各州，都喜欢去中心化的、互不相干的分布式架构，对于可能出现的集中式架构，深感警惕。要他们商量出一个一致同意的新架构，将会异常艰难&amp;hellip;&amp;hellip;
但是，另一个值得思考的问题是：拥有先见之明的天纵奇才、提前制定出明见万里、高瞻远瞩式的架构，真的靠谱吗？
显而易见的观点，可能并不正确 当时的欧洲，有很多人也在关注这次大会。按照欧洲人的看法：民主共和的政体，只适合于像瑞士那样的小国家。对于美国这么大的国家而言，只能是选择君主制。因此，那些美国人之所以要关起门来讨论，估计是在商量：到底是请哪一位君主到美国去当国王，会比较合适。更有好事者，连候选人都想好了：要么是普鲁士的亨利王子，要么是英国的弗雷德里克·奥古斯塔斯王子。
当时的美国人，有很多人抱着完全相反的另一种观点：不要有国王，甚至连中央政府都最好没有！他们之所以打了一场独立战争，就是为了从英国的统治下，解放出来。在获得了自己的独立、自由之后，他们立马就各回各家了。过自己的日子不挺好吗？为啥还要立宪？还要成立一个凌驾于各州之上的中央政府？大家受到英国的奴役，还不够吗？
对于提议召开此次大会的组织者而言，尤其是对于美国宪法之父，已经准备好了弗吉尼亚方案的詹姆斯·麦迪逊而言，美国这个国家，已经到了最危险的时候，必须有一个强有力的中央政府，十三个州政府再也不能像过去一样，一盘散沙了。时年35岁的麦迪逊，已经通读了当时几乎所有的政治相关著作，并且在去开会前，带上了几百本书和报纸，准备回答可能遇到的一切疑问和质询。
事情当然没有那么简单，一场大会从5月25日开到了9月17日，整整116天！期间有无数次，某些代表、甚至所有的与会代表，都深感沮丧和绝望，感觉这个会开不出结果来了。究其原因，实在是因为问题太过复杂，代表们的分歧太大造成的。事实上，他们所做的事情，是要写出人类历史上的第一部成文宪法。而且这个国家，与历史上的任何国家，都大不相同。就好比我们打算做一个架构设计，却几乎找不到任何可供参考的案例。任何已经存在的方案，显而易见的观点，各种类比与参考，都无法理所当然的直接借鉴。
换言之，我们在开始一个架构设计时，最需要警惕的，恰恰是那种显而易见的观点和方案，因为很可能是错误的。
会议程序的价值 在阅读制宪会议的这段历史时，最令我感兴趣的，是他们的一些会议程序设计，非常有意思。
5月25日，开会第一天，大会选举了乔治·华盛顿为大会主席。然后，在5月29日大会决定采取全体委员会的形式，另选了一个人，做了全体委员会的主席。此后，华盛顿便只在每天开会和散会时，上台就主席座，宣布会议开始与会议结束。其余时间，他都坐在弗吉尼亚代表团的桌子旁，以普通代表身份参加讨论。
这种会中会的玩法，据说是能够给讨论，留下缓冲的余地。
第二个程序设计，是代表们一致同意，在大会过程中有权改变决议，而不是讨论投票表决，就结束了。任何代表都可以要求对任何议题或决定进行重新讨论，而且他们经常这么做！整个大会，一共有569次表决，很多议题会被反复讨论。例如关于总统选举的办法，就一共有60次投票表决。因此，他们又制定了一个保密规定，任何人，不得对外透露大会的事情。
为何要采用这样一种反复讨论、表决，而且对外保密的做法？在40年后，麦迪逊才解释了原因：如果大会对外公开的话，任何代表之后都不会改变自己的主张，这样做就意味着公开承认自己原来是错误的。如果这样，那么这次大会，就可能会失败。
第三个程序设计，也是一个会中会的形式。在会议遇到重大分歧时，他们会另外任命一个小型的、专门的委员会，首先让这个委员会在小范围里讨论出推荐方案，表决通过，再提交大会讨论和表决。下文将会介绍“伟大的妥协”，就是一个委员会的努力工作的产物。
追根溯源来说，这些开会的艺术，其实是英国政治文化的优秀遗产。一群无论是智力还是见识，都仅仅只能算平庸的人，要想把一个非常复杂的问题讨论清楚，只能尽可能保持耐心、保持克制、充分讨论、反复表决，只有这样，才有可能达成共识，也才有可能获得尽可能好的结果。
虽然，我们不能想象一个系统的架构设计，也像这样一口气开3~4个月的会。但是：在讨论问题的过程中，集思广益，反复权衡，参与争论的各方，也能够心平气和、就事论事、不翻旧帐（你昨天不还是反对的吗？上次你那个设计就有问题！）对于获得良好的架构，也应该会有很大的帮助。
妥协（不埋雷）的艺术 在架构设计的过程中，我们通常会面临各种复杂的、甚至是相互矛盾的需求，在追求设计的品质时，理想主义与现实主义也会存在冲突。如果紧紧守住自己的意见，毫不妥协，通常连一个架构方案都拿不出来。但是，在权衡与妥协的时候，一味的期望消弭冲突，或者求同存异，都可能会埋下地雷，在系统上线运行之后，日积月累、酿成大祸！
在这次的制宪会议上，代表们达成了很多的妥协。其中“有名有姓”、载入史册的重大妥协有三项：关于大州和小州之间在议会中席位数多寡的妥协，这项妥协干脆就被史家们称做“伟大的妥协”（The Great Compromise）；其次是南方州和北方州之间关于奴隶是否有选举权的妥协，“五分之三妥协”（The three-fifths compromise）；再者是与南、北方经济利益冲突相关的、关于国会管理新大陆商业贸易权限的妥协，“商业妥协”（The commerce compromises）。</description>
    </item>
    
    <item>
      <title>计算机专业必读书籍</title>
      <link>https://yushuangqi.com/blog/2017/ji-suan-ji-zhuan-ye-bi-dou-shu-ji.html</link>
      <pubDate>Tue, 21 Feb 2017 13:19:55 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/ji-suan-ji-zhuan-ye-bi-dou-shu-ji.html</guid>
      <description>石头经过高考后20天的思考，终于将自己的专业金融经济改成了计算机，这个决定由衷的让我一阵窃喜。从事了20多来年计算机出版和市场推广的我，看到象石头一样的少年，成为新一代程序员，心里非常自豪又能给下一代孩子们做学习计算机技术的引路人，推荐一些好书了。
对于刚高考完的孩子们，既然选择了计算机专业，这个暑假当然还是先好好玩玩，打游戏、学车、上网看各种电影和同学出去毕业旅游等等。
在休息娱乐之余，我建议孩子们选一门语言（推荐Python和JavaScript），网上找本完整的电子书或去京东当当买本纸书(同样我推荐图灵出版的Python基础教程和JS方面的书及人邮社计算机分社出版的几本Python和JS书都不错）。推荐这个网站，可以从零开始学python：https://docs.python.org/3/ 。
JavaScript现在已经无处不在了，可能会在你手机上的某个app里，在你浏览的网页里，在你IDE中的某个进程中运行的。自己照着搭建环境，对着书一个字一个字敲代码，运行，出问题自己解决，解决不了先谷歌，不行再来网上问，然后就可以编你想编的程序了，做个小软件运行起来找到成就感。等有了一定的编程经验，你就知道该进一步学什么了。以下这些前端技术书可以先入为主：
 Head First HTML and CSS HTML &amp;amp; CSS CSS 权威指南，CSS 禅意花园，精通 CSS JavaScript DOM编程艺术，JavaScript 高级程序设计，JavaScript 权威指南，JavaScript 模式  学习JS，可以参考这里的文章：http://limu.iteye.com/blog/1267475 。
如果想学PHP(python这样的类PHP语言), 那么下面是一个简单的思路，开始是学习HTML, 应该从页面入手, 自己体察细微变化, 再去研究什么是块元素, 什么是内联元素。做一些展示性的变化，可以学习CSS。CSS也不要上来就挨个介绍属性, 而是以完成展现任务为目的。
而后, 可以接触PHP, 做个简单留言板, 接触到PHP的一些东西和数据库相关东西。做一些用户注册、登录，理解Cookie和session是怎么回事. 在手写一些数据库操作函数以后, 选一个库开始使用。引入模板( php smarty 模板)的概念，简单的逻辑和展示分离。
这时候, 可以学习jQuery, 做些Ajax相关东西, 了解一下json，也应该重视代码质量了, 可以看看art of readable code之类的书，在有人引导的前提下, 可以看看开源项目等(drupal, zendframework, wordpress)。
从大一开始，跟着学校的通识课教学，自己从计算机这个学科体系里的基本知识入手，实践乃是第一必修课，参考http://www.udacity.com/ 和 https://www.coursera.org/ 的现有网上课程（包括很多计算机相关的基础课、中级乃至高级课程）同，这些网上课程非常丰富，在暑假可以抽着空学习一下。
计算机基础学科和数学基础课程
推荐看这里的课程，每周1天，6周就够， https://www.coursera.org/course/cs101 ，了解下计算机基本原理，懂点简单的编程，并具体实践操作，从实践中体验计算机的魅力。以下是新同学要学习的一些计算机基础课程：
 编程语言（如C、C++、JAVA、python 等） 数学基础（一阶逻辑系统、集合论、图论、线性代数、微积分、概率论） 数据结构与算法 软件理论入门（形式语言、自动机） 体系结构（数字电路、CPU设计、操作系统、编译器、网络协议）  掌握一门常用的编程语言和编程技术：能了解你用过的所有的程序内部大致是怎样的，能用你熟悉的语言编写大部分的程序，至少不能是对任何一个程序满头雾水。</description>
    </item>
    
    <item>
      <title>互联网高可用架构技术实践</title>
      <link>https://yushuangqi.com/blog/2017/hu-lian-wang-gao-ke-yong-jia-gou-ji-shu-shi-jian.html</link>
      <pubDate>Tue, 21 Feb 2017 13:19:40 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/hu-lian-wang-gao-ke-yong-jia-gou-ji-shu-shi-jian.html</guid>
      <description>一、什么是高可用 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。
假设系统一直能够提供服务，我们说系统的可用性是100%。如果系统每运行100个时间单位，会有1个时间单位无法提供服务，我们说系统的可用性是99%。很多公司的高可用目标是4个9，也就是99.99%，这就意味着，系统的年停机时间为8.76个小时。
百度的搜索首页，是业内公认高可用保障非常出色的系统，甚至人们会通过www.baidu.com能不能访问来判断“网络的连通性”，百度高可用的服务让人留下啦“网络通畅，百度就能访问”，“百度打不开，应该是网络连不上”的印象，这其实是对百度HA最高的褒奖。
二、如何保障系统的高可用 我们都知道，单点是系统高可用的大敌，单点往往是系统高可用最大的风险和敌人，应该尽量在系统设计的过程中避免单点。方法论上，高可用保证的原则是“集群化”，或者叫“冗余”：只有一个单点，挂了服务会受影响；如果有冗余备份，挂了还有其他backup能够顶上。
保证系统高可用，架构设计的核心准则是：冗余。有了冗余之后，还不够，每次出现故障需要人工介入恢复势必会增加系统的不可服务实践。所以，又往往是通过“自动故障转移”来实现系统的高可用。接下来我们看下典型互联网架构中，如何通过冗余+自动故障转移来保证系统的高可用特性。
三、常见的互联网分层架构 常见互联网分布式架构如上，分为：
 （1）客户端层：典型调用方是浏览器browser或者手机应用APP （2）反向代理层：系统入口，反向代理 （3）站点应用层：实现核心应用逻辑，返回html或者json （4）服务层：如果实现了服务化，就有这一层 （5）数据-缓存层：缓存加速访问存储 （6）数据-数据库层：数据库固化数据存储  整个系统的高可用，又是通过每一层的冗余+自动故障转移来综合实现的。
四、分层高可用架构实践 1. 客户端层-&amp;gt;反向代理层的高可用 客户端层到反向代理层的高可用，是通过反向代理层的冗余来实现的。以nginx为例：有两台nginx，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。
自动故障转移：当nginx挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-nginx，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。
2. 反向代理层-&amp;gt;站点层的高可用 反向代理层到站点层的高可用，是通过站点层的冗余来实现的。假设反向代理层是nginx，nginx.conf里能够配置多个web后端，并且nginx能够探测到多个后端的存活性。
自动故障转移：当web-server挂了的时候，nginx能够探测到，会自动的进行故障转移，将流量自动迁移到其他的web-server，整个过程由nginx自动完成，对调用方是透明的。
3. 站点层-&amp;gt;服务层的高可用 站点层到服务层的高可用，是通过服务层的冗余来实现的。“服务连接池”会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。
自动故障转移：当service挂了的时候，service-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的service，整个过程由连接池自动完成，对调用方是透明的（所以说RPC-client中的服务连接池是很重要的基础组件）。
4. 服务层&amp;gt;缓存层的高可用 服务层到缓存层的高可用，是通过缓存数据的冗余来实现的。 缓存层的数据冗余又有几种方式：第一种是利用客户端的封装，service对cache进行双读或者双写。
缓存层也可以通过支持主从同步的缓存集群来解决缓存层的高可用问题。
以redis为例，redis天然支持主从同步，redis官方也有sentinel哨兵机制，来做redis的存活性检测。
自动故障转移：当redis主挂了的时候，sentinel能够探测到，会通知调用方访问新的redis，整个过程由sentinel和redis集群配合完成，对调用方是透明的。
说完缓存的高可用，这里要多说一句，业务对缓存并不一定有“高可用”要求，更多的对缓存的使用场景，是用来“加速数据访问”：把一部分数据放到缓存里，如果缓存挂了或者缓存没有命中，是可以去后端的数据库中再取数据的。
这类允许“cache miss”的业务场景，缓存架构的建议是：
将kv缓存封装成服务集群，上游设置一个代理（代理可以用集群的方式保证高可用），代理的后端根据缓存访问的key水平切分成若干个实例，每个实例的访问并不做高可用。
缓存实例挂了屏蔽：当有水平切分的实例挂掉时，代理层直接返回cache miss，此时缓存挂掉对调用方也是透明的。key水平切分实例减少，不建议做re-hash，这样容易引发缓存数据的不一致。
5. 服务层&amp;gt;数据库层的高可用 大部分互联网技术，数据库层都用了“主从同步，读写分离”架构，所以数据库层的高可用，又分为“读库高可用”与“写库高可用”两类。
 服务层&amp;gt;数据库层“读”的高可用
  服务层到数据库读的高可用，是通过读库的冗余来实现的。
既然冗余了读库，一般来说就至少有2个从库，“数据库连接池”会建立与读库多个连接，每次请求会路由到这些读库。
自动故障转移：当读库挂了的时候，db-connection-pool能够探测到，会自动的进行故障转移，将流量自动迁移到其他的读库，整个过程由连接池自动完成，对调用方是透明的（所以说DAO中的数据库连接池是很重要的基础组件）。
 服务层&amp;gt;数据库层“写”的高可用
  服务层到数据库写的高可用，是通过写库的冗余来实现的。
以mysql为例，可以设置两个mysql双主同步，一台对线上提供服务，另一台冗余以保证高可用，常见的实践是keepalived存活探测，相同virtual IP提供服务。
自动故障转移：当写库挂了的时候，keepalived能够探测到，会自动的进行故障转移，将流量自动迁移到shadow-db-master，由于使用的是相同的virtual IP，这个切换过程对调用方是透明的。
五、总结 高可用HA（High Availability）是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</description>
    </item>
    
    <item>
      <title>从美国制宪和中国改革来学架构设计</title>
      <link>https://yushuangqi.com/blog/2017/jia-gou-she-ji-ke-yi-xue-mei-guo-zhi-xian-jia-gou-gai-zao-ke-yi-xue-zhong-guo-gai-ge.html</link>
      <pubDate>Tue, 21 Feb 2017 13:19:29 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/jia-gou-she-ji-ke-yi-xue-mei-guo-zhi-xian-jia-gou-gai-zao-ke-yi-xue-zhong-guo-gai-ge.html</guid>
      <description>2017年2月6日周一晚8点30分，GitChat团队迎来了华为公司内源社区平台架构师、开源社理事庄表伟“从美国宪法学习架构设计原则”主题交流。以下是主持人赫阳整理的问题精华，记录下了作者和读者的问答精彩片段。
问： 1）架构中对合作博弈的机制设计是否重要？如果是，则如何设计引入？老架构的调整中，如何破解纳什均衡中的“锁定效应”和“路径依赖”等问题？2） 美国宪法架构设计中，如何处理经费预算的问题呢？或者是预算问题是否是架构问题的先决条件？或者别的某些先决条件属于必要的存在？
答： 1）先引用一段评论。钟晖说：“以前，看过一篇IT同仁用苹果、安卓等操作系统来解释伊斯兰教、基督教等宗教的文章，喻示法灵活显，直白易懂，让大家明白了伊斯兰教是什么鬼。”
那篇文章，我也看过，但是：说实话并不喜欢。因为一旦深入了解各个宗教与各种操作系统，就会发现，简单类比是非常危险的。或者说，仅仅是基于某种固有印象的类比。
另一个希望避免的倾向，是那种“讽喻”，借着IT架构的某某特征，来暗讽某种政治制度。不仅仅因为这样危险，而且也很可能是错误的。其中最大的一个区别，就在于：IT系统里的各种组件，都是人类编写的程序，目前还不会有自行造反的可能性。而人类社会中的各种角色，都是有智力、有目的、有情绪的人。所以，对于人可以讨论博弈论。对于各个模块、组件，就很难去讨论他们之间的博弈关系。
所以，在收到关于纳什均衡相关的问题时，我思索了片刻，感觉很难回答。因为不容易类比过去。当然，在决策过程中，我们的确会发现各种“路径依赖”的现象。因为过去的思路如此，在后续的改进或变更过程中，很难跳出那个圈子去思考。这是人之常情，也可以说是人类共通的弱点。
2）在我的文章里，提到了因为美国政府没钱，所以才会在奴隶制方面有一个3/5妥协。另外，就是每个奴隶，美国政府能够收10美元的税。这就是经济原因导致的，政治决策。另一好玩的例子，我的文章里没有提。在制宪会议过程中，因为争吵太过激烈，富兰克林提议，是不是找一个牧师，来带着大家祈祷。然后，人家告诉他：没有钱请牧师&amp;hellip;
问：三权分立，怎么玩是否可以详细说说？
答：这也是个很难的问题，因为在架构上，我们很难找到简单的类比：A、B、C正好是一个架构里的三个要素。虽然，我们会说三层架构、或者MVC架构，但是这种简单的类比，可能是错误的。或者说，我们如果因为想要比对上三个要素，结果就忽略了系统中的第四、第五个要素，就很危险了。
当然，如果要深入的讨论三权分立的思想精神，可以说它是基于一个要点：假设某个部分出了问题，我们可以如何制衡它？从这个角度而言，我们针对系统中的每个部分，都可以再问一问：如果这个部分出问题了，我们该如何办？就像美国人说“总统是靠不住的、国会也是靠不住的、法官也是靠不住的”，而对于我们的架构来说：架构中的任何一个组件，都是靠不住的。至于是不是一定会是三个部分，互相监督，倒是未必。
问： 在公司多产品平台上的架构重构，需要的周期比较长。对现有产品影响稳定周期较长，一般都是小调整，怎么实施较大重构，老庄的策略及自己操刀过成功的案例有么？ 架构眼花时候的充分向下兼容会导致维护比较重，是否尝试过比较激进的策略？就是为了加快产品进度而一定程度放弃向下兼容，中早期产品迭代获取用户才是最关键的。
答：其实，我们可以泛泛的问题：架构变更（演进），应该依据什么原则？我先引用一段美国宪法的文字：“第五条国会应在两院各2/3议员认为必要时，提出本宪法的修正案，或根据全国2/3州议会的请求召开公议提出修正案。以上任何一种情况下提出的修正案，经全国的州议会或3/4州的制宪会议批准，即成为本宪法的一部分而发生实际效力；采用哪种批准方式可由国会提出。但在1808年前所制定的修正案不得以任何形式影响本宪法第一条第九款之第一、第四两项；任何一州，未经其同意，不得被剥夺它在参议院中的平等投票权。”
这段文字，规定了什么样的修改，可以成为宪法修正案。2/3议员提议；3/4的州通过；可以说，这是一个非常非常难以达到的条件。因为有了这条规则，所以才会有：美国宪法230年，只有27条修正案的结果。
那么，这个规则到底是不是好事呢？
假设，一家公司有一个架构师委员会，2/3架构师提议；3/4架构师同意，才能够对架构实施变更。那么，基本上我们可以认为，这个架构的变化可能性会很小。当业务快速增长、产品快速迭代时，这种搞法，是要出问题的。
在我的文章里，其实也提到了一些。比如美国的总统选举办法，在200多年的时间里，有上百次的修改提议，但是却始终没有能够获得通过。所以，总统的选举办法，还是这个老样子。说实话，是有些危险的。当然，从长治久安的角度来说，随随便便，就可以推出一部新宪法，也不是个事儿。我国的宪法：在60多年的时间里，制定和施行了四部宪法。即1954、1975、1978、1982宪法。1982宪法颁行后，又于1988年、1993年、1999年、2004年四度修正宪法。总觉得，也不太妥当。当然，世界变化太快，也是原因之一。比如说：在希特勒上台之后，在二战结束之后，其实美国人也反省了一下，比如修改了总统选举法。原来的总统不能第二次连任，只是华盛顿立下的潜规则。但是之后的宪法第22修正案，就明确规定只能连任一次了。
还是正面回答一下，如何操刀一次架构变更的问题。说实话，我有成功的案例，也有失败的案例。失败的例子，现在我反省下来，还是当时自己太年轻，资历不够，说服力不强导致的。至于成功的案例，本质上是靠我的鼓动力（说服力）。能不能够说服其他同事，同意我的架构变更方案，至关重要。作为一个会自己coding的架构师，总会有一种冲动：我自己上，把关键的代码给写出来了。看他们还能把我怎么样？这就好比军人干政。我手里有武装力量，就带兵杀进去，造成既成事实。当然，这样肯定是很糟糕的做法。“政治不正确。”
我儿子曾经问过我一个问题：爸爸，你想过变成一个美国人吗？你觉得做中国人好，还是做美国人好？
我当时是这么跟他聊的。美国人有他们的自豪感。中国人也有他们的自豪感。但是，这两种自豪感大不相同。美国人的自豪感，是他们的成就，上升、上升，直到现在成了世界第一。而中国人的自豪感，是“咱们都经历过”。不仅经历过辉煌，也经历过衰落，甚至近乎灭顶之灾。中国人的自豪感在于：几千年风风雨雨，咱们这个民族，都挺过来了。不仅经历过温和的渐变，也经历过毁灭后的重生。所以，在美国人，可能无法想象：把现在的美国宪法，全部推倒重来。但是，在中国历史上，全部推翻，重新搞一套的次数，已经太多次了。所以，在中国历史领域，有一个词叫做：“超稳定结构”，这个架构，可以说更加神奇。全部机器都炸光，还能再build一套，接着run。
所以，针对激进的架构变更策略，其实也没啥。只要公司没有倒，还是可以跑起来的。（当然，风险自负。）
问：讲讲架构的对具体实现的指导和约束机制吧。另外我想说明的是，架构师需要了解整个代码的痛点，才能有效地针对这种痛点做相应的反应。所以，架构师是需要经常触碰代码的，以便整个架构跟随着应用宝氧化而演化。
答：架构对于现实约束，其实是很困难的问题。很多时候，我感觉架构师一定要是一个很好的布道师。将自己对架构的理念与思考，灌注到其他团队成员的心里。然后，才能引导他们，写出我希望看到的代码。从这个意义上来说：汉密尔顿等三位，写的《联邦党人文集》，就是在做这样的说服工作。
另一方面，法制意识也很重要。如果你已经投票同意了这个宪法，是不是就愿意去遵守这个宪法？如果最高法院判你违宪，你是不是立刻就停止种种动作，而不是坚持自己的观点，一意孤行？将法制意识，类比到研发工作中，就是一个开发者的职业素养。在讨论架构的时候，大家各诉己见。在具体的开发过程中，是否能够严格遵守？
问：当组织架构不支持系统架构产品架构的时候有什么办法促进架构的演进和最优化？
答：这个问题，可以说很简单，也可以说很难。简单说：什么挡路就推开什么呀。既然是组织架构的问题，那就想办法改造组织架构呀。而难点在于：如果你的力量不够（不过是个架构师），你根本没有能力，改造组织架构。老板让你做个架构，你告诉他：要变革组织。你让老板怎么想？所以，问题还是回到架构师的说服力。看起来是个架构问题，其实是一个政治问题。你能不能推动某种程度上的变革？与你的手段高低，密切相关。
之前有一段时间，我很喜欢看中国改革开放的那段历史，其中推动变革的技巧，非常值得学习。
问：1）美国的架构应是其政治体制，如三权分立 州联邦 州议会选举等，而宪法应是其brd prd（业务需求文档产品文档）一类的，这些架构也早已借鉴到IT系统中，如选举、联邦等，请问下一步去中心化的架构应如何架设？ 2）IT架构的演进也如政治体制的演进，从君权神授到选举、从集权到民主，其实it的演进比政治快，请问IT架构的演进一般有什么样的节奏？3）利益各方的权衡正如性能、稳定、成本的协调，恰如云计算的发展，性能 稳定 成本可以自动动态调整，请问如何构建自适应的架构？
答：我觉得，宪法的文本，不是产品需求文档。如果一定要类比的话：独立宣言，可以算是需求文档。讨论：我们要变成什么样，人人应该生而平等。这种口号，是产品经理的活。如何落实到宪法中，是架构师的工作。
首先：我不太认同你的问题里面的潜台词：政治制度，是逐步进化的，所以君权神授之后，就应该进化到民主制度。
有两段历史，都是反方向的。一段是美国从《邦联条例》进化成《联邦宪法》，事实上权力变得更加集中了。另一段历史，我最近正在看的罗马史，也是从共和制，走向了“帝制”。不能简单说，这种演变是对还是错。但是，的确是这么变过去了。
去中心化的分布式架构，未必就是未来的架构进化方向。就好像现在大家都在聊的微服务，似乎你们的系统有100个微服务，我们的系统有1000个微服务。你们明显就不够牛。本质上，不应该追求这个。回到我的文章的第一节：重构都是被逼的，并非：有一个人人都认可的，先进的，注定正确的方向。抛开实际的业务场景，抛开具体的困难与目标，泛泛的谈架构演进的方向，是很危险的。再聊聊演进的节奏问题，这个我现在最认同的观点，是精益企业的观点。首先有数据，然后才能正确的判断该如何演进。既然是在IT架构上谈演化，那么对于IT架构目前的现状，就完全可以不凭感觉，而是凭数据说话。
问：架构有没有不能妥协的最小原则？
答：其实，没有什么不能妥协的。只要老板还有钱，还肯让你接着弄。总是可以变来变去的。当然，这是一种很没有追求的回答。另外一个较为有深度的说法是：架构师可以有主见，但是不能有成见。所以，在我的工作中，唯一不能容忍的架构决策是：凭借猜测，做出的判断。你可以有A观点，也可以有B观点，但是你不能说：咱们试试吧，说不定这样就好了！
问： 如果一个架构团队，有一个架构师无视集体决议，利用自己编码速度快，在公司统一框架下夹带私货，如何应对？举个例子哦，其它架构师都同意把token或者权限验证签名放在HTTPheader里传递，可这个架构却把这些安全参数放在requestbody的json字符串中，并且都已经上生产环境了，其余架构是否可以强制下线该项目或功能？
答： 这个架构师，缺乏职业素养，先开掉吧。然后再慢慢的收拾他制造的残局。因为，你无法确保，他会不会做出其他出格的事情，比如拖库、删库。
问：传统企业，但由于历史原因，架构都不一样，但公司也要互联网话，公司领导也支持架构重构，人也相对够用，目前所有业务量都不算大，但对架构的基本要求，比如了扩展，高可用，稳定，监控等，重构后希望统一技术，提高开发效率，想问下这种场景下一般要怎样设计架构呢，有什么建议呢？
答：目标不应该是“互联网化”，而是“架构优化”。从实际出发，分析该如何改进。不是“以扩展、高可用、监控”，甚至容器、微服务之类的时髦词汇为目标。而是：当前的系统，有啥问题。痛点在哪里？然后，找一下业界的成熟实践，看看有没有可以引进的方案。小步慢跑，再逐步的快起来。尤其是不要心血来潮，搞休克疗法。说实话，领导支持云云，不是因为这样的改造是必须。只是因为它听起来“更先进了”。
可以简单的总结一下我的观点：设计架构，可以学习美国制宪；改造架构，可以学习中国改革。</description>
    </item>
    
    <item>
      <title>go协程与主线程强占运行</title>
      <link>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:49 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-xie-cheng-yu-zhu-xian-cheng-jiang-zhan-yun-hang.html</guid>
      <description>最近在学习了go 语言 , 正好学习到了 协程这一块 ,遇到了困惑的地方.这个是go语言官方文档 . 在我的理解当中是,协程只能在主线程释放时间片后才会经过系统调度来运行协程,其实正确的也确实是这样的,但是我遇到了协程强占主线程的一个问题,经过帮助,现在已经了解.废话不多说,先看代码
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { go say(&amp;quot;world&amp;quot;) say(&amp;quot;hello&amp;quot;) /* fmt.Println(&amp;quot;---------------1&amp;quot;) a := []int{7, 2, 8, -9, 4, 0} fmt.Println(&amp;quot;===&amp;quot;, a[:len(a)/2]) c := make(chan int) go sum(a[:len(a)/2], c) go sum(a[len(a)/2:], c) x, y := &amp;lt;-c, &amp;lt;-c // receive from c fmt.Println(x, y, x+y) fmt.Println(&amp;quot;---------------2&amp;quot;) c2 := make(chan int, 2) c2 &amp;lt;- 1 c2 &amp;lt;- 2 fmt.Println(&amp;lt;-c2) fmt.Println(&amp;lt;-c2) fmt.Println(&amp;quot;---------------3&amp;quot;) c3 := make(chan int, 10) go fibonacci(cap(c3), c3) for i := range c3 { fmt.</description>
    </item>
    
    <item>
      <title>Gounsafe包</title>
      <link>https://yushuangqi.com/blog/2017/go-unsafebao.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:48 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-unsafebao.html</guid>
      <description>Go unsafe包
unsafe包概述 直到现在（Go1.7），unsafe包含以下资源：
三个函数：
// unsafe.Sizeof函数返回操作数在内存中的字节大小,参数可以是任意类型的表达式,但是它并不会对表达式进行求值. // 一个Sizeof函数调用是一个对应uintptr类型的常量表达式, // 因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量. func Sizeof(x ArbitraryType) uintptr //函数的参数必须是一个字段 x.f, 然后返回 f 字段相对于 x 起始地址的偏移量, 包括可能的空洞. func Offsetof(x ArbitraryType) uintptr //unsafe.Alignof 函数返回对应参数的类型需要对齐的倍数. func Alignof(x ArbitraryType) uintptr   内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 和一种类型：
type Pointer *ArbitraryType  这里，ArbitraryType不是一个真正的类型。官方导出这个类型只是出于完善文档的考虑，在其他的库和任何项目中都没有使用价值，除非程序员故意使用它。
 unsafe.Sizeof, Alignof 和 Offsetof  计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。
 由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。
 一个结构体变量 x 以及其在64位机器上的典型的内存. 灰色区域是空洞.
var x struct { a bool b int16 c []int }  对结构体变量的三个字段调用unsafe包相关函数的计算结果如下，</description>
    </item>
    
    <item>
      <title>Go1_8httpgraceful体验</title>
      <link>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:47 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-1_8-http-graceful-ti-yan.html</guid>
      <description>很高兴Go 1.8发布了，这是个值得庆祝的日子。
如何优雅的关闭http服务在Go Web开发中一直被提及和讨论的话题，今天Go 1.8的发布终于为我们带来了这个特性。
文档中是这样介绍的：
func (srv *Server) Shutdown(ctx context.Context) error  Shutdown 将无中断的关闭正在活跃的连接，然后平滑的停止服务。处理流程如下：
 首先关闭所有的监听
 然后关闭所有的空闲连接
 然后无限期等待连接处理完毕转为空闲，并关闭
 如果提供了 带有超时的Context，将在服务关闭前返回 Context的超时错误
  需要注意的是，Shutdown 并不尝试关闭或者等待 hijacked连接，如 WebSockets。如果需要的话调用者需要分别处理诸如长连接类型的等待和关闭。
其实，你只要调用 Shutdown 方法就好了。
简单示例：
// main.go package main import ( &amp;quot;fmt&amp;quot; &amp;quot;log&amp;quot; &amp;quot;net/http&amp;quot; &amp;quot;os&amp;quot; &amp;quot;os/signal&amp;quot; &amp;quot;syscall&amp;quot; &amp;quot;time&amp;quot; ) func main() { http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, &amp;quot;Hello World, %v\n&amp;quot;, time.Now()) }) s := &amp;amp;http.Server{ Addr: &amp;quot;:8080&amp;quot;, Handler: http.</description>
    </item>
    
    <item>
      <title>Go1_8正式发布</title>
      <link>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:46 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go1_8zheng-shi-fa-bu.html</guid>
      <description>今天Go团队很高兴地宣布Go 1.8发布了。你可以从下载页面获得1.8版本。在这个版本中，整个标准库有显着的性能改进和变化。
Go 1.7中为64位x86系统引入的编译器后端现在用于所有体系结构，在这些体系结构下可以看到显着的性能改进。例如，我们的基准程序所需的CPU时间在32位ARM系统上减少了20-30％。在此版本中，对于64位x86系统也有一些性能提升。编译器和链接器跑得更快。编译时间应该比Go 1.7缩短约15％。在这一领域还有更多的工作要做：希望未来版本的编译速度更快。
垃圾收集暂停应明显更短，通常在100微秒以下，通常低至10微秒。
HTTP服务器添加对HTTP/2 Push的支持，允许服务器向客户端推送。这对于消除网络延迟非常有用。 HTTP服务器还添加了对优雅停机的支持，允许服务器完成正在运行的请求之后关闭从而最小化停机时间。
context（添加到Go 1.7中的标准库）提供了取消和超时机制。 Go 1.8在更多的标准库中添加了对context的支持，包括database/sql和net包以及net/http包中的Server.Shutdown。
现在使用新添加的Slice函数使得对slice进行排序更简单。例如，要通过“名称”字段对结构体片段进行排序：
Go 1.8包括很多新增API，以及老API的改进和修复。 你可以在Go 1.8发行说明中查找完整的修改列表，以及有关上面列出内容的详细信息。
为了庆祝新版发布，世界各地的Go用户组都在本周举办发布会。 发布会已经成为Go社区的一个传统，所以如果你错过了这一次，当1.9发布时应该注意了。
感谢超过200个贡献者谁帮助了1.8版本的发布。</description>
    </item>
    
    <item>
      <title>go用slice模拟vector功能</title>
      <link>https://yushuangqi.com/blog/2017/go-yong-slicemo-ni-vectorgong-neng.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:46 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-yong-slicemo-ni-vectorgong-neng.html</guid>
      <description>appendVector ``` - 编程语言与开发 a = append(a, b&amp;hellip;)
 copy ==== ``` - 编程语言与开发 b = append([]T(nil), a...)  ``` - 编程语言与开发 b = make([]T, len(a)) copy(b, a)
 cut删除一段范围i\~j =================== ``` - 编程语言与开发 copy(a[i:], a[j:]) for k, n := len(a) - j + i, len(a); k &amp;lt; n; k++ { a[k] = nil //or the zero value of T } a = a[:len(a) - j + i]  delete删除指定i ``` - 编程语言与开发 copy(a[i:], a[i+1:] a[len(a] - 1] = nil //or zero value of T a = a[:len(a)-1]</description>
    </item>
    
    <item>
      <title>gogrpc安装</title>
      <link>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:45 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/go-grpcan-zhuang.html</guid>
      <description>Prerequisites Go version gRPC works with Go 1.5 or higher.
$ go version  For installation instructions, follow this guide: Getting Started - The Go Programming Language
Install gRPC Use the following command to install gRPC.
$ go get google.golang.org/grpc  Install Protocol Buffers v3 Install the protoc compiler that is used to generate gRPC service code. The simplest way to do this is to download pre-compiled binaries for your platform(protoc-&amp;lt;version&amp;gt;-&amp;lt;platform&amp;gt;.</description>
    </item>
    
    <item>
      <title>golangappend的并发问题</title>
      <link>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/golang-appendde-bing-fa-wen-ti.html</guid>
      <description>先看一段代码
ackage main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var wg sync.WaitGroup s := make([]int, 0, 1000) for i := 0; i &amp;lt; 1000; i++ { v := i wg.Add(1) go func() { s = append(s, v) wg.Done() }() } wg.Wait() fmt.Printf(&amp;quot;%v\n&amp;quot;, len(s)) }  结果
第一次：928 第二次：945 第三次：986 ……  多运行几次你就会发现，slice长度并不是1000，而是不停的在变，为什么呢？
因为append并不是并发安全的。
我们举一个简单例子，比如，当A和B两个协程运行append的时候同时发现s[1]这个位置是空的，他们就都会把自己的值放在这个位置，这样他们两个的值就会覆盖，造成数据丢失。
那该怎么写？最简单的方式就是用锁，贴一个例子。
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; ) func main() { var ( wg sync.</description>
    </item>
    
    <item>
      <title>设计模式(golang)</title>
      <link>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:44 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/she-ji-mo-shi-golang.html</guid>
      <description>设计模式的六大原则 摘自 Java开发中的23种设计模式详解
 1、开闭原则（Open Close Principle）
开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。 所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后 面的具体设计中我们会提到这点。
 2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何 基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受 到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。 实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽 象化的具体步骤的规范。—— From Baidu 百科
 3、依赖倒转原则（Dependence Inversion Principle）
这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。
 4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出， 其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。
 5、迪米特法则（最少知道原则）（Demeter Principle）
为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。
 6、合成复用原则（Composite Reuse Principle）
原则是尽量使用合成/聚合的方式，而不是使用继承。
  实现代码 {#h1_1} https://github.com/BPing/golang_design_pattern/tree/master/pattern
 创建型 C 结构型 J 行为型 X   -AbstractFactory.go : 抽象工厂模式(C) -Adapter.go : 适配器模式(J) -Bridge.go : 桥接模式(J) -Builder.</description>
    </item>
    
    <item>
      <title>屌炸天的新版GoGC之twitch的GC优化之路</title>
      <link>https://yushuangqi.com/blog/2017/diao-zha-tian-de-xin-ban-go-gczhi-twitchde-gcyou-hua-zhi-lu.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:43 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/diao-zha-tian-de-xin-ban-go-gczhi-twitchde-gcyou-hua-zhi-lu.html</guid>
      <description>此文翻译自：https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7
我们在Twitch使用Go研发了许多高并发的系统。它的简单性，安全性，性能和可读性使其成为解决我们遇到问题的一个很好的工具，我们向数百万用户提供实况视频和聊天服务。
但这不是另一篇关于Go对于我们有多么大作用的文章， 本文是关于我们在使用Go过程中碰到的限制以及我们如何克服这些限制的文章。
Go 1.4和Go 1.6之间Go runtime的改进使我们的垃圾收集（GC）暂停时间缩短了20倍，我们如何在Go 1.6的停顿之上进一步缩小 10 倍的暂停时间，以及如何向Go团队分享我们的案例，使得1.7中不使用我们手动方案的同时停顿时间又降低了10倍。
开始 我们的基于IRC的聊天系统最早是在2013年年底用Go写的，取代了以前的Python实现。使用Go 1.2的预发布版本，它能够在每个物理主机提供超过500,000并发用户，而无需特殊调整。有一组三个goroutine（Go的轻量级执行线程）为每个连接提供服务，程序在每个进程中拥有1,500,000个goroutine。即使有这么大的goroutine数量，我们在使用Go1.2的过程中碰见的唯一性能问题是GC暂停时间，执行GC将冻结我们的应用程序几十秒。
不仅每个GC暂停非常昂贵，GC每分钟运行几次。我们努力减少内存分配的数量和大小，以便将GC运行的频率降低，如果堆每两分钟只增长50％，就意味着分配数量足够低。虽然暂停时间减少，但每一次GC暂停都是破坏性的。
一旦Go 1.2 正式发布，GC暂停时间下降到“仅”几秒钟。我们将流量分散在更大数量的进程中，从而将停顿降低到更容易接受的范围。
随着Go版本增长，减少分配的工作会继续有益于我们的聊天服务器，但是分解聊天进程是一个特定范围的Go版本的解决方案。这样的解决方案经不起时间的考验，但对于为我们的用户提供良好的服务非常重要。分享我们的经验有助于为Go运行时创建持久的改进，从而使单个程序受益。
从2015年8月的Go 1.5开始，Go的垃圾收集器大多数时候是并发和增量的，这意味着在大部分阶段它不需要将应用程序完全停止。除了相对较短的标记和终止阶段，我们的程序可以继续运行，同时运行垃圾回收。升级到Go 1.5立即导致我们的聊天系统中的GC暂停时间的10倍缩小，在重负荷测试实例上的暂停时间从2秒缩短到约200ms。
Go 1.5 GC新纪元 虽然Go 1.5的延迟减少值得庆祝，但新GC的最大意义是它为进一步的增量改进奠定了基础。
Go 1.5的垃圾收集器仍然具有相同的两个主要阶段 -
标记阶段（GC确定哪些内存分配仍在使用），以及扫描阶段（其中未使用的内存已准备好重用） 但是每个阶段都被分成两个子阶段。首先，应用程序暂停，而前一个扫描阶段终止。然后，并发标记阶段在用户代码运行时查找正在使用的内存。最后，应用程序第二次暂停，标记阶段终止。之后，未使用的内存将被扫描，同时应用程序将执行其业务。
runtime的gctrace功能打印每个GC周期，包括每个阶段的持续时间。对于我们的聊天服务器，它表明大部分剩余的暂停时间在标记终止阶段，因此分析将集中在那里。
当然，我们需要更多关于GC在这些暂停期间究竟做了什么的细节。 Go核心包有CPU profiler，同时组合使用Linux的perf工具。使用perf允许使用更高的采样频率和在内核中花费的时间可视化。在内核中使用的监视器可以帮助我们调试缓慢的系统调用，并透明地完成虚拟内存管理。
下面的图片是我们的聊天服务器配置文件的一部分，运行go1.5.1。这是一个使用Brendan Gregg工具制作的火焰图，修剪后只包含在堆栈上具有runtime.gcMark函数的样本，这是Go 1.5在标记终止阶段花费的时间。
火焰图将堆栈深度显示为向上增长，并且将CPU时间表示为每个部分的宽度。 （颜色是无意义的，x轴上的排序也是无关紧要的 - 它只是字母顺序。）在图表的左边，我们可以看到runtime.gcMark在几乎所有的抽样堆栈中调用runtime.parfordo。向上我们看到大多数时间花在runtime.markroot调用runtime.scang，runtime.scanobject和runtime.shrinkstack。
runtime.scang函数用于重新扫描内存以帮助终止标记阶段。标记终止阶段背后的整个想法是完成扫描应用程序的内存。
接下来是runtime.scanobject。这个函数做了几件事情，但在Go 1.5的聊天服务器标记终止阶段运行的原因是实现finalizer。 为什么程序会使用这么多的finalizer，他们为什么会占用这么长GC暂停时间？。有问题的应用程序是一个聊天服务器，同时处理成千上万的用户。
Go的核心“net”软件包附加一个finalizer到每个TCP连接，以帮助控制文件描述符泄漏 并且由于每个用户都有自己的TCP连接，即使每个链接只有一个finalizer，加起来还是很可观。
这个问题似乎值得向Go runtime 团队报告。我们通过电子邮件交流，Go团队对如何诊断性能问题以及如何将它们提炼成最小测试用例的建议非常有帮助。对于Go 1.6，运行时团队将finalizer扫描移动到并发标记阶段，导致具有大量TCP连接的应用程序的暂停时间更短。结合发布中的所有其他改进，我们的聊天服务器在Go 1.6的暂停时间是在Go 1.5的一半左右，在测试实例上降低到大约100ms。
堆栈收缩 Go的并发使启动大量goroutine非常廉价。虽然使用10,000个操作系统线程的程序性能可能很差，但是这个数量的goroutine却很正常。一个区别是goroutine从非常小的堆栈开始 - 只有2kB - 根据需要增长，与其他地方常见的大型固定大小堆栈形成对比。
Go的函数调用前缀确保有足够的堆栈空间用于下一次调用，如果没有，则在允许调用继续之前，将goroutine的堆栈移动到更大的内存区域 - 根据需要重写指针。
因此对一个程序来说，为了支持他们做的最深的调用，其goroutine的堆栈将增长。垃圾收集器的一个职责是回收不再需要的堆栈内存。将goroutine堆栈移动到更适当大小的内存区域的任务由runtime.shrinkstack完成，在Go 1.5和1.6中，在标记终止期间完成。
上面的火焰图，在其样本的3/4左右显示runtime.shrinkstack。如果这项工作可以在应用程序运行时完成，它可以大大加快我们的聊天服务器和其他程序。
Go运行时的包docs解释如何禁用堆栈收缩。对于我们的聊天服务器，相对于浪费内存来说更短暂的暂停时间更容易接受。在禁用堆栈收缩的情况下，聊天服务器的暂停时间再次减少到30到70ms之间。
在保持聊天服务的结构和操作相对恒定的同时，我们忍受了Go 1.</description>
    </item>
    
    <item>
      <title>数据库不适合Docker及容器化的7大原因</title>
      <link>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</link>
      <pubDate>Sat, 18 Feb 2017 11:13:42 +0800</pubDate>
      <author>devysq@gmail.com (虞双齐)</author>
      <guid>https://yushuangqi.com/blog/2017/shu-ju-ku-bu-kuo-ge-dockerji-rong-qi-hua-de-7da-yuan-yin.html</guid>
      <description>导读：所有的服务都开始了容器化升级，在一切皆容器的主流思想下，无状态的服务采用容器化已经是大势所趋，常常困扰架构师的一个问题是，数据库是否需要容器化，本文作者 Mikhail Chinkov 提出了自己否定观点，由高可用架构翻译。

如果我们观察 2017 年技术行业，容器和 Docker 依然将是最热门的流行语。我们开始在每个领域的 Docker 容器中打包开发的软件。从小型初创公司到巨大的微服务平台都在使用容器技术。从 CI 平台到 Raspberry Pi 。从数据库到……
数据库？您确定要将数据库放在容器中吗？
不幸的是，这不是虚构的场景。我看到许多快速增长的项目将数据持久化到容器中。并且将计算服务和数据服务放在同一台机器上。笔者希望有经验的人不会用这个解决方案。
下面是我的观点，数据库容器化从今天来看是非常不合理的。
数据库不适合容器化的7大原因 **
**
1. 数据不安全 
即使你要把 Docker 数据放在主机来存储 ，它依然不能保证不丢数据。 Docker volumes 的设计围绕 Union FS 镜像层提供持久存储，但它仍然缺乏保证。
使用当前的存储驱动程序，Docker 仍然存在不可靠的风险。 如果容器崩溃并数据库未正确关闭，则可能会损坏数据。

2. 运行数据库的环境需求 **
**
常看到 DBMS 容器和其他服务运行在同一主机上。 然而这些服务对硬件要求是非常不同的。
数据库（特别是关系型数据库）对 IO 的要求较高。 一般数据库引擎为了避免并发资源竞争而使用专用环境。如果将你的数据库放在容器中，那么将浪费你的项目的资源。 因为你需要为该实例配置大量额外的资源。 在公有云，当你需要 34G 内存时，你启动的实例却必须开 64G 内存。在实践中，这些资源并未完全使用。
怎么解决？ 您可以分层设计，并使用固定资源来启动不同层次的多个实例。 水平伸缩总是比垂直伸缩更好。 
3. 网络问题 **
**
要理解 Docker 网络，您必须对网络虚拟化有深入的了解。也必须准备应付好意外情况。你可能需要在没有支持或没有额外工具的情况下，进行 bug 修复。</description>
    </item>
    
  </channel>
</rss>