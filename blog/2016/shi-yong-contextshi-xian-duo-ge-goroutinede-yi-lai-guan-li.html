<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>使用context实现多个goroutine的依赖管理 |虞双齐Golang开发</title><meta name="description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html"><meta property="og:title" content="使用context实现多个goroutine的依赖管理"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:32:52"><meta property="article:modified_time" content="2016-12-31 11:32:52"><meta property="article:tag" content="golang"><meta name="og:description" content="解决的问题 在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html">使用context实现多个goroutine的依赖管理</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000007531146" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="解决的问题">解决的问题</h2><p>在很多实际情况，比如处理网络请求时，我们需要启动多个goroutine来处理不同的逻辑，比如一个主要的goroutine用来响应请求，生成网页，同时它还启动一个子线程用来获取数据库信息，还有一个则写日志等等。正常情况都没有问题，但是一旦出现异常，如何优雅的退出这些子线程，同时释放掉可能占用的资源呢？</p><h2 id="context">context</h2><p>在golang中，人们发明了context接口处理这种情况。早在14年，这个库就出现了，并且提出了<a href="https://blog.golang.org/context">基于context的并发编程范式</a>（英文好的同学可以直接撸这篇文章）。<br>今年8月<a href="https://golang.org/doc/go1.7">go1.7</a>发布后，它正式成为了标准库的一员。</p><h2 id="如何使用">如何使用</h2><p>在golang的context库中，首先定义了context的接口，然后给出了context接口的4种实现：</p><ul><li><p>WithCancel(parent Context) (Context, CancelFunc)<br>初始化一个可以被cancel的context，同时把新context对象作为child放入parent的children数组中。当parent终止时，child也会接受到信号。这个过程叫<code>propagateCancel</code></p></li><li><p>WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc)<br>同样初始化一个context，除了实现跟<code>WithCancel</code>同样的功能外，还增加了一个时间变量，一旦当前时间超过这个deadline，那么这个context以及它的所有子孙都被被cancel。</p></li><li><p>WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)<br>跟<code>WithDeadline</code>类似，如果说<code>WithDeadline</code>是一个绝对时间上的限制，那么<code>WithTimeout</code>就是一个相对时间的限制</p></li><li><p>WithValue(parent Context, key, val interface{}) Context<br>单纯给parent增加value，不需要<code>propagateCancel</code>。value可以用来跨进程、跨api的传递数据，最好是和某个请求相关的参数，不要传递太多大量数据。</p></li></ul><p>所以关键就在于<code>propagateCancel</code>，实际工程中，所有context共同组成了一个依赖树，他们都继承自一个祖先。一旦parent被cancel，就会通过<code>propagateCancel</code>递归的传播给下面的所有子孙。可以看出，context就好比信使，或者说通讯协议，通过遵循context接口构建的这个框架，能够保证子线程及时获得与他相关的父线程的状态，从而由子线程根据情况作出反应。至于怎么反应，就取决于各位码农的能力和搬砖当时的心情了。。。</p><p>另外，golang有一套静态分析工具可以分析context的传播过程，所以为了方便这个工具的使用，实际使用中有几个规定：</p><ul><li><p>不要把context作为struct内部变量使用，而是把它和其他变量一块作为参数传入下一个函数。</p></li><li><p>context变量需要作为函数的第一个参数传入，命名一般为<code>ctx</code></p></li></ul><h2 id="具体例子">具体例子</h2><p>这个例子来源于<a href="https://blog.golang.org/context">基于context的并发编程范式</a>，但是为了符合国情我做了些修改：<br>包括3部分：</p><ul><li><p>server.go<br>主线程，会创建一个server服务器，可以通过<code>localhost:9090/search</code>访问。接到请求后，它会创建父context，同时生成一个新goroutine，去fakesrv（本来应该去google上的）上请求数据。</p></li><li><p>google.go<br>替换原来的google网址，改成由fakesrv提供的一个网址。主要就是演示一下context的运行过程，请求fakesrv的工作在一个新goroutine中进行，同时它还有一个访问数据库的操作。如果父context因为timeout超时了，那么对fakesrv和数据库的访问也会终止。在代码中，演示了如何监听context信息的过程。</p></li><li><p>query.go<br>解析url中的query参数</p></li><li><p>fakesrv.go<br>提供<a href="http://localhost:9000/context_demo">http://localhost:9000/context&hellip;</a>供google.go访问。</p></li></ul><h3 id="mycontext-serve-go">mycontext/serve.go</h3><pre><code>// The server program issues Google search requests and demonstrates the use of
// the go.net Context API. It serves on port 8080.
//
// The /search endpoint accepts these query params:
//   q=the Google search query
//   timeout=a timeout for the request, in time.Duration format
//
// For example, http://localhost:8080/search?q=golang&amp;timeout=1s serves the
// first few Google search results for &quot;golang&quot; or a &quot;deadline exceeded&quot; error
// if the timeout expires.
package main

import (
    &quot;html/template&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    &quot;time&quot;

    &quot;context&quot;
    &quot;mycontext/google&quot;
    &quot;mycontext/query&quot;
)

func main() {
    http.HandleFunc(&quot;/search&quot;, handleSearch)
    log.Fatal(http.ListenAndServe(&quot;:9090&quot;, nil))
}

// handleSearch handles URLs like /search?q=golang&amp;timeout=1s by forwarding the
// query to google.Search. If the query param includes timeout, the search is
// canceled after that duration elapses.
func handleSearch(w http.ResponseWriter, req *http.Request) {
    // ctx is the Context for this handler. Calling cancel closes the
    // ctx.Done channel, which is the cancellation signal for requests
    // started by this handler.
    var (
        ctx    context.Context
        qctx   *query.QueryCtx
        cancel context.CancelFunc
    )
    timeout, err := time.ParseDuration(req.FormValue(&quot;timeout&quot;))
    if err == nil {
        // The request has a timeout, so create a context that is
        // canceled automatically when the timeout expires.
        ctx, cancel = context.WithTimeout(context.Background(), timeout)
    } else {
        ctx, cancel = context.WithCancel(context.Background())
    }
    defer cancel() // Cancel ctx as soon as handleSearch returns.
    qctx, err = query.NewQueryCtx(ctx, req)
    if err != nil {
        http.Error(w, &quot;no query&quot;, http.StatusBadRequest)
        return
    }

    // Run the Google search and print the results.
    start := time.Now()
    results, err := google.Search(qctx)
    elapsed := time.Since(start)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    if err := resultsTemplate.Execute(w, struct {
        Results          google.Results
        Timeout, Elapsed time.Duration
    }{
        Results: results,
        Timeout: timeout,
        Elapsed: elapsed,
    }); err != nil {
        log.Print(err)
        return
    }
}

var resultsTemplate = template.Must(template.New(&quot;results&quot;).Parse(`
&lt;html&gt;
&lt;head/&gt;
&lt;body&gt;
  &lt;ol&gt;
  {{range .Results}}
    &lt;li&gt;{{.Title}} - &lt;span&gt;{{.SubTitle}}&lt;/span&gt;&lt;/li&gt;
  {{end}}
  &lt;/ol&gt;
  &lt;p&gt;{{len .Results}} results in {{.Elapsed}}; timeout {{.Timeout}}&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
`))
</code></pre><h3 id="mycontext-google-google-go">mycontext/google/google.go</h3><pre><code>// Package google provides a function to do Google searches using the Google Web
// Search API. See https://developers.google.com/web-search/docs/
//
// This package is an example to accompany https://blog.golang.org/context.
// It is not intended for use by others.
//
// Google has since disabled its search API,
// and so this package is no longer useful.
package google

import (
    &quot;context&quot;
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;mycontext/query&quot;
    &quot;net/http&quot;
    &quot;time&quot;
)

// Results is an ordered list of search results.
type Results []Result

// A Result contains the title and URL of a search result.
type Result struct {
    Title, SubTitle string
}

// Search sends query to Google search and returns the results.
func Search(ctx *query.QueryCtx) (Results, error) {
    // Prepare the Google Search API request.
    req, err := http.NewRequest(&quot;GET&quot;, &quot;http://localhost:9000/context_demo&quot;, nil)
    if err != nil {
        return nil, err
    }

    ctx.SetReq(req)
    // Issue the HTTP request and handle the response. The httpDo function
    // cancels the request if ctx.Done is closed.
    var results Results
    err = httpDo(ctx, req, func(resp *http.Response, err error) error {
        if err != nil {
            return err
        }
        defer resp.Body.Close()

        // Parse the JSON search result.
        // https://developers.google.com/web-search/docs/#fonje
        var data struct {
            ResponseData struct {
                Results []struct {
                    Title, SubTitle string
                }
            }
        }
        if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {
            return err
        }
        for _, res := range data.ResponseData.Results {
            results = append(results, Result{Title: res.Title, SubTitle: res.SubTitle})
        }
        return nil
    })
    // httpDo waits for the closure we provided to return, so it's safe to
    // read results here.
    return results, err
}

// httpDo issues the HTTP request and calls f with the response. If ctx.Done is
// closed while the request or f is running, httpDo cancels the request, waits
// for f to exit, and returns ctx.Err. Otherwise, httpDo returns f's error.
func httpDo(ctx *query.QueryCtx, req *http.Request, f func(*http.Response, error) error) error {
    // Run the HTTP request in a goroutine and pass the response to f.
    tr := &amp;http.Transport{}
    client := &amp;http.Client{Transport: tr}
    // WithCancel会在ctx的children中增加cancelDb，这样当
    // ctx 结束的时候，cancelDb也会受到消息
    cancelDb, cancel := context.WithCancel(ctx.Context)
    defer cancel()
    c := make(chan error, 1)
    go func() { c &lt;- f(client.Do(req)) }()
    go func(ctx context.Context) {
        t := time.NewTimer(2 * time.Second)

        select {
        case &lt;-t.C:
            log.Println(&quot;db access finished!&quot;)
        case &lt;-ctx.Done():
            log.Println(&quot;canceld by parent, release resource&quot;)
        }
    }(cancelDb)
    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }
}
</code></pre><h3 id="mycontext-query-query-go">mycontext/query/query.go</h3><pre><code>package query

import (
    &quot;context&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func NewQueryCtx(ctx context.Context, req *http.Request) (*QueryCtx, error) {
    q := req.FormValue(&quot;q&quot;)
    if q == &quot;&quot; {
        return nil, fmt.Errorf(&quot;no query supplied!&quot;)
    }
    return &amp;QueryCtx{ctx, q}, nil
}

type QueryCtx struct {
    context.Context
    val string
}

func (ctx *QueryCtx) SetReq(req *http.Request) {
    q := req.URL.Query()
    q.Set(&quot;q&quot;, ctx.val)

    req.URL.RawQuery = q.Encode()
}
</code></pre><h3 id="mycontext-fakesrv-main-go">mycontext/fakesrv/main.go</h3><pre><code>package main

import (
    &quot;bytes&quot;
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;log&quot;
    &quot;math/rand&quot;
    &quot;net/http&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
    &quot;time&quot;
)

func init() {
    log.SetFlags(log.Lshortfile)
}

type Results struct {
    ResponseData struct {
        Results []Content
    }
}

// A Result contains the title and URL of a search result.
type Content struct {
    Title, SubTitle string
}

func main() {

    http.HandleFunc(&quot;/context_demo&quot;, handleContext)
    http.ListenAndServe(&quot;:9000&quot;, nil)
}

func handleContext(resp http.ResponseWriter, req *http.Request) {
    defer func() {
        if e := recover(); e != nil {
            if msg, ok := e.(string); ok {
                resp.Write([]byte(msg))
            } else {
                panic(e)
            }
        }
    }()
    check_error := func(err error, msg string) {
        if err != nil {
            if msg != &quot;&quot; {
                panic(err.Error() + &quot;:&quot; + msg)
            } else {
                panic(err.Error())
            }
        }
    }
    if req.Method == &quot;GET&quot; {
        q := req.FormValue(&quot;q&quot;)
        seg := strings.Split(q, &quot;:&quot;)
        if len(seg) &lt; 2 {
            log.Println(&quot;query format wrong&quot;)
            resp.Write([]byte(&quot;query format wrong&quot;))
            return
        }
        title := seg[0]
        num, err := strconv.Atoi(seg[1])
        check_error(err, &quot;&quot;)
        rs := Results{}
        for i := 0; i &lt; num; i++ {
            rs.ResponseData.Results = append(rs.ResponseData.Results,
                Content{fmt.Sprintf(&quot;%s %d&quot;, title, i), RandomString(20)})
        }
        buff := bytes.NewBuffer(nil)
        err = json.NewEncoder(buff).Encode(rs)
        check_error(err, &quot;&quot;)
        time.Sleep(time.Second * 2)
        resp.Write(buff.Bytes())
    } else {
        resp.Write([]byte(&quot;请使用get方法!&quot;))
    }
}
func RandomString(strlen int) string {
    rand.Seed(time.Now().UTC().UnixNano())
    const chars = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;
    result := make([]byte, strlen)
    for i := 0; i &lt; strlen; i++ {
        result[i] = chars[rand.Intn(len(chars))]
    }
    return string(result)
}
</code></pre><h3 id="makefile">Makefile</h3><pre><code>run:
    go build 
    ./mycontext &amp;
    cd fakesrv &amp;&amp; go build &amp;&amp; ./fakesrv &amp;

test:
    @echo &quot;======= test without timeout =======&quot;
    curl localhost:9090/search?q=title:6
    @echo &quot;======= test with timeout 1s =======&quot;
    curl localhost:9090/search?q=title:6\&amp;timeout=1s
    @echo &quot;======= test with timeout 4s =======&quot;
    curl localhost:9090/search?q=title:6\&amp;timeout=4s
</code></pre><h3 id="测试">测试</h3><p>在命令行运行如下命令，即可看到具体结果<br>make run<br>make test</p></div><aside id="meta"><meta itemprop="wordCount" content="1089"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/_gozk_zookeeper_zk_go-fatal-error-zookeeper_h-file-not-found.html">_gozk_zookeeper_zk_gofatalerror:zookeeper_hfilenotfound</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/zai-beegozhong-shi-yong-jademo-ban.html">在Beego中使用Jade模板</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="1f6dc3c56d99c02c6fc31f763062909a" data-title="使用context实现多个goroutine的依赖管理" data-url="https://yushuangqi.com/blog/2016/shi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，Golang开发独立咨询顾问。为国内客户提供Golang开发、技术实战、架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fshi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fshi-yong-contextshi-xian-duo-ge-goroutinede-yi-lai-guan-li.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Go语言技术独立咨询顾问。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>