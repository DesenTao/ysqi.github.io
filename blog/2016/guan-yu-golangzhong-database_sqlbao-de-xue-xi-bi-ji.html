<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>关于Golang中database_sql包的学习笔记 |虞双齐Golang开发与SRE运维</title><meta name="description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没"><meta name="keywords" content="sql, 数据库, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html"><meta property="og:title" content="关于Golang中database_sql包的学习笔记"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:24"><meta property="article:modified_time" content="2016-12-31 11:34:24"><meta property="article:tag" content="sql"><meta property="article:tag" content="数据库"><meta property="article:tag" content="golang"><meta name="og:description" content="因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html">关于Golang中database_sql包的学习笔记</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000003036452" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><blockquote><p>因为最近在学习Go，所以找了revel这个框架来学习，感觉和php的面向对象有很大不同。revel没有提供db mapping的组件，所以在github上搜了很多ORM来学习，在<code>jmoiron/sqlx</code>中发现了一篇比较详细介绍<code>database/sql</code>这个包的文章，拿来和大家分享。本文并不是按字句的翻译，如果哪里表述不清楚建议阅读原文 <a href="http://go-database-sql.org/index.html">原文地址</a></p></blockquote><h2 id="概述">概述</h2><p><code>sql.DB</code>不是一个连接，它是数据库的抽象接口。它可以根据driver打开关闭数据库连接，管理连接池。正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。</p><h2 id="使用db">使用DB</h2><h3 id="导入driver">导入driver</h3><p>这里使用的是<a href="https://github.com/go-sql-driver/mysql">MySQL drivers</a></p><pre><code>import (
    &quot;database/sql&quot;
    _ &quot;github.com/go-sql-driver/mysql&quot;
)
</code></pre><h3 id="连接db">连接DB</h3><pre><code>func main() {
    db, err := sql.Open(&quot;mysql&quot;,
        &quot;user:password@tcp(127.0.0.1:3306)/hello&quot;)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
}
</code></pre><p><code>sql.Open</code>的第一个参数是driver名称，第二个参数是driver连接数据库的信息，各个driver可能不同。DB不是连接，并且只有当需要使用时才会创建连接，如果想立即验证连接，需要用<code>Ping()</code>方法，如下：</p><pre><code>err = db.Ping()
if err != nil {
    // do something here
}
</code></pre><p>sql.DB的设计就是用来作为长连接使用的。不要频繁Open, Close。比较好的做法是，为每个不同的datastore建一个DB对象，保持这些对象Open。如果需要短连接，那么把DB作为参数传入function，而不要在function中Open, Close。</p><h3 id="读取db">读取DB</h3><p>如果方法包含<code>Query</code>，那么这个方法是用于查询并返回rows的。其他情况应该用<code>Exec()</code>。</p><pre><code>var (
    id int
    name string
)
rows, err := db.Query(&quot;select id, name from users where id = ?&quot;, 1)
if err != nil {
    log.Fatal(err)
}
defer rows.Close()
for rows.Next() {
    err := rows.Scan(&amp;id, &amp;name)
    if err != nil {
        log.Fatal(err)
    }
    log.Println(id, name)
}
err = rows.Err()
if err != nil {
    log.Fatal(err)
}
</code></pre><p>上面代码的过程为：<code>db.Query()</code>表示向数据库发送一个query，<code>defer rows.Close()</code>非常重要，遍历rows使用<code>rows.Next()</code>， 把遍历到的数据存入变量使用<code>rows.Scan()</code>, 遍历完成后检查error。有几点需要注意：</p><ol><li>检查遍历是否有error</li><li>结果集(rows)未关闭前，底层的连接处于繁忙状态。当遍历读到最后一条记录时，会发生一个内部EOF错误，自动调用<code>rows.Close()</code>，但是如果提前退出循环，rows不会关闭，连接不会回到连接池中，连接也不会关闭。所以手动关闭非常重要。<code>rows.Close()</code>可以多次调用，是无害操作。</li></ol><h3 id="单行query">单行Query</h3><p>err在<code>Scan</code>后才产生，所以可以如下写：</p><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    log.Fatal(err)
}
fmt.Println(name)
</code></pre><h2 id="修改数据-事务">修改数据，事务</h2><p>一般用Prepared Statements和<code>Exec()</code>完成<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>操作。</p><pre><code>stmt, err := db.Prepare(&quot;INSERT INTO users(name) VALUES(?)&quot;)
if err != nil {
    log.Fatal(err)
}
res, err := stmt.Exec(&quot;Dolly&quot;)
if err != nil {
    log.Fatal(err)
}
lastId, err := res.LastInsertId()
if err != nil {
    log.Fatal(err)
}
rowCnt, err := res.RowsAffected()
if err != nil {
    log.Fatal(err)
}
log.Printf(&quot;ID = %d, affected = %d\n&quot;, lastId, rowCnt)
</code></pre><h3 id="事务">事务</h3><p><code>db.Begin()</code>开始事务，<code>Commit()</code> 或 <code>Rollback()</code>关闭事务。<code>Tx</code>从连接池中取出一个连接，在关闭之前都是使用这个连接。Tx不能和DB层的<code>BEGIN</code>, <code>COMMIT</code>混合使用。</p><p>如果你需要通过多条语句修改连接状态，你必须使用Tx，例如：</p><ul><li>创建仅对单个连接可见的临时表</li><li>设置变量，例如<code>SET @var := somevalue</code></li><li>改变连接选项，例如字符集，超时</li></ul><h2 id="prepared-statements">Prepared Statements</h2><h3 id="prepared-statements-and-connection">Prepared Statements and Connection</h3><p>在数据库层面，Prepared Statements是和单个数据库连接绑定的。客户端发送一个有占位符的statement到服务端，服务器返回一个statement ID，然后客户端发送ID和参数来执行statement。</p><p>在GO中，连接不直接暴露，你不能为连接绑定statement，而是只能为DB或Tx绑定。<code>database/sql</code>包有自动重试等功能。当你生成一个Prepared Statement</p><ol><li>自动在连接池中绑定到一个空闲连接</li><li><code>Stmt</code>对象记住绑定了哪个连接</li><li>执行<code>Stmt</code>时，尝试使用该连接。如果不可用，例如连接被关闭或繁忙中，会自动re-prepare，绑定到另一个连接。</li></ol><p>这就导致在高并发的场景，过度使用statement可能导致statement泄漏，statement持续重复prepare和re-prepare的过程，甚至会达到服务器端statement数量上限。</p><p>某些操作使用了PS，例如<code>db.Query(sql, param1, param2)</code>, 并在最后自动关闭statement。</p><p>有些场景不适合用statement：</p><ol><li>数据库不支持。例如Sphinx，MemSQL。他们支持MySQL wire protocol, 但不支持&rdquo;binary&rdquo; protocol。</li><li>statement不需要重用很多次，并且有其他方法保证安全。<a href="https://vividcortex.com/blog/2014/11/19/analyzing-prepared-statement-performance-with-vividcortex/">例子</a></li></ol><h3 id="在transaction中使用ps">在Transaction中使用PS</h3><p>PS在Tx中唯一绑定一个连接，不会re-prepare。</p><p>Tx和statement不能分离，在DB中创建的statement也不能在Tx中使用，因为他们必定不是使用同一个连接使用Tx必须十分小心，例如下面的代码：</p><pre><code>tx, err := db.Begin()
if err != nil {
    log.Fatal(err)
}
defer tx.Rollback()
stmt, err := tx.Prepare(&quot;INSERT INTO foo VALUES (?)&quot;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close() // danger!
for i := 0; i &lt; 10; i++ {
    _, err = stmt.Exec(i)
    if err != nil {
        log.Fatal(err)
    }
}
err = tx.Commit()
if err != nil {
    log.Fatal(err)
}
// stmt.Close() runs here!
</code></pre><p><code>*sql.Tx</code>一旦释放，连接就回到连接池中，这里stmt在关闭时就无法找到连接。所以必须在Tx commit或rollback之前关闭statement。</p><h2 id="处理error">处理Error</h2><h3 id="循环rows的error">循环Rows的Error</h3><p>如果循环中发生错误会自动运行<code>rows.Close()</code>，用<code>rows.Err()</code>接收这个错误，Close方法可以多次调用。循环之后判断error是非常必要的。</p><pre><code>for rows.Next() {
    // ...
}
if err = rows.Err(); err != nil {
    // handle the error here
}
</code></pre><h3 id="关闭resultsets时的error">关闭Resultsets时的error</h3><p>如果你在rows遍历结束之前退出循环，必须手动关闭Resultset，并且接收error。</p><pre><code>for rows.Next() {
    // ...
    break; // whoops, rows is not closed! memory leak...
}
// do the usual &quot;if err = rows.Err()&quot; [omitted here]...
// it's always safe to [re?]close here:
if err = rows.Close(); err != nil {
    // but what should we do if there's an error?
    log.Println(err)
}
</code></pre><h3 id="queryrow-的error">QueryRow()的error</h3><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    log.Fatal(err)
}
fmt.Println(name)
</code></pre><p>如果id为1的不存在，err为sql.ErrNoRows，一般应用中不存在的情况都需要单独处理。此外，Query返回的错误都会延迟到Scan被调用，所以应该写成如下代码：</p><pre><code>var name string
err = db.QueryRow(&quot;select name from users where id = ?&quot;, 1).Scan(&amp;name)
if err != nil {
    if err == sql.ErrNoRows {
        // there were no rows, but otherwise no error occurred
    } else {
        log.Fatal(err)
    }
}
fmt.Println(name)
</code></pre><p>把空结果当做Error处理是为了强行让程序员处理结果为空的情况</p><h3 id="分析数据库error">分析数据库Error</h3><p>各个数据库处理方式不太一样，mysql为例：</p><pre><code>if driverErr, ok := err.(*mysql.MySQLError); ok { 
    // Now the error number is accessible directly
    if driverErr.Number == 1045 {
        // Handle the permission-denied error
    }
}
</code></pre><p><code>MySQLError</code>, <code>Number</code>都是DB特异的，别的数据库可能是别的类型或字段。这里的数字可以替换为常量，例如这个包 <a href="https://github.com/VividCortex/mysqlerr">MySQL error numbers maintained by VividCortex</a></p><h3 id="连接错误">连接错误</h3><h2 id="null值处理">NULL值处理</h2><p>简单说就是设计数据库的时候不要出现null，处理起来非常费力。Null的type很有限，例如没有<code>sql.NullUint64</code>; null值没有默认零值。</p><pre><code>for rows.Next() {
    var s sql.NullString
    err := rows.Scan(&amp;s)
    // check err
    if s.Valid {
       // use s.String
    } else {
       // NULL value
    }
}
</code></pre><h2 id="未知column">未知Column</h2><p><code>rows.Columns()</code>的使用，用于处理不能得知结果字段个数或类型的情况，例如：</p><pre><code>cols, err := rows.Columns()
if err != nil {
    // handle the error
} else {
    dest := []interface{}{ // Standard MySQL columns
        new(uint64), // id
        new(string), // host
        new(string), // user
        new(string), // db
        new(string), // command
        new(uint32), // time
        new(string), // state
        new(string), // info
    }
    if len(cols) == 11 {
        // Percona Server
    } else if len(cols) &gt; 8 {
        // Handle this case
    }
    err = rows.Scan(dest...)
    // Work with the values in dest
}

cols, err := rows.Columns() // Remember to check err afterwards
vals := make([]interface{}, len(cols))
for i, _ := range cols {
    vals[i] = new(sql.RawBytes)
}
for rows.Next() {
    err = rows.Scan(vals...)
    // Now you can check each element of vals for nil-ness,
    // and you can use type introspection and type assertions
    // to fetch the column into a typed variable.
}
</code></pre><h2 id="关于连接池">关于连接池</h2><ol><li>避免错误操作，例如LOCK TABLE后用 INSERT会死锁，因为两个操作不是同一个连接，insert的连接没有table lock。</li><li>当需要连接，且连接池中没有可用连接时，新的连接就会被创建。</li><li>默认没有连接上限，你可以设置一个，但这可能会导致数据库产生错误“too many connections”</li><li><code>db.SetMaxIdleConns(N)</code>设置最大空闲连接数</li><li><code>db.SetMaxOpenConns(N)</code>设置最大打开连接数</li><li>长时间保持空闲连接可能会导致db timeout</li></ol></div><aside id="meta"><meta itemprop="wordCount" content="675"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/sql.html" rel="tag">sql</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93.html" rel="tag">数据库</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/kingshard--yi-ge-zhi-chi-shardingde-mysql-proxyxiang-mu.html">kingshard--一个支持sharding的MySQLProxy项目</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/tong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html">通过Mesos、Docker和Go使用300行代码创建一个分布式系统</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="0e94bcb69e90108102f9e2a4e34a3318" data-title="关于Golang中database_sql包的学习笔记" data-url="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fguan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fguan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-#Golang开发 #SRE运维。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>