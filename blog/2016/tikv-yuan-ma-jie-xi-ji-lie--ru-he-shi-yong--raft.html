<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>TiKV源码解析系列-如何使用Raft |虞双齐的博客</title><meta name="description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 T"><meta name="keywords" content="mysql, rust, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.31.1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐的博客"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html"><meta property="og:title" content="TiKV源码解析系列-如何使用Raft"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:32:35"><meta property="article:modified_time" content="2016-12-31 11:32:35"><meta property="article:tag" content="mysql"><meta property="article:tag" content="rust"><meta property="article:tag" content="golang"><meta name="og:description" content="TiKV 源码解析系列——如何使用 Raft 本系列文章主要面向 TiKV 社区开发者，重点介绍 T"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=201709"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html">TiKV源码解析系列-如何使用Raft</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000008006649" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h1 id="tikv-源码解析系列-如何使用-raft">TiKV 源码解析系列——如何使用 Raft</h1><p>本系列文章主要面向 TiKV 社区开发者，重点介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读之后，能对 TiKV 项目有一个初步了解，更好的参与进入 TiKV 的开发中。<br>需要注意，TiKV 使用 Rust 语言编写，用户需要对 Rust 语言有一个大概的了解。另外，本系列文章并不会涉及到 TiKV 中心控制服务 Placement Driver(PD) 的详细介绍，但是会说明一些重要流程 TiKV 是如何与 PD 交互的。<br>TiKV 是一个分布式的 KV 系统，它采用 Raft 协议保证数据的强一致性，同时使用 MVCC + 2PC 的方式实现了分布式事务的支持。</p><h3 id="概述">概述</h3><p>本文档主要面向 TiKV 社区开发者，主要介绍 TiKV 的系统架构，源码结构，流程解析。目的是使得开发者阅读文档之后，能对 TiKV 项目有一个初步了解，更好的参与进入 TiKV 的开发中。</p><p>需要注意，TiKV 使用 <a href="https://www.rust-lang.org/zh-CN/">Rust</a> 语言编写，用户需要对 Rust 语言有一个大概的了解。另外，本文档并不会涉及到 TiKV 中心控制服务 Placement Driver(PD) 的详细介绍，但是会说明一些重要流程 TiKV 是如何与 PD 交互的。</p><p>TiKV 是一个分布式的 KV 系统，它采用 Raft 协议保证数据的强一致性，同时使用 MVCC + 2PC 的方式实现了分布式事务的支持。</p><h3 id="架构">架构</h3><p>TiKV 的整体架构比较简单，如下：</p><p><strong>Placement Driver</strong> : Placement Driver (PD) 负责整个集群的管理调度。</p><p><strong>Node</strong> : Node 可以认为是一个实际的物理机器，每个 Node 负责一个或者多个 Store。</p><p><strong>Store</strong> : Store 使用 RocksDB 进行实际的数据存储，通常一个 Store 对应一块硬盘。</p><p><strong>Region</strong> : Region 是数据移动的最小单元，对应的是 Store 里面一块实际的数据区间。每个 Region 会有多个副本（replica），每个副本位于不同的 Store ，而这些副本组成了一个 Raft group。</p><h3 id="raft">Raft</h3><p>TiKV 使用 Raft 算法实现了分布式环境下面数据的强一致性，关于 Raft，可以参考论文 “<a href="https://raft.github.io/raft.pdf">In Search of an Understandable Consensus Algorithm</a>” 以及<a href="https://raft.github.io/">官网</a>，这里不做详细的解释。简单理解，Raft 是一个 replication log + State Machine 的模型，我们只能通过 leader 进行写入，leader 会将 command 通过 log 的形式复制到 followers，当集群的大多数节点都收到了这个 log，我们就认为这个 log 是 committed，可以 apply 到 State Machine 里面。</p><p>TiKV 的 Raft 主要移植 <a href="https://github.com/coreos/etcd/tree/master/raft">etcd Raft</a>，支持 Raft 所有功能，包括：</p><ul><li><p>Leader election</p></li><li><p>Log replicationLog compaction</p></li><li><p>Membership changesLeader transfer</p></li><li><p>Linearizable / Lease read</p></li></ul><p>这里需要注意，TiKV 以及 etcd 对于 membership change 的处理，跟 Raft 论文是稍微有一点不一样的，主要在于 TiKV 的 membership change 只有在 log applied 的时候生效，这样主要的目的是为了实现简单，但有一个风险在于如果我们只有两个节点，要从里面移掉一个节点，如果一个 follower 还没收到 ConfChange 的 log entry，leader 就当掉并且不可恢复了，整个集群就没法工作了。所以通常我们都建议用户部署 3 个或者更多个奇数个节点。</p><p>Raft 库是一个独立的库，用户也可以非常方便的将其直接嵌入到自己的应用程序，而仅仅只需要自行处理存储以及消息的发送。这里简单介绍一下如何使用 Raft，代码在 TiKV 源码目录的 /src/raft 下面。</p><h4 id="storage">Storage</h4><p>首先，我们需要定义自己的 Storage，Storage 主要用来存储 Raft 相关数据，trait 定义如下：</p><pre><code>pub trait Storage {
    fn initial_state(&amp;self) -&gt; Result&lt;RaftState&gt;;
    fn entries(&amp;self, low: u64, high: u64, max_size: u64) -&gt; Result&lt;Vec&lt;Entry&gt;&gt;;
    fn term(&amp;self, idx: u64) -&gt; Result&lt;u64&gt;;
    fn first_index(&amp;self) -&gt; Result&lt;u64&gt;;
    fn last_index(&amp;self) -&gt; Result&lt;u64&gt;;
    fn snapshot(&amp;self) -&gt; Result&lt;Snapshot&gt;;
}
</code></pre><p>我们需要实现自己的 Storage trait，这里详细解释一下各个接口的含义：</p><p>initial_state：初始化 Raft Storage 的时候调用，它会返回一个 RaftState，RaftState 的定义如下：</p><pre><code>pub struct RaftState {
    pub hard_state: HardState,
    pub conf_state: ConfState,
}
</code></pre><p>HardState 和 ConfState 是 protobuf，定义：</p><pre><code>message HardState {
    optional uint64 term   = 1; 
    optional uint64 vote   = 2; 
    optional uint64 commit = 3; 
}

message ConfState {
    repeated uint64 nodes = 1;
}
</code></pre><p>在 HardState 里面，保存着该 Raft 节点最后一次保存的 term 信息，之前 vote 的哪一个节点，以及已经 commit 的 log index。而 ConfState 则是保存着 Raft 集群所有的节点 ID 信息。</p><p>在外面调用 Raft 相关逻辑的时候，用户需要自己处理 RaftState 的持久化。</p><p><strong>entries</strong>: 得到 [low, high) 区间的 Raft log entry，通过 max_size 来控制最多返回多少个 entires。</p><p>term，first_index 和 last_index 分别是得到当前的 term，以及最小和最后的 log index。</p><p><strong>snapshot</strong>：得到当前的 Storage 的一个 snapshot，有时候，当前的 Storage 数据量已经比较大，生成 snapshot 会比较耗时，所以我们可能得在另一个线程异步去生成，而不用阻塞当前 Raft 线程，这时候，可以返回 SnapshotTemporarilyUnavailable 错误，这时候，Raft 就知道正在准备 snapshot，会一段时间之后再次尝试。</p><p>需要注意，上面的 Storage 接口只是 Raft 库需要的，实际我们还会用这个 Storage 存储 raft log 等数据，所以还需要单独提供其他的接口。在 Raft storage.rs 里面，我们提供了一个 MemStorage，用于测试，大家也可以参考 MemStorage 来实现自己的 Storage。</p><h4 id="config">Config</h4><p>在使用 Raft 之前，我们需要知道 Raft 一些相关的配置，在 Config 里面定义，这里只列出需要注意的：</p><pre><code>pub struct Config {
    pub id: u64,
    pub election_tick: usize,
    pub heartbeat_tick: usize,
    pub applied: u64,
    pub max_size_per_msg: u64,
    pub max_inflight_msgs: usize,
}
</code></pre><p><strong>id</strong>: Raft 节点的唯一标识，在一个 Raft 集群里面，id 是不可能重复的。在 TiKV 里面，id 的通过 PD 来保证全局唯一。</p><p><strong>election_tick</strong>：当 follower 在 election_tick 的时间之后还没有收到 leader 发过来的消息，那么就会重新开始选举，TiKV 默认使用 50。</p><p><strong>heartbeat_tick</strong>: leader 每隔 hearbeat_tick 的时间，都会给 follower 发送心跳消息。默认 10。</p><p><strong>applied</strong>: applied 是上一次已经被 applied 的 log index。</p><p><strong>max_size_per_msg</strong>: 限制每次发送的最大 message size。默认 1MB。</p><p><strong>max_inflight_msgs</strong>: 限制复制时候最大的 in-flight 的 message 的数量。默认 256。</p><p>这里详细解释一下 tick 的含义，TiKV 的 Raft 是定时驱动的，假设我们每隔 100ms 调用一次 Raft tick，那么当调用到 headtbeat_tick 的 tick 次数之后，leader 就会给 follower 发送心跳。</p><h4 id="rawnode">RawNode</h4><p>我们通过 RawNode 来使用 Raft，RawNode 的构造函数如下：</p><pre><code>pub fn new(config: &amp;Config, store: T, peers: &amp;[Peer]) -&gt; Result&lt;RawNode&lt;T&gt;&gt; 
</code></pre><p>我们需要定义 Raft 的 Config，然后传入一个实现好的 Storage，peers 这个参数只是用于测试，实际要传空。生成好 RawNode 对象之后，我们就可以使用 Raft 了。我们关注如下几个函数：</p><p><strong>tick</strong>: 我们使用 tick 函数定期驱动 Raft，在 TiKV，我们每隔 100ms 调用一次 tick。</p><p><strong>propose</strong>: leader 通过 propose 命令将 client 发过来的 command 写入到 raft log，并复制给其他节点。</p><p><strong>propose_conf_change</strong>: 跟 propose 类似，只是单独用来处理 ConfChange 命令。</p><p><strong>step</strong>: 当节点收到其他节点发过来的 message，主动调用驱动 Raft。</p><p><strong>has_ready</strong>: 用来判断一个节点是不是 ready 了。</p><p><strong>ready</strong>: 得到当前节点的 ready 状态，我们会在之前用 has_ready 来判断一个 RawNode 是否 ready。</p><p><strong>apply_conf_change</strong>: 当一个 ConfChange 的 log 被成功 applied，需要主动调用这个驱动 Raft。</p><p><strong>advance</strong>: 告诉 Raft 已经处理完 ready，开始后续的迭代。</p><p>对于 RawNode，我们这里重点关注下 ready 的概念，ready 的定义如下：</p><pre><code>pub struct Ready {
    pub ss: Option&lt;SoftState&gt;,
    pub hs: Option&lt;HardState&gt;,
    pub entries: Vec&lt;Entry&gt;,
    pub snapshot: Snapshot,
    pub committed_entries: Vec&lt;Entry&gt;,
    pub messages: Vec&lt;Message&gt;,
}
</code></pre><p><strong>ss</strong>: 如果 SoftState 变更，譬如添加，删除节点，ss 就不会为空。</p><p><strong>hs</strong>: 如果 HardState 有变更，譬如重新 vote，term 增加，hs 就不会为空。</p><p><strong>entries</strong>: 需要在 messages 发送之前存储到 Storage。</p><p><strong>snapshot</strong>: 如果 snapshot 不是 empty，则需要存储到 Storage。</p><p><strong>committed_entries</strong>: 已经被 committed 的 raft log，可以 apply 到 State Machine 了。</p><p><strong>messages</strong>: 给其他节点发送的消息，通常需要在 entries 保存成功之后才能发送，但对于 leader 来说，可以先发送 messages，在进行 entries 的保存，这个是 Raft 论文里面提到的一个优化方式，TiKV 也采用了。</p><p>当外部发现一个 RawNode 已经 ready 之后，得到 Ready，处理如下：</p><ol><li><p>持久化非空的 ss 以及 hs。</p></li><li><p>如果是 leader，首先发送 messages。</p></li><li><p>如果 snapshot 不为空，保存 snapshot 到 Storage，同时将 snapshot 里面的数据异步应用到 State Machine（这里虽然也可以同步 apply，但 snapshot 通常比较大，同步会 block 线程）。</p></li><li><p>将 entries 保存到 Storage 里面。</p></li><li><p>如果是 follower，发送 messages。</p></li><li><p>将 committed_entries apply 到 State Machine。</p></li><li><p>调用 advance 告知 Raft 已经处理完 ready。</p></li></ol><p>（未完待续…）</p></div><aside id="meta"><meta itemprop="wordCount" content="670"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/mysql.html" rel="tag">mysql</a> <a href="/tags/rust.html" rel="tag">rust</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/tikv-yuan-ma-jie-xi-ji-lie--multi-raft-she-ji-yu-shi-xian.html">TiKV源码解析系列-multi-raft设计与实现</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/da-jian-golangban-ssfu-wu.html">搭建golang版ss服务</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sid="a92e02e236fb1a064a9be73b925e0054"></div><div id="cyReward" role="cylabs" data-use="reward" sid="a92e02e236fb1a064a9be73b925e0054" style="text-align:center"></div><div id="SOHUCS" sid="a92e02e236fb1a064a9be73b925e0054"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li><li class="rel_linksli"><a href="https://www.zhihu.com/people/_ysqi" title="访问虞双齐的知乎" rel="nofollow">我的 知乎</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics.html"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionWeibo">Weibo</span></a></li><li><a class="footeraction" href="https://www.zhihu.com/people/_ysqi" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionZhiHu">知乎</span></a></li><li><a class="footeraction" href="/index.xml" title="RSS订阅 虞双齐"><span class="footeractionRSS">Feed</span></a></li><li><a class="footeraction" href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ftikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html" rel="nofollow" target="blank"><span class="footeractionW3CHTML">Valid XHTMl 4.0</span></a></li><li><a class="footeraction" href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ftikv-yuan-ma-jie-xi-ji-lie--ru-he-shi-yong--raft.html" rel="nofollow" target="blank"><span class="footeractionW3CCSS">Valid CSS Leval2</span></a></li></ul><p>©2015-2016 虞双齐-全栈开发。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>