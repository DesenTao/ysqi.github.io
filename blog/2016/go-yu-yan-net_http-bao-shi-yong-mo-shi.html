<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语言net_http包使用模式 |虞双齐Go语言技术独立咨询顾问</title><meta name="description" content="译注: 这篇文章的内容非常基础，也非常容易理解。原文地址，感觉是最能清晰的讲述了net/http包的"><meta name="keywords" content="go-web-framework, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Go语言技术独立咨询顾问"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html"><meta property="og:title" content="Go语言net_http包使用模式"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:33:08"><meta property="article:modified_time" content="2016-12-31 11:33:08"><meta property="article:tag" content="go-web-framework"><meta property="article:tag" content="golang"><meta name="og:description" content="译注: 这篇文章的内容非常基础，也非常容易理解。原文地址，感觉是最能清晰的讲述了net/http包的"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html">Go语言net_http包使用模式</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000006812688" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>译注: 这篇文章的内容非常基础，也非常容易理解。<a href="http://www.alexedwards.net/blog/a-recap-of-request-handling">原文地址</a>，感觉是最能清晰的讲述了<code>net/http</code>包的用法的一篇，故翻译一下共享之。</p><h2 id="一切的基础-servemux-和-handler">一切的基础：ServeMux 和 Handler</h2><p>Go 语言中处理 HTTP 请求主要跟两个东西相关：<code>ServeMux</code> 和 <code>Handler</code>。</p><p><a href="http://golang.org/pkg/net/http/#ServeMux"><code>ServrMux</code></a> 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。</p><p><strong>处理器（Handler）</strong>负责输出HTTP响应的头和正文。任何满足了<a href="http://golang.org/pkg/net/http/#Handler"><code>http.Handler</code>接口</a>的对象都可作为一个处理器。通俗的说，对象只要有个如下签名的<code>ServeHTTP</code>方法即可：</p><pre><code>ServeHTTP(http.ResponseWriter, *http.Request)
</code></pre><p>Go 语言的 HTTP 包自带了几个函数用作常用处理器，比如<a href="http://golang.org/pkg/net/http/#FileServer"><code>FileServer</code></a>，<a href="http://golang.org/pkg/net/http/#NotFoundHandler"><code>NotFoundHandler</code></a> 和 <a href="http://golang.org/pkg/net/http/#RedirectHandler"><code>RedirectHandler</code></a>。我们从一个简单具体的例子开始：</p><pre><code>$ mkdir handler-example
$ cd handler-example
$ touch main.go

//File: main.go
package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
)

func main() {
  mux := http.NewServeMux()

  rh := http.RedirectHandler(&quot;http://example.org&quot;, 307)
  mux.Handle(&quot;/foo&quot;, rh)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><p>快速地过一下代码：</p><ul><li><p>在 <code>main</code> 函数中我们只用了 <a href="http://golang.org/pkg/net/http/#NewServeMux"><code>http.NewServeMux</code></a> 函数来创建一个空的 <code>ServeMux</code>。</p></li><li><p>然后我们使用 <a href="http://golang.org/pkg/net/http/#RedirectHandler"><code>http.RedirectHandler</code></a> 函数创建了一个新的处理器，这个处理器会对收到的所有请求，都执行307重定向操作到 <code>http://example.org</code>。</p></li><li><p>接下来我们使用 <a href="http://golang.org/pkg/net/http/#ServeMux.Handle"><code>ServeMux.Handle</code></a> 函数将处理器注册到新创建的 <code>ServeMux</code>，所以它在 URL 路径<code>/foo</code> 上收到所有的请求都交给这个处理器。</p></li><li><p>最后我们创建了一个新的服务器，并通过 <a href="http://golang.org/pkg/net/http/#ListenAndServe"><code>http.ListenAndServe</code></a> 函数监听所有进入的请求，通过传递刚才创建的 <code>ServeMux</code>来为请求去匹配对应处理器。</p></li></ul><p>继续，运行一下这个程序:</p><pre><code>$ go run main.go
Listening...
</code></pre><p>然后在浏览器中访问 <code>http://localhost:3000/foo</code>，你应该能发现请求已经成功的重定向了。</p><p>明察秋毫的你应该能注意到一些有意思的事情：<code>ListenAndServer</code> 的函数签名是 <code>ListenAndServe(addr string, handler Handler)</code> ，但是第二个参数我们传递的是个 <code>ServeMux</code>。</p><p>我们之所以能这么做，是因为 <code>ServeMux</code> 也有 <code>ServeHTTP</code> 方法，因此它也是个合法的 <code>Handler</code>。</p><p>对我来说，将 <code>ServerMux</code> 用作一个特殊的Handler是一种简化。它不是自己输出响应而是将请求传递给注册到它的其他 Handler。这乍一听起来不是什么明显的飞跃 - 但在 Go 中将 <code>Handler</code> 链在一起是非常普遍的用法。</p><h3 id="自定义处理器-custom-handlers">自定义处理器（Custom Handlers）</h3><p>让我们创建一个自定义的处理器，功能是将以特定格式输出当前的本地时间：</p><pre><code>type timeHandler struct {
  format string
}

func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  tm := time.Now().Format(th.format)
  w.Write([]byte(&quot;The time is: &quot; + tm))
}
</code></pre><p>这个例子里代码本身并不是重点。</p><p>真正的重点是我们有一个对象（本例中就是个<code>timerHandler</code>结构体，但是也可以是一个字符串、一个函数或者任意的东西），我们在这个对象上实现了一个 <code>ServeHTTP(http.ResponseWriter, *http.Request)</code> 签名的方法，这就是我们创建一个处理器所需的全部东西。</p><p>我们把这个集成到具体的示例里：</p><pre><code>//File: main.go

package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;time&quot;
)

type timeHandler struct {
  format string
}

func (th *timeHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
  tm := time.Now().Format(th.format)
  w.Write([]byte(&quot;The time is: &quot; + tm))
}

func main() {
  mux := http.NewServeMux()

  th := &amp;timeHandler{format: time.RFC1123}
  mux.Handle(&quot;/time&quot;, th)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><p><code>main</code>函数中，我们像初始化一个常规的结构体一样，初始化了<code>timeHandler</code>，用 <code>&amp;</code> 符号获得了其地址。随后，像之前的例子一样，我们使用 <code>mux.Handle</code> 函数来将其注册到 <code>ServerMux</code>。</p><p>现在当我们运行这个应用，<code>ServerMux</code> 将会将任何对 <code>/time</code>的请求直接交给 <code>timeHandler.ServeHTTP</code> 方法处理。</p><p>访问一下这个地址看一下效果：<a href="http://localhost:3000/time">http://localhost:3000/time</a> 。</p><p>注意我们可以在多个路由中轻松的复用 <code>timeHandler</code>：</p><pre><code>func main() {
  mux := http.NewServeMux()

  th1123 := &amp;timeHandler{format: time.RFC1123}
  mux.Handle(&quot;/time/rfc1123&quot;, th1123)

  th3339 := &amp;timeHandler{format: time.RFC3339}
  mux.Handle(&quot;/time/rfc3339&quot;, th3339)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><h3 id="将函数作为处理器">将函数作为处理器</h3><p>对于简单的情况（比如上面的例子），定义个新的有 <code>ServerHTTP</code> 方法的自定义类型有些累赘。我们看一下另外一种方式，我们借助 <a href="http://golang.org/pkg/net/http/#HandlerFunc"><code>http.HandlerFunc</code></a> 类型来让一个常规函数满足作为一个 <code>Handler</code> 接口的条件。</p><p>任何有 <code>func(http.ResponseWriter, *http.Request)</code> 签名的函数都能转化为一个 <code>HandlerFunc</code> 类型。这很有用，因为 <code>HandlerFunc</code> 对象内置了 <code>ServeHTTP</code> 方法，后者可以聪明又方便的调用我们最初提供的函数内容。</p><p>如果你听起来还有些困惑，可以尝试看一下[相关的源代码]<a href="http://golang.org/src/pkg/net/http/server.go?s=35455:35502#L1221()">http://golang.org/src/pkg/net&hellip;</a>。你将会看到让一个函数对象满足 <code>Handler</code> 接口是非常简洁优雅的。</p><p>让我们使用这个技术重新实现一遍<code>timeHandler</code>应用：</p><pre><code>//File: main.go
package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;time&quot;
)

func timeHandler(w http.ResponseWriter, r *http.Request) {
  tm := time.Now().Format(time.RFC1123)
  w.Write([]byte(&quot;The time is: &quot; + tm))
}

func main() {
  mux := http.NewServeMux()

  // Convert the timeHandler function to a HandlerFunc type
  th := http.HandlerFunc(timeHandler)
  // And add it to the ServeMux
  mux.Handle(&quot;/time&quot;, th)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><p>实际上，将一个函数转换成 <code>HandlerFunc</code> 后注册到 <code>ServeMux</code> 是很普遍的用法，所以 Go 语言为此提供了个便捷方式：<a href="http://golang.org/pkg/net/http/#ServeMux.HandleFunc"><code>ServerMux.HandlerFunc</code></a> 方法。</p><p>我们使用便捷方式重写 <code>main()</code> 函数看起来是这样的：</p><pre><code>func main() {
  mux := http.NewServeMux()

  mux.HandleFunc(&quot;/time&quot;, timeHandler)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><p>绝大多数情况下这种用函数当处理器的方式工作的很好。但是当事情开始变得更复杂的时候，就会有些产生一些限制了。</p><p>你可能已经注意到了，跟之前的方式不同，我们不得不将时间格式硬编码到 <code>timeHandler</code> 的方法中。如果我们想从 <code>main()</code> 函数中传递一些信息或者变量给处理器该怎么办？</p><p>一个优雅的方式是将我们处理器放到一个闭包中，将我们要使用的变量带进去：</p><pre><code>//File: main.go
package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;time&quot;
)

func timeHandler(format string) http.Handler {
  fn := func(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(format)
    w.Write([]byte(&quot;The time is: &quot; + tm))
  }
  return http.HandlerFunc(fn)
}

func main() {
  mux := http.NewServeMux()

  th := timeHandler(time.RFC1123)
  mux.Handle(&quot;/time&quot;, th)

  log.Println(&quot;Listening...&quot;)
  http.ListenAndServe(&quot;:3000&quot;, mux)
}
</code></pre><p><code>timeHandler</code> 函数现在有了个更巧妙的身份。除了把一个函数封装成 Handler(像我们之前做到那样)，我们现在使用它来返回一个处理器。这种机制有两个关键点：</p><p>首先是创建了一个<code>fn</code>，这是个匿名函数，将 <code>format</code> 变量封装到一个闭包里。闭包的本质让处理器在任何情况下，都可以在本地范围内访问到 <code>format</code> 变量。</p><p>其次我们的闭包函数满足 <code>func(http.ResponseWriter, *http.Request)</code> 签名。如果你记得之前我们说的，这意味我们可以将它转换成一个<code>HandlerFunc</code>类型（满足了<code>http.Handler</code>接口）。我们的<code>timeHandler</code> 函数随后转换后的 <code>HandlerFunc</code> 返回。</p><p>在上面的例子中我们已经可以传递一个简单的字符串给处理器。但是在实际的应用中可以使用这种方法传递数据库连接、模板组，或者其他应用级的上下文。使用全局变量也是个不错的选择，还能得到额外的好处就是编写更优雅的自包含的处理器以便测试。</p><p>你也可能见过相同的写法，像这样：</p><pre><code>func timeHandler(format string) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(format)
    w.Write([]byte(&quot;The time is: &quot; + tm))
  })
}
</code></pre><p>或者在返回时，使用一个到 <code>HandlerFunc</code> 类型的隐式转换：</p><pre><code>func timeHandler(format string) http.HandlerFunc {
  return func(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(format)
    w.Write([]byte(&quot;The time is: &quot; + tm))
  }
}
</code></pre><h3 id="更便利的-defaultservemux">更便利的 DefaultServeMux</h3><p>你可能已经在很多地方看到过 <code>DefaultServeMux</code>, 从最简单的 <code>Hello World</code> 例子，到 go 语言的源代码中。</p><p>我花了很长时间才意识到 <code>DefaultServerMux</code> 并没有什么的特殊的地方。<code>DefaultServerMux</code> 就是我们之前用到的 <code>ServerMux</code>，只是它随着 <code>net/httpp</code> 包初始化的时候被自动初始化了而已。Go 源代码中的相关行如下：</p><pre><code>var DefaultServeMux = NewServeMux()
</code></pre><p><code>net/http</code> 包提供了一组快捷方式来配合 <code>DefaultServeMux</code>：<a href="http://golang.org/pkg/net/http/#Handle"><code>http.Handle</code></a> 和 <a href="http://golang.org/pkg/net/http/#HandleFunc"><code>http.HandleFunc</code></a>。这些函数与我们之前看过的类似的名称的函数功能一样，唯一的不同是他们将处理器注册到 <code>DefaultServerMux</code> ，而之前我们是注册到自己创建的 <code>ServeMux</code>。</p><p>此外，<code>ListenAndServe</code>在没有提供其他的处理器的情况下（也就是第二个参数设成了 <code>nil</code>），内部会使用 <code>DefaultServeMux</code>。</p><p>因此，作为最后一个步骤，我们使用 <code>DefaultServeMux</code> 来改写我们的 <code>timeHandler</code>应用：</p><pre><code>//File: main.go
package main

import (
  &quot;log&quot;
  &quot;net/http&quot;
  &quot;time&quot;
)

func timeHandler(format string) http.Handler {
  fn := func(w http.ResponseWriter, r *http.Request) {
    tm := time.Now().Format(format)
    w.Write([]byte(&quot;The time is: &quot; + tm))
  }
  return http.HandlerFunc(fn)
}

func main() {
  // Note that we skip creating the ServeMux...

  var format string = time.RFC1123
  th := timeHandler(format)

  // We use http.Handle instead of mux.Handle...
  http.Handle(&quot;/time&quot;, th)

  log.Println(&quot;Listening...&quot;)
  // And pass nil as the handler to ListenAndServe.
  http.ListenAndServe(&quot;:3000&quot;, nil)
}
</code></pre></div><aside id="meta"><meta itemprop="wordCount" content="572"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/go-web-framework.html" rel="tag">go-web-framework</a> <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/golangshen-me-shi-hou-ying-gai-ba-fang-fa-bang-ding-zai-structde-zhi-shang-er-bu-shi-zhi-zhen-shang.html">golang什么时候应该把方法绑定在struct的值上而不是指针上？</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/javascriptxin-xian-shi-di-6ji.html">JavaScript新鲜事·第6期</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="618bb5a31646cc7ff7da0e163e7d2a59" data-title="Go语言net_http包使用模式" data-url="https://yushuangqi.com/blog/2016/go-yu-yan-net_http-bao-shi-yong-mo-shi.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，Go语言技术独立咨询顾问。为国内客户提供Go语言开发、技术实战、架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Go语言技术独立咨询顾问">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgo-yu-yan-net_http-bao-shi-yong-mo-shi.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgo-yu-yan-net_http-bao-shi-yong-mo-shi.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Go语言技术独立咨询顾问。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>