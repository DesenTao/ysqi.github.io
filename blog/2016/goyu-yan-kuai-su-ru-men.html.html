<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语言快速入门 |虞双齐的博客</title><meta name="description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。
最近决定深入地学习这"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.31.1"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐的博客"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-kuai-su-ru-men.html.html"><meta property="og:title" content="Go语言快速入门"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:12"><meta property="article:modified_time" content="2016-12-31 11:34:12"><meta property="article:tag" content="golang"><meta name="og:description" content="一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。
最近决定深入地学习这"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=201709"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/goyu-yan-kuai-su-ru-men.html.html">Go语言快速入门</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000003856830" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>一年前为了给同事介绍Go而做的演讲文稿。一年过去，我对Go的理解没有任何进展。<br>最近决定深入地学习这门语言。</p><h1 id="hello-world">Hello World</h1><pre><code>package main

import &quot;fmt&quot;

// this is a comment

func main() {
    fmt.Println(&quot;Hello World&quot;)
}
</code></pre><h1 id="build-run">Build &amp; Run</h1><pre><code>$ cd D:\Go\src\github.com\sif\hello

$ go run main.go
Hello World

$ go build main.go

$ main.exe
Hello World

$ go clean
</code></pre><h1 id="executable-size">Executable Size</h1><p>Language</p><p>Executable Size (KB)</p><p>Comments</p><p>Go</p><p>1524</p><p>C++</p><p>12</p><p>Using cout. #include &lt;iostream&gt;</p><p>C++ (with runtime)</p><p>48</p><p>Using cout. #include &lt;iostream&gt;</p><p>C</p><p>7</p><p>Using printf() #include &lt;stdio.h&gt;</p><p>Go embeds the “virtual machine” into the executable.</p><h1 id="enviroment-variables">Enviroment Variables</h1><p>On 64bit Windows:</p><p>Name Value Comments</p><hr><p>GOARCH amd64<br>GOOS windows<br>GOPATH D:\Go Location of your workspaces. Can specify multiple workspaces. GOROOT C:\Go</p><p><strong>GOPATH</strong>可以指定多个workspaces。</p><h1 id="workspace-hierarchy">Workspace Hierarchy</h1><pre><code>bin\
    hello.exe

pkg\
    windows_amd64\
        carestream.com\dental\
            csi.a

src\
    github.com\sif\
        hello\
            hello.go
    carestream.com\dental\
        csi\
            patient.go
</code></pre><h1 id="doc-server">Doc Server</h1><p>Browse Go documents on <a href="http://localhost">http://localhost</a>:6060/</p><h1 id="basic-types">Basic Types</h1><h3 id="integer-numbers">Integer Numbers</h3><p><em>Integer types:</em><br><code>uint8, uint16, uint32, uint64, int8, int16, int32, int64</code></p><p><em>Two alias types:</em><br><code>byte (uint8) rune (int32)</code></p><p><em>Three machine dependent integer types:</em><br><code>uint, int, uintptr</code><br>They are machine dependent because their size depends on the type of architecture you are using.</p><p><em>Floating Point Numbers</em><br><code>float32, float64</code><br>Generally we should stick with float64 when working with floating point numbers.</p><p><em>Complex Numbers</em><br><code>complex64, complex128</code></p><p>Operators +, -, *, / and % are all the same as C.</p><h3 id="booleans">Booleans</h3><pre><code>func main() {
    fmt.Println(true &amp;&amp; true)
    fmt.Println(true &amp;&amp; false)
    fmt.Println(true || true)
    fmt.Println(true || false)
    fmt.Println(!true)
}
</code></pre><h3 id="strings">Strings</h3><p>Go strings are made up of individual bytes, usually one for each character.</p><pre><code>&quot;Hello \nWorld&quot;  // Similar to C/C++

`Hello
 World`  // Similar to Python “””

func main() {
    fmt.Println(len(&quot;Hello World&quot;))
    fmt.Println(&quot;Hello World&quot;[1])
    fmt.Println(&quot;Hello &quot; + &quot;World&quot;)
}
</code></pre><p>Characters from other languages like Chinese are represented by more than one byte.</p><pre><code>func main() {
    s := &quot;abc汉字&quot;

    for i := 0; i &lt; len(s); i++ { // byte
        fmt.Printf(&quot;%c,&quot;, s[i])
    }

    fmt.Println()
    for _, r := range s { // rune
        fmt.Printf(&quot;%c,&quot;, r)
    }
}
</code></pre><p>Output:</p><pre><code>a,b,c,æ,±,,å,,,
a,b,c,汉,字,
</code></pre><h3 id="enum">Enum</h3><pre><code>// A Month specifies a month of the year (January = 1, ...).
type Month int

const (
    January Month = 1 + iota
    February
    March
    April
    May
    // ...
    November
    December
)
</code></pre><h1 id="variables">Variables</h1><pre><code>func main() {
    var x string = &quot;Hello World&quot;
    fmt.Println(x)
}
</code></pre><p>Shorter form:</p><pre><code>x := &quot;Hello World&quot;
</code></pre><p>The type is not necessary because the Go compiler is able to infer the type based on the literal value you assign the variable.<br>The compiler can also do inference with the var statement:</p><pre><code>var x = &quot;Hello World&quot;
</code></pre><p>Generally you should use this shorter form whenever possible.</p><h3 id="scope">Scope</h3><p>The same as C.</p><h3 id="constants">Constants</h3><p>Constants are basically variables whose values cannot be changed later.</p><pre><code>func main() {
    const x string = &quot;Hello World&quot;
    fmt.Println(x)
}

const x string = &quot;Hello World&quot;
x = &quot;Some other string&quot;  // cannot assign to x
</code></pre><p>Constants must be numbers, strings and booleans which can be determined in compile time.</p><h3 id="defining-multiple-values">Defining Multiple Values</h3><pre><code>var (
    a = 5
    b = 10
    c = 15
)

const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)
</code></pre><h1 id="control-structures">Control Structures</h1><h3 id="if">IF</h3><p>可省略条件表达式括号。<br>支持初始化语句，可定义代码块局部变量。<br>代码块左大括号必须在条件表达式尾部。</p><pre><code>x := 0

if n := &quot;abc&quot;; x &gt; 0 {
    fmt.Println(n[2])
} else if x &lt; 0 {
    fmt.Println(n[1])
} else {
    fmt.Println(n[0])
}
</code></pre><p>但是，不支持三元操作符 &ldquo;a &gt; b ? a : b&rdquo;。</p><h3 id="for">FOR</h3><pre><code>s := &quot;abc&quot;

for i, n := 0, len(s); i &lt; n; i++ {    // 常见的 for 循环
    fmt.Println(s[i])
}

n := len(s)
for n &gt; 0 {                 // 替代 while (n &gt; 0) {}
    fmt.Println(s[n])             // 替代 for (; n &gt; 0;) {}
    n--
}

for {                         // 替代 while (true) {}
    fmt.Println(s)             // 替代 for (;;) {}
}
</code></pre><h3 id="range">Range</h3><p>类似迭代器操作，返回（索引，值）或（键，值）。</p><pre><code>            1st value   2nd value    
</code></pre><hr><p>string index s[index] unicode, rune array/slice index s[index]<br>map key m[key]<br>channel element</p><pre><code>s := &quot;abc&quot;

// 忽略 2nd value，支持 string/array/slice/map。
for i := range s {
    fmt.Println(s[i])
}

for _, c := range s {     // 忽略 index
    fmt.Println(c)
}

m := map[string]int{&quot;a&quot;: 1, &quot;b&quot;: 2}
for k, v := range m {     // 返回 (key, value)
    fmt.Println(k, v)
}
</code></pre><h3 id="switch">Switch</h3><p>分支表达式可以是任意类型，不限于常量。可省略 break，默认自动终止。</p><pre><code>x := []int{1, 2, 3}
i := 2

switch i {
case x[1]:        // 不限于常量
    fmt.Println(&quot;a&quot;)
case 1, 3:        // 多值匹配
    fmt.Println(&quot;b&quot;)
 default:
    fmt.Println(&quot;c&quot;)
}
</code></pre><p>如需要继续下一分支，可使用 fallthrough，但不再判断条件。</p><pre><code>x := 10

switch x {
case 10:
    fmt.Println(&quot;a&quot;)
    fallthrough
case 0:
    fmt.Println(&quot;b&quot;)
}
</code></pre><p>Output:</p><pre><code>a
b
</code></pre><p>省略条件表达式，可当 if&hellip;else if&hellip;else 使用。</p><pre><code>switch {
case x[1] &gt; 0:
    fmt.Println(&quot;a&quot;)
case x[1] &lt; 0:
    fmt.Println(&quot;b&quot;)
default:
    fmt.Println(&quot;c&quot;)
}

switch i := x[2]; { // 带初始化语句
case i &gt; 0:
    fmt.Println(&quot;a&quot;)
case i &lt; 0:
    fmt.Println(&quot;b&quot;)
default:
    fmt.Println(&quot;c&quot;)
}
</code></pre><h1 id="data-structures">Data Structures</h1><h3 id="array">Array</h3><pre><code>var a [4]int
fmt.Println(a)              // [0 0 0 0]
fmt.Println(len(a))          // 4
fmt.Println(cap(a))          // 4

var a = [2]string{&quot;Penn&quot;, &quot;Teller&quot;}
fmt.Println(a)              // [Penn Teller]
fmt.Println(len(a))          // 2

var a = [...]string{&quot;Penn&quot;, &quot;Teller&quot;}
fmt.Println(a)              // [Penn Teller]
fmt.Println(len(a))          // 2
</code></pre><p><strong>Similar to C but with differencies:</strong><br>Go&rsquo;s arrays are values. An array variable denotes the entire array; it is not a pointer to the first array element (as would be the case in C).</p><h3 id="slice">Slice</h3><p>The type specification for a slice:</p><pre><code>[]T
</code></pre><p>Slices build on arrays to provide great power and convenience. Unlike an array type, a slice type has no specified length.<br>Create with literal:</p><pre><code>var s = []int{0, 1, 2, 3, 4}
fmt.Println(s)              // [0 1 2 3 4]
fmt.Println(len(s))         // 5
fmt.Println(cap(s))         // 5
</code></pre><p>Create with built-in function make:</p><pre><code>func make([]T, len, cap) []T

var s = make([]int, 5, 10)
fmt.Println(s)              // [0 0 0 0 0]
fmt.Println(len(s))         // 5
fmt.Println(cap(s))         // 10
</code></pre><p>The zero value of a slice is nil.</p><pre><code>var s []int
fmt.Println(s)             // []
fmt.Println(s == nil)      // true
fmt.Println(len(s))        // 0
</code></pre><p>Create by &ldquo;slicing&rdquo; an existing slice or array.</p><pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte{'o', 'l', 'a'}
// b[:2] == []byte{'g', 'o'}
// b[2:] == []byte{'l', 'a', 'n', 'g'}
// b[:] == b
</code></pre><p>Create a slice given an array:</p><pre><code>b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
s := b[:]  // a slice referencing the storage of b
</code></pre><p>make([]byte, 5), is structured like this:</p><p>Re-slicing a slice doesn&rsquo;t make a copy of the underlying array.</p><pre><code>t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
</code></pre><p>Grow a slice by built-in function append:</p><pre><code>func append(s []T, x ...T) []T 

a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
</code></pre><p>Append one slice to another:</p><pre><code>a := []string{&quot;John&quot;, &quot;Paul&quot;}
b := []string{&quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
a = append(a, b...) // equivalent to &quot;append(a, b[0], b[1], b[2])&quot;
// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}
</code></pre><h3 id="map">Map</h3><p>A map is an unordered collection of key-value pairs.</p><pre><code>var x map[string]int
</code></pre><p>x is a map of strings to ints.</p><p>Maps have to be initialized before they can be used.\</p><pre><code>x := make(map[string]int)
x[&quot;10&quot;] = 10
fmt.Println(x[&quot;10&quot;])
</code></pre><p>Delete items from a map using the built-in delete function:</p><pre><code>delete(x, “10”)
</code></pre><p>Looking up a key which doesn&rsquo;t exist returns the zero value.</p><pre><code>fmt.Println(x[&quot;unexisted&quot;])  // 0
</code></pre><p>Similar to C++ std::map.<br>Accessing an element of a map can return two values instead of just one.</p><p>The first value is the result of the lookup,<br>The second tells us whether or not the lookup was successful.</p><p>In Go we often see code like this:</p><pre><code>if value, ok := x[&quot;0&quot;]; ok {
    fmt.Println(value, ok)
}
</code></pre><p>Shorter way to create maps:</p><pre><code>x := map[string]int{
    &quot;1&quot;: 1,
    &quot;2&quot;: 2,
    &quot;3&quot;: 3,
}
</code></pre><h3 id="set">Set</h3><p>No build-in support.</p><pre><code>map[X]struct{}
</code></pre><h1 id="functions">Functions</h1><pre><code>func main() {
    xs := []float64{98, 93, 77, 82, 83}
    fmt.Println(average(xs))
}

func average(xs []float64) float64 {
    total := 0.0
    for _, v := range xs {
        total += v
    }
    return total / float64(len(xs))
}
</code></pre><p>We can also name the return type:</p><pre><code>func average(xs []float64) (avg float64) {
    total := 0.0
    for _, v := range xs {
        total += v
    }
    avg = total / float64(len(xs))
    return
}
</code></pre><h3 id="returning-multiple-values">Returning Multiple Values</h3><pre><code>func f() (int, int) {
    return 5, 6
}

func main() {
    x, y := f()
}
</code></pre><p>Multiple values are often used to return an error value along with the result, or a boolean to indicate success.<br>Here is a simple example, opening a file and reading some of it.</p><pre><code>file, err := os.Open(&quot;file.go&quot;)  // For read access.
if err != nil {
    log.Fatal(err)
}

count, err := file.Read(data)
if err != nil {
    log.Fatal(err)
}
</code></pre><p>Here&rsquo;s the implementation of method Read:</p><pre><code>// Read reads up to len(b) bytes from the File.
// It returns the number of bytes read and an error, if any.
// EOF is signaled by a zero count with err set to io.EOF.
func (f *File) Read(b []byte) (n int, err error) {
    if f == nil {
        return 0, ErrInvalid
    }
    n, e := f.read(b)
    if n &lt; 0 {
        n = 0
    }
    if n == 0 &amp;&amp; len(b) &gt; 0 &amp;&amp; e == nil {
        return 0, io.EOF
    }
    if e != nil {
        err = &amp;PathError{&quot;read&quot;, f.name, e}
    }
    return n, err
}
</code></pre><h3 id="variadic-functions">Variadic Functions</h3><p>There is a special form available for the last parameter in a Go function:</p><pre><code>func add(args ...int) int {  // Zero or more
    total := 0
    for _, v := range args {
        total += v
    }
    return total
}

func main() {
    fmt.Println(add(1,2,3))
}
</code></pre><p>This is precisely how the fmt.Println function is implemented:</p><pre><code>func Println(a ...interface{}) (n int, err error)
</code></pre><p>We can also pass a slice of ints by following the slice with &hellip;:</p><pre><code>func main() {
    xs := []int{1,2,3}
    fmt.Println(add(xs...))
}
</code></pre><h3 id="closure">Closure</h3><p>It is possible to create functions inside of functions:</p><pre><code>func main() {
    add := func(x, y int) int {
        return x + y
    }
    fmt.Println(add(1,1))
}
</code></pre><p>It also has access to other local variables:</p><pre><code>func main() {
    x := 0
    increment := func() int {
        x++
        return x
    }
    fmt.Println(increment())  // 1
    fmt.Println(increment())  // 2
}
</code></pre><p>A function like this together with the non-local variables it references is known as a closure.</p><h3 id="recursion">Recursion</h3><pre><code>func factorial(x uint) uint {
    if x == 0 {
        return 1
    }
    return x * factorial(x-1)
}
</code></pre><h3 id="defer-panic-recover">Defer, Panic &amp; Recover</h3><pre><code>func first() {
    fmt.Println(&quot;1st&quot;)
}
func second() {
    fmt.Println(&quot;2nd&quot;)
}
func main() {
    defer second()
    first()
}
</code></pre><p>Defer is often used when resources need to be freed in some way.</p><pre><code>f, _ := os.Open(filename)
defer f.Close()
</code></pre><h3 id="panic-recover">Panic &amp; Recover</h3><pre><code>func main() {
    defer func() {
        str := recover()
        fmt.Println(str)  // PANIC
    }()
    panic(&quot;PANIC&quot;)
}
</code></pre><p>A panic generally indicates a programmer error (for example,</p><p>attempting to access an index of an array that&rsquo;s out of bounds<br>forgetting to initialize a map<br>etc.</p><p>) or an exceptional condition that there&rsquo;s no easy way to recover from.</p><pre><code>// pkg\bytes\buffer.go

// makeSlice allocates a slice of size n. If the allocation fails,
// it panics with ErrTooLarge.
func makeSlice(n int) []byte {
    // If the make fails, give a known error.
    defer func() {
        if recover() != nil {
            panic(ErrTooLarge)
        }
    }()
    return make([]byte, n)
}
</code></pre><h1 id="pointers">Pointers</h1><p>Go is similar to C in pointers.</p><pre><code>func zero(xPtr *int) {  // pointer
    *xPtr = 0  // dereference
}

func main() {
    x := 5
    zero(&amp;x)  // address
    fmt.Println(x)  // 0
}
</code></pre><h3 id="build-in-function-new">Build-in function “new”</h3><p>Function “new” takes a type as an argument, allocates enough memory to fit a value of that type and returns a pointer to it.</p><pre><code>func one(xPtr *int) {
    *xPtr = 1
}

func main() {
    xPtr := new(int)
    one(xPtr)
    fmt.Println(*xPtr)  // 1
}
</code></pre><p>Pointers are rarely used with Go&rsquo;s built-in types. They are extremely useful when paired with structs.</p><h1 id="structs">Structs</h1><p>A struct is a type which contains named fields.</p><pre><code>type Circle struct {
    x float64
    y float64
    r float64
}
</code></pre><p>The fields with the same type can be collapsed:</p><pre><code>type Circle struct {
    x, y, r float64
}
</code></pre><h3 id="initialization">Initialization</h3><p>Create a local variable with zero initialization:</p><pre><code>var c Circle  // {0 0 0}
</code></pre><p>Use new function:</p><pre><code>c := new(Circle)  // Also {0 0 0}
</code></pre><p>This allocates memory for all the fields, sets each of them to their zero value and returns a pointer (*Circle).<br>More often we want to give each of the fields a value.</p><pre><code>c := Circle{x: 0, y: 0, r: 5}
</code></pre><p>Or,</p><pre><code>c := Circle{0, 0, 5}
</code></pre><p>Note that variable c is NOT a pointer of Circle.</p><pre><code>func zeroCircle(c *Circle) {
    c.x = 0  // No -&gt; operator like C! Just use dot.
    c.y = 0
    c.r = 0
}

func main() {
    c := Circle{x: 0, y: 0, r: 5}
    zeroCircle(&amp;c)  // c is not a pointer, have to address it.
    fmt.Println(c)  // {0 0 0}
}
</code></pre><h3 id="constructor">Constructor?</h3><p>没有构造和析构方法，通常用简单工厂模式返回对象实例。</p><pre><code>type Queue struct {
    elements []interface{}
}
func NewQueue() *Queue {
    return &amp;Queue{make([]interface{}, 10)}
}

// src\pkg\container\list\list.go

package list

// New returns an initialized list.
func New() *List { return new(List).Init() }
</code></pre><h3 id="methods">Methods</h3><p>Normal function:</p><pre><code>func circleArea(c *Circle) float64 {
    return math.Pi * c.r*c.r
}
</code></pre><p>Method:</p><pre><code>func (c *Circle) area() float64 {  // Receiver
    return math.Pi * c.r*c.r
}
</code></pre><p>Call the method:</p><pre><code>fmt.Println(c.area())
</code></pre><h3 id="interfaces">Interfaces</h3><p>Similarily, define struct Rectangle:</p><pre><code>type Rectangle struct {
    x1, y1, x2, y2 float64
}

func (r *Rectangle) area() float64 {
    l := distance(r.x1, r.y1, r.x1, r.y2)
    w := distance(r.x1, r.y1, r.x2, r.y1)
    return l * w
}
</code></pre><p>Both Circle and Rectangle have a method named area(). Let&rsquo;s define an Interface for this similarity:</p><pre><code>type Shape interface {
    area() float64
}
</code></pre><p>Instead of defining fields, interface defines a “method set”: a list of methods that a type must have in order to “implement” the interface.<br>Function taking interface types as arguments:</p><pre><code>func totalArea(shapes ...Shape) float64 {
    var area float64
    for _, s := range shapes {
        area += s.area()
    }
    return area
}
</code></pre><p>Now call it:</p><pre><code>fmt.Println(totalArea(&amp;c, &amp;r))
</code></pre><p>Interfaces can also be used as fields:</p><pre><code>type MultiShape struct {
    shapes []Shape
}
</code></pre><p>We can even turn MultiShape itself into a Shape by giving it an area method:</p><pre><code>func (m *MultiShape) area() float64 {
    var area float64
    for _, s := range m.shapes {
        area += s.area()
    }
    return area
}
</code></pre><h1 id="packages">Packages</h1><p>编译工具对源码目录有严格要求，每个工作空间 (workspace) 必须由 bin、pkg、src 三个目录组成。</p><p>“D:\proj\Go” is NOT in \$GOPATH.</p><pre><code>$ D:\proj\Go&gt;go build hello.go

$ D:\proj\Go&gt;go install
go install: no install location for directory D:\proj\Go outside GOPATH
</code></pre><p><strong>所有代码都必须组织在 package 中：</strong><br>源文件头部以 &ldquo;package &lt;name&gt;&rdquo; 声明包名称。<br>包由同一目录下的多个源码文件组成。<br>包名类似 namespace，与包所在目录名、编译文件名无关。<br>可执行文件必须包含 package main，入口函数 main。</p><h3 id="access-control">Access Control</h3><p>Lower case private, upper case public.</p><pre><code>package list

type Element struct {
    next, prev *Element  // private
    list *List           // private
    Value interface{}    // public
}

package csi

type Patient struct {
    Id string
    Name string
    BirthDate time.Time
    dose float32            // Won't exported.
}

package main
...
p := &amp;csi.Patient{&quot;1&quot;, &quot;Adam&quot;, newDate(1984, time.March, 26), 1.0}

Error:
&gt; implicit assignment of unexported field 'dose' in csi.Patient literal
</code></pre><h1 id="concurrency">Concurrency</h1><p>Go has rich support for concurrency using goroutines and channels.</p><h3 id="goroutines">Goroutines</h3><p>A goroutine is a function that is capable of running concurrently with other functions.</p><pre><code>func f(n int) {
    for i := 0; i &lt; 10; i++ {
        fmt.Println(n, &quot;:&quot;, i)
    }
}

func main() {
    go f(0)
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><p>Goroutines are lightweight, you can create many of them:</p><pre><code>func main() {
    for i := 0; i &lt; 10; i++ {
        go f(i)
    }
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><h3 id="channels">Channels</h3><p>Channels provide a way for two goroutines to communicate with one another and synchronize their execution.</p><pre><code>func pinger(c chan string) {
    for i := 0; ; i++ {
        c &lt;- &quot;ping&quot;
    }
}

func printer(c chan string) {
    for {
        msg := &lt;- c
        fmt.Println(msg)
        time.Sleep(time.Second * 1)
    }
}

func main() {
    var c chan string = make(chan string)
    go pinger(c)
    go printer(c)
    var input string
    fmt.Scanln(&amp;input)
}
</code></pre><p>When pinger attempts to send a message on the channel it will wait until printer is ready to receive the message. (this is known as blocking)</p><h1 id="create-library">Create Library</h1><p>Choose a package path (carestream.com/dental/csi) and create the package dir:</p><pre><code>  $GOPATH\src\carestream.com\dental\csi
</code></pre><p>Next, create a file named patient.go, containing the following code.</p><pre><code>package csi

import &quot;time&quot;

type Patient struct {
    Id string
    Name string
    BirthDate time.Time
    Dose float32
}
</code></pre><p>Now, build it:</p><pre><code>$ go build carestream.com\dental\csi
</code></pre><p>No output. Do go install for it.</p><pre><code>$ go install carestream.com\dental\csi
</code></pre><p>Get:</p><pre><code>$GOPATH\pkg\windows_amd64\carestream.com\dental\csi.a
</code></pre><p><strong>THE END</strong></p></div><aside id="meta"><meta itemprop="wordCount" content="2659"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/goyu-yan-kuai-su-ru-men.html.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/gozhua-qu-wang-xie-shu-ju-bing-cun-ru-mysqlhe-fan-hui-jsonshu-ju-ampltsi-ampgt.html.html">Go抓取网页数据并存入MySQL和返回json数据&lt;四&gt;</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/golangzai-mac-osshang-de-huan-jing-pei-zhi.html.html">Golang在MacOS上的环境配置</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sid="046833a15b4d334b2f330e78d17a3035"></div><div id="cyReward" role="cylabs" data-use="reward" sid="046833a15b4d334b2f330e78d17a3035" style="text-align:center"></div><div id="SOHUCS" sid="046833a15b4d334b2f330e78d17a3035"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li><li class="rel_linksli"><a href="https://www.zhihu.com/people/_ysqi" title="访问虞双齐的知乎" rel="nofollow">我的 知乎</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionWeibo">Weibo</span></a></li><li><a class="footeraction" href="https://www.zhihu.com/people/_ysqi" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionZhiHu">知乎</span></a></li><li><a class="footeraction" href="/index.xml" title="RSS订阅 虞双齐"><span class="footeractionRSS">Feed</span></a></li><li><a class="footeraction" href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-kuai-su-ru-men.html.html" rel="nofollow" target="blank"><span class="footeractionW3CHTML">Valid XHTMl 4.0</span></a></li><li><a class="footeraction" href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-kuai-su-ru-men.html.html" rel="nofollow" target="blank"><span class="footeractionW3CCSS">Valid CSS Leval2</span></a></li></ul><p>©2015-2016 虞双齐-全栈开发。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>