<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语法 |虞双齐的博客</title><meta name="description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值
注：_（下划线）是个特殊的变量名，任何赋"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐的博客"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-fa.html"><meta property="og:title" content="Go语法"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:34"><meta property="article:modified_time" content="2016-12-31 11:34:34"><meta property="article:tag" content="golang"><meta name="og:description" content="Go基础 变量 基本结构：var 变量名 变量类型 = 值
注：_（下划线）是个特殊的变量名，任何赋"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170816"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/goyu-fa.html">Go语法</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000002623278" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h1 id="go基础">Go基础</h1><h2 id="变量">变量</h2><p>基本结构：<code>var 变量名 变量类型 = 值</code><br>注：<code>_</code>（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃</p><pre><code>package main

/* 全局变量 */
// 仅声明, 必要有var和变量类型
var a int
var b, c int

// 声明并初始化，变量类型可省略
var d int = 1
var e, f int = 1, 2
var g = 1 // 自动推断类型
var h, i = 1, &quot;string&quot; // 类型可以不一样

func main() {
    /* 局部变量特有的声明方式 */
    j := 1;
    k, l := 1, 2
}
</code></pre><h2 id="常量">常量</h2><p>常量可定义为数值、布尔值或字符串等类型。</p><pre><code>/* 全局和局部声明方式相同 */
const a int = 1
const b = 1
const c, d = 1, 2 &quot;string&quot; // 类型可以不一样
</code></pre><h2 id="内置基本类型">内置基本类型</h2><h3 id="boolean">Boolean</h3><p>布尔值的类型为bool，值是true或false，默认为false。</p><p>注：不能用0和非0表示true或false</p><h3 id="数值类型">数值类型</h3><pre><code>1. 整型 
    * 分为无符号和带符号，例如：int和uint
    * 8，16，32，64位，例如：int32和uint32
    * rune是int32的别称，byte是uint8的别称
2. 浮点型 float32和float64
3. 复数 complex64和complex128
注：不同类型之间不能进行运算
</code></pre><h3 id="字符串">字符串</h3><h4 id="定义">定义</h4><pre><code>var a string 
var b string = &quot;&quot; 
func test() {
    no, yes, maybe := &quot;no&quot;, &quot;yes&quot; 
}
</code></pre><h4 id="修改">修改</h4><pre><code>s := &quot;hello&quot;
c := []byte(s)  // 将字符串 s 转换为 []byte 类型
c[0] = 'c'
s2 := string(c)  // 再转换回 string 类型
fmt.Printf(&quot;%s\n&quot;, s2)
</code></pre><h4 id="连接">连接</h4><pre><code>s := &quot;hello,&quot;
m := &quot; world&quot;
a := s + m
fmt.Printf(&quot;%s\n&quot;, a)
</code></pre><h4 id="原始格式输出">原始格式输出</h4><p>` 括起的字符串为Raw字符串，即字符串在代码中的形式就是打印时的形式，它没有字符转义，换行也将原样输出。</p><pre><code>m := `hello
    world`
</code></pre><h2 id="错误类型">错误类型</h2><p>Go内置有一个error类型，专门用来处理错误信息，Go的package里面还专门有一个包errors来处理错误：</p><pre><code>err := errors.New(&quot;emit macho dwarf: elf header corrupted&quot;)
if err != nil {
    fmt.Print(err)
}
</code></pre><h2 id="go数据底层的存储">Go数据底层的存储</h2><p>下面这张图来源于Russ Cox Blog中一篇介绍Go数据结构的文章，大家可以看到这些基础类型底层都是分配了一块内存，然后存储了相应的值。</p><h2 id="一些技巧">一些技巧</h2><h3 id="分组声明">分组声明</h3><pre><code>import(
    &quot;fmt&quot;
    &quot;os&quot;
)

const(
    i = 100
    pi = 3.1415
    prefix = &quot;Go_&quot;
)

var(
    i int
    pi float32
    prefix string
)
</code></pre><h3 id="iota枚举">iota枚举</h3><p>Go里面有一个关键字iota，这个关键字用来声明enum的时候采用，它默认开始值是0，每调用一次加1：</p><pre><code>const(
    x = iota  // x == 0
    y = iota  // y == 1
    z = iota  // z == 2
    w  // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用&quot;= iota&quot;
)

const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0

const ( 
  e, f, g = iota, iota, iota //e=0,f=0,g=0 iota在同一行值相同
)
</code></pre><blockquote><p>除非被显式设置为其它值或iota，每个const分组的第一个常量被默认设置为它的0值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是iota，则它也被设置为iota。</p></blockquote><h3 id="私有和公有">私有和公有</h3><p>大写字母开头的变量或函数，为公有，相当于java中的public<br>小写字母开头的变量或函数为，私有，相当于java中的private。</p><h2 id="array-slice-map">array、slice、map</h2><h3 id="array">array</h3><p>基本结构：<code>var 变量名 [长度]类型</code></p><ul><li>数组长度不能改变</li><li>长度也是数组类型的一部分，因此<a href="http://www.tuicool.com/articles/QrymYz">3</a>int与[4]int是不同的类型</li><li>当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。</li></ul><pre><code>var arr [10]int  // 声明了一个int类型的数组
a := [3]int{1, 2, 3} // 声明了一个长度为3的int数组
b := [10]int{1, 2, 3} // 声明了一个长度为10的int数组，其中前三个元素初始化为1、2、3，其它默认为0
c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度
</code></pre><h3 id="slice">slice</h3><h4 id="声明">声明</h4><p>基本结构：<code>var 变量名 []类型</code></p><p>slice是一个引用类型。slice总是指向一个底层array，slice的声明也可以像array一样，只是不需要长度。</p><pre><code>&lt;!-- 直接声明 --&gt;
var slice []int
var slice = []int{1, 2, 3}
slice := []byte {'a', 'b', 'c'}
&lt;!-- 从数组中截取 --&gt;
array := [3]byte {'a', 'b', 'c'}
slice := array[1, 2] // slice通过array[i:j]来获取，其中i是数组的开始位置，j是结束位置，但不包含array[j]，它的长度是j-i。 
</code></pre><h4 id="内置函数">内置函数</h4><ul><li>len 获取slice的长度</li><li>cap 获取slice的最大容量</li><li>append 向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice</li><li>copy 函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数</li></ul><h4 id="长度与容量">长度与容量</h4><pre><code>a := [10]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 0}
s := a[0:]
s = append(s, 11, 22, 33)
sa := a[2:7]
sb := sa[3:5]
fmt.Println(a, len(a), cap(a))    //输出：[1 2 3 4 5 6 7 8 9 0] 10 10
fmt.Println(s, len(s), cap(s))    //输出：[1 2 3 4 5 6 7 8 9 0 11 22 33] 13 20
fmt.Println(sa, len(sa), cap(sa)) //输出：[3 4 5 6 7] 5 8
fmt.Println(sb, len(sb), cap(sb)) //输出：[6 7] 2 5
</code></pre><ul><li>长度为已存放个数，容量为可存放个数</li><li>对数组来说，长度和容量总是相等的</li><li>slice的容量可以大于长度，如果容量不足，将动态分配新的数组空间</li><li>array[i:j:k]，k - i为容量，k默认为数组长度</li></ul><h4 id="陷阱">陷阱</h4><p>当Slice的容量还有空闲的时候，append进来的元素会直接使用空闲的容量空间，但是一旦append进来的元素个数超过了原来指定容量值的时候，内存管理器就是重新开辟一个更大的内存空间，用于存储多出来的元素，并且会将原来的元素复制一份，放到这块新开辟的内存空间。</p><pre><code>a := []int{1, 2, 3, 4}
sa := a[1:3]
fmt.Printf(&quot;%p\n&quot;, sa) //输出：0xc0840046e0
sa = append(sa, 11, 22, 33)
fmt.Printf(&quot;%p\n&quot;, sa) //输出：0xc084003200
</code></pre><p><a href="http://www.tuicool.com/articles/QrymYz">参考链接</a></p><h3 id="map">map</h3><h4 id="声明-1">声明</h4><p>基本结构：<code>map[keyType]valueType</code></p><pre><code>m1 := make(map[string]string)
m1[&quot;aa&quot;] = &quot;bb&quot; // 添加
m2 := map[string]float32{&quot;C&quot;:5, &quot;Go&quot;:4.5, &quot;Python&quot;:4.5, &quot;C++&quot;:2 }
m2[&quot;C++&quot;] = 5 // 修改
delete(m2, &quot;C&quot;)  // 删除key为C的元素
len(m2) // 长度
</code></pre><h4 id="特点">特点</h4><ul><li>map是无序的，每次打印出来的map都会不一样，它不能通过index获取，而必须通过key获取</li><li>map的长度是不固定的，也就是和slice一样，也是一种引用类型</li><li>map和其他基本型别不同，它不是thread-safe，在多个go-routine存取时，必须使用mutex lock机制</li><li>map[key]，有两个返回值，第一个是value，第二个是是否存在对应的值</li></ul><h3 id="make-new操作">make、new操作</h3><p>make用于内建类型（map、slice 和channel）的内存分配。new用于各种类型的内存分配。</p><ul><li>new返回的是指针</li><li>make返回初始化后的（非零）值</li></ul><h3 id="零值">零值</h3><p>关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为0。 此处罗列 部分类型 的 “零值”</p><pre><code>int     0
int8    0
int32   0
int64   0
uint    0x0
rune    0 //rune的实际类型是 int32
byte    0x0 // byte的实际类型是 uint8
float32 0 //长度为 4 byte
float64 0 //长度为 8 byte
bool    false
string  &quot;&quot;
</code></pre><h2 id="流程与函数">流程与函数</h2><h3 id="流程控制">流程控制</h3><p>Go中流程控制分三大类：条件判断，循环控制和无条件跳转</p><h4 id="if">if</h4><p>Go的if有一个强大的地方就是条件判断语句里面允许声明一个变量，这个变量的作用域只能在该条件逻辑块内，其他地方就不起作用了，如下所示</p><pre><code>// 计算获取值x,然后根据x返回的大小，判断是否大于10。
if x := computedValue(); x &gt; 10 {
    fmt.Println(&quot;x is greater than 10&quot;)
} else {
    fmt.Println(&quot;x is less than 10&quot;)
}

//这个地方如果这样调用就编译出错了，因为x是条件里面的变量
fmt.Println(x)
</code></pre><h4 id="goto">goto</h4><p>Go有goto语句——请明智地使用它。用goto跳转到必须在当前函数内定义的标签(大小写敏感)。例如假设这样一个循环：</p><pre><code>func myFunc() {
    i := 0
Here:   //这行的第一个词，以冒号结束作为标签
    println(i)
    i++
    goto Here   //跳转到Here去
}
</code></pre><h4 id="for">for</h4><p>Go里面最强大的一个控制逻辑就是for，它即可以用来循环读取数据，又可以当作while来控制逻辑，还能迭代操作。它的语法如下：</p><pre><code>/* expression1和expression3是变量声明或者函数调用返回值之类的，expression2是用来条件判断，expression1在循环开始之前调用，expression3在每轮循环结束之时调用。 */
for expression1; expression2; expression3 {
    //...
}

/* 例如 */
for index:= 0; index &lt; 10 ; index++ {
}
// 平行赋值
for a, b:= 0, 0; b &lt; 10 ; b++ {
}
</code></pre><h5 id="while语句">while语句</h5><pre><code>/* while语句 */
for ; sum &lt; 1000;  {
    sum += sum
}
// ;可省略
for sum &lt; 1000 {
    sum += sum
}
</code></pre><h5 id="break和continue">break和continue</h5><pre><code>/* break和continue与java一致 */
for index := 10; index&gt;0; index-- {
    if index == 5{
        break // 或者continue
    }
    fmt.Println(index)
}
// break打印出来10、9、8、7、6
// continue打印出来10、9、8、7、6、4、3、2、1
</code></pre><h5 id="range">range</h5><pre><code>/* for配合range可以用于读取slice和map的数据 */
// 第一个返回值是key，第二个返回值是value
// 如果是slice，那么key为下标
for k,v:=range map {
    fmt.Println(&quot;map's key:&quot;,k)
    fmt.Println(&quot;map's val:&quot;,v)
}
</code></pre><h4 id="switch">switch</h4><p>与java不同的是，默认每个<code>case</code>执行完毕后会跳出<code>switch语句</code>，如果希望继续执行下一个<code>case</code>，需要加入<code>fallthrough</code>关键字</p><pre><code>i := 10
switch i {
case 1:
    fmt.Println(&quot;i is equal to 1&quot;)
case 2, 3, 4:
    fmt.Println(&quot;i is equal to 2, 3 or 4&quot;)
case 10:
    fmt.Println(&quot;i is equal to 10&quot;)
    fallthrough
default:
    fmt.Println(&quot;------------------------&quot;)
}
</code></pre><h3 id="函数">函数</h3><pre><code>/* 基本结构 */
func funcName(input1 type1, input2 type2) (output1 type1, output2 type2) {
    //这里是处理逻辑代码
    //返回多个值
    return output1, output2
}

/* output1和output2，可以不声明，但必须注明返回类型*/
func funcName(input1 type1, input2 type2) (type1, type2) {

    return &quot;&quot;, &quot;&quot; 
}

/* 如果只有一个返回值且不声明返回值变量，可以这样写 */
func funcName(input1 type1, input2 type2) type {

}

/* 没有返回值，可全部省略 */
func funcName(input1 type1, input2 type2) {

}

/* 前后参数类型相同，可省略前面的参数类型*/
func funcName(input1, input2 int, input3 string, input4, input5 float32) (output1, output2 int){

}

/* 官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。 */
func SumAndProduct(A, B int) (add int, Multiplied int) {
    add = A+B
    Multiplied = A*B
    // 这里也是个特别的地方
    return
}
</code></pre><h3 id="变参">变参</h3><p>基本结构：<code>func myfunc(arg ...int) {}</code></p><ul><li>参数的类型全部是int</li><li>变量arg是一个int的slice</li></ul><pre><code>for _, n := range arg {
    fmt.Printf(&quot;And the number is: %d\n&quot;, n)
}
</code></pre><h3 id="传值与传指针">传值与传指针</h3><ul><li>函数的参数，传入的都是copy</li><li>即使传入的是指针，也是指针的copy</li></ul><p>指针的优点</p><ul><li>传指针使得多个函数能操作同一个对象。</li><li>传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次copy上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。</li><li>Go语言中string，slice，map这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变slice的长度，则仍需要取地址传递指针）</li></ul><pre><code>package main
import &quot;fmt&quot;

//简单的一个函数，实现了参数+1的操作
func add1(a *int) int { // 请注意，
    *a = *a+1 // 修改了a的值
    return *a // 返回新值
}

func main() {
    x := 3

    fmt.Println(&quot;x = &quot;, x)  // 应该输出 &quot;x = 3&quot;

    x1 := add1(&amp;x)  // 调用 add1(&amp;x) 传x的地址

    fmt.Println(&quot;x+1 = &quot;, x1) // 应该输出 &quot;x+1 = 4&quot;
    fmt.Println(&quot;x = &quot;, x)    // 应该输出 &quot;x = 4&quot;
}
</code></pre><h3 id="defer">defer</h3><ul><li>defer语句会在函数返回前执行</li></ul><pre><code>func ReadWrite() bool {
    file.Open(&quot;file&quot;)
    defer file.Close()
    if failureX {
        return false
    }
    if failureY {
        return false
    }
    return true
}
</code></pre><ul><li>defer是采用后进先出模式，所以如下代码会输出4 3 2 1 0</li></ul><pre><code>for i := 0; i &lt; 5; i++ {
    defer fmt.Printf(&quot;%d &quot;, i)
}
</code></pre><h3 id="函数作为值-类型">函数作为值、类型</h3><p>基本结构：<code>type typeName func(input1 inputType1 , input2 inputType2) (result1 resultType1)</code></p><ul><li>拥有相同参数列表和返回值列表的函数，属于同一函数类型。比如下面例子中的isOdd和isEven函数。</li></ul><pre><code>package main
import &quot;fmt&quot;

type testInt func(int) bool // 声明了一个函数类型

func isOdd(integer int) bool {
    if integer%2 == 0 {
        return false
    }
    return true
}

func isEven(integer int) bool {
    if integer%2 == 0 {
        return true
    }
    return false
}

// 声明的函数类型在这个地方当做了一个参数

func filter(slice []int, f testInt) []int {
    var result []int
    for _, value := range slice {
        if f(value) {
            result = append(result, value)
        }
    }
    return result
}

func main(){
    slice := []int {1, 2, 3, 4, 5, 7}
    fmt.Println(&quot;slice = &quot;, slice)
    odd := filter(slice, isOdd)    // 函数当做值来传递了
    fmt.Println(&quot;Odd elements of slice are: &quot;, odd)
    even := filter(slice, isEven)  // 函数当做值来传递了
    fmt.Println(&quot;Even elements of slice are: &quot;, even)
}
</code></pre></div><aside id="meta"><meta itemprop="wordCount" content="1094"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/goyu-fa.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/golang-huan-jing-pei-zhi-jian-yi.html">golang环境配置建议</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/goyu-yan-de-biao-shi-fu-guan-jian-zi-zi-mian-liang-lei-xing.html">Go语言的标识符、关键字、字面量、类型</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sid="017d5f10ea73aeae7f80964401ba5da7"></div><div id="cyReward" role="cylabs" data-use="reward" sid="017d5f10ea73aeae7f80964401ba5da7" style="text-align:center"></div><div id="SOHUCS" sid="017d5f10ea73aeae7f80964401ba5da7"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li><li class="rel_linksli"><a href="https://www.zhihu.com/people/_ysqi" title="访问虞双齐的知乎" rel="nofollow">我的 知乎</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionWeibo">Weibo</span></a></li><li><a class="footeraction" href="https://www.zhihu.com/people/_ysqi" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionZhiHu">知乎</span></a></li><li><a class="footeraction" href="/index.xml" title="RSS订阅 虞双齐"><span class="footeractionRSS">Feed</span></a></li><li><a class="footeraction" href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-fa.html" rel="nofollow" target="blank"><span class="footeractionW3CHTML">Valid XHTMl 4.0</span></a></li><li><a class="footeraction" href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-fa.html" rel="nofollow" target="blank"><span class="footeractionW3CCSS">Valid CSS Leval2</span></a></li></ul><p>©2015-2016 虞双齐-全栈开发。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>