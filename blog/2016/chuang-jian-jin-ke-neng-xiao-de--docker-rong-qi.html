<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>创建尽可能小的Docker容器 |极客虞双齐</title><meta name="description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smal"><meta name="keywords" content="golang, dockerfile, docker, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="极客虞双齐"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html"><meta property="og:title" content="创建尽可能小的Docker容器"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:48"><meta property="article:modified_time" content="2016-12-31 11:34:48"><meta property="article:tag" content="golang"><meta property="article:tag" content="dockerfile"><meta property="article:tag" content="docker"><meta name="og:description" content="注：本文由 Adriaan de Jonge 编写，本文的原文地址为 Create The Smal"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html">创建尽可能小的Docker容器</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000000628247" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><blockquote><p>注：本文由 <a href="http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/#">Adriaan de Jonge</a> 编写，本文的原文地址为 <a href="http://blog.xebia.com/2014/07/04/create-the-smallest-possible-docker-container/">Create The Smallest Possible Docker Container</a></p></blockquote><p>当我们在使用 Docker 的时候，你会很快注意到你正在下载很多 MB 作为你的预先配置的容器。一个简单的 Ubuntu 容器很容易超过 200 MB，并且随着在上面安装软件，尺寸在逐渐增大。在某些情况下，你不需要任何事情都使用 Ubuntu 。例如，如果你只是简单的想运行一个 web 服务，使用 GO 编写的，没有必要围绕它使用任何工具。</p><p>我一直在寻找尽可能小的容器入手，并且发现了一个：</p><pre><code>docker pull scratch
</code></pre><p>scratch 镜像是完美的，真正的完美！它简洁，小巧以及快速。它不包含任何 bug，安全泄漏，慢的代码或是技术债务。这是因为它是一个空的镜像。除了一点由 Docker 加入的元数据。事实上，你可以使用如下命令按照 <a href="https://docs.docker.com/articles/baseimages/#creating-a-simple-base-image-using-scratch">Docker 文档</a>描述的那样创建一个自己的 scratch 镜像。</p><pre><code>tar cv --files-from /dev/null | docker import - scratch
</code></pre><p>所以这可能就是最小的 Docker 镜像。</p><p>或者我们可以说说关于这个的更多东西？比如，你怎样使用 scratch 镜像。这给自己带来了一些挑战。</p><h1 id="为-scratch-镜像创建内容">为 scratch 镜像创建内容</h1><p>我们可以在一个空镜像中运行什么？一个没有依赖的可执行程序。你是否有没有依赖的可执行程序？</p><p>我过去常常使用 Python，Java 和 Javascript 编写代码。每一个这样的语言/平台都需要一个运行时的安装。最近，我开始涉及 Go（或是 golang 如果你喜欢）平台。看起来 Go 是静态连接的。因此我尝试编译一个简单的 web 服务输出 Hello World 并且运行在 scratch 容器中。下面是这个 Hello World web 服务的代码：</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintln(w, &quot;Hello World from Go in minimal Docker container&quot;)
}

func main() {
    http.HandleFunc(&quot;/&quot;, helloHandler)

    fmt.Println(&quot;Started, serving at 8080&quot;)
    err := http.ListenAndServe(&quot;:8080&quot;, nil)
    if err != nil {
        panic(&quot;ListenAndServe: &quot; + err.Error())
    }
}
</code></pre><p>明显地，我不能在 scratch 容器中编译我的 web 服务，因为容器中没有 Go 编译器。正如我在 Mac 上工作，我也无法编译 Linux 的二进制文件一样（实际上，是可以在不同的平台上交叉编译 Go 的源码的，但这会在另外一篇博客中介绍）。</p><p>因此，我首先需要一个有 Go 编译器的 Docker 容器。让我们开始：</p><pre><code>docker run -ti google/golang /bin/bash
</code></pre><p>在这个容器里面，我可以构建一个 Web 服务，通过我已经提交到<a href="https://github.com/adriaandejonge/helloworld">一个 GitHub 仓库</a>的代码。</p><pre><code>go get github.com/adriaandejonge/helloworld
</code></pre><p>go get 命令是 go build 命令的变种，运行获取和构建远程的依赖。你可以运行可执行的结果：</p><pre><code>$GOPATH/bin/helloworld
</code></pre><p>它工作了，但是这不是我们想要的。我们需要 hello world 容器运行在 scratch 容器里面。因此，实际上，我们需要一个 Dockerfile :</p><pre><code>FROM scratch
ADD bin/helloworld /helloworld
CMD [&quot;/helloworld&quot;]
</code></pre><p>然后启动它，不幸的是，我们开始 google/golang 容器的这个方法， 没有办法构建这个 Dockerfile 。因此，首先，我们需要一种方法从这个容器内部访问到 Docker。</p><h1 id="从-docker-内部调用-docker">从 Docker 内部调用 Docker</h1><p>当你使用 Dokcer 时，你迟早会遇到需要从 Docker 内部访问 Docker。可以有多种方法实现它。你可以使用递归和<a href="https://github.com/jpetazzo/dind">在 Docker 中运行 Docker</a>。尽管如此，这样看起来会很复杂并且导致容器很大。你还可以使用一些额外的命令选项在实例外访问 Docker 服务器：</p><pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) -ti google/golang /bin/bash
</code></pre><p>在你继续前，你重新运行 Go 编译器，由于在重启动过程中 Docker 忘记了我们以前编译过。</p><pre><code>go get github.com/adriaandejonge/helloworld
</code></pre><p>当我们启动这个容器， <code>-v</code> 参数在 Docker 容器中创建一个卷并且允许你从 Docker 的机器提供一个文件作为输入。<code>/var/run/docker.sock</code> 是 UNIX socket，通过这个允许你访问 Docker 服务。 <code>(which docker)</code> 部分是一个非常聪明的方法，它提供了一个在 容器中的 Docker 可执行文件的路径，而不是硬编码。尽管如此，当你在 Mac 上通过 boot2docker 使用这个命令的时候需要小心。如果 Docker 的可执行文件与 boot2docker 虚拟机的在不同的位置，将导致不匹配。因此，你或许想使用 <code>/usr/local/bin/docker</code> 硬编码的方式替换 <code>$(which docker)</code>，如果你运行在不同的系统，<code>/var/run/docker.sock</code> 有在不同位置的机会，你需要做相应的调整。</p><p>现在你可以在 google/golang 容器的 \$GOPATH 目录使用 Dockerfile ，在这个示例中指向 <code>/gopath</code>。实际上，我已经在 github 上检查过了这个 <code>Dockerfile</code>，因此，你可以从 Go build 目录复制它到所需的位置，像这样：</p><pre><code>cp $GOPATH/src/github.com/adriaandejonge/helloworld/Dockerfile $GOPATH
</code></pre><p>你需要复制这个作为二进制的编译文件，现在位于 \$GOPATH/bin，并且它不可能从父目录包含文件当构建一个 Dockerfile 的时候。因此复制后，下一步是：</p><pre><code>docker build -t adejonge/helloworld $GOPATH
</code></pre><p>所有的都完成以后， Docker 给出如下响应：</p><pre><code>Successfully built 6ff3fd5a381d
</code></pre><p>允许你运行这个容器：</p><pre><code>docker run -ti --name hellobroken adejonge/helloworld
</code></pre><p>但是不幸的是， Docker 这次响应如下：</p><pre><code>2014/07/02 17:06:48 no such file or directory
</code></pre><p>那么到底是怎么回事？我们在 scratch 容器中有可执行的静态链接。难道我们犯了一个错误？</p><p>事实证明，Go 不是静态链接库。或者至少不是所有的库。在 Linux 下，我们可以使用 ldd 命令来看到动态链接库：</p><pre><code>ldd $GOPATH/bin/helloworld 
</code></pre><p>得到如下响应：</p><pre><code>linux-vdso.so.1 =&gt; (0x00007fff039fe000)
libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f61df30f000)
libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f61def84000)
/lib64/ld-linux-x86-64.so.2 (0x00007f61df530000)
</code></pre><p>因此，在我们运行我们的 web 服务之前，我需要告诉 go 编译器实际的静态链接。</p><h1 id="创建在-go-中的可执行静态链接">创建在 Go 中的可执行静态链接</h1><p>为了创建可执行的静态链接，我们需要告诉 Go 使用 cgo 编译器而不是 go 编译器。命令如下：</p><pre><code>CGO_ENABLED=0 go get -a -ldflags '-s' github.com/adriaandejonge/helloworld
</code></pre><p><code>CGO_ENABLED</code> 环境变量告诉 Go 使用 cgo 编译器而不是 go 编译器。<code>-a</code> 参数告诉 GO 重薪构建所有的依赖。否则的话你将以动态链接依赖结束。最后的 <code>-ldflags '-s'</code> 参数是一个非常好的扩展。它大概降低了可执行文件 50% 的文件大小。你也可以不通过 cgo 使用这个。尺寸缩小是去除了调试信息的结果。</p><p>为了确定，运行 ldd 命令：</p><pre><code>ldd $GOPATH/bin/helloworld 
</code></pre><p>返回是：</p><pre><code>not a dynamic executable
</code></pre><p>你也可以重新运行步骤，围绕着从 scratch 创建 Docker 容器的可执行文件。</p><pre><code>docker build -t adejonge/helloworld $GOPATH
</code></pre><p>如果一切顺利，Docker 将响应如下：</p><pre><code>Successfully built 6ff3fd5a381d
</code></pre><p>允许你运行这个容器：</p><pre><code>docker run -ti --name helloworld adejonge/helloworld
</code></pre><p>响应如下：</p><pre><code>Started, serving at 8080
</code></pre><p>到目前为止，有许多手动的步骤和很多错误的地方。让我们退出 google/golang 容器并且从周边服务器继续：</p><pre><code>&lt;Press Ctrl-C&gt;
exit
</code></pre><p>你可以检查 Docker 容器和镜像存在不存在：</p><pre><code>docker ps -a
docker images -a
</code></pre><p>你可以使用如下命令清理：</p><pre><code>docker rm -f helloworld
docker rmi -f adejonge/helloworld
</code></pre><h1 id="创建一个-docker-容器来创建一个-docker-容器">创建一个 Docker 容器来创建一个 Docker 容器</h1><p>目前为止，我们花了那么多步骤，我们还可以记录在 Dockerfile 中并且 Docker 会为我们做这些工作：</p><pre><code>FROM google/golang
RUN CGO_ENABLED=0 go get -a -ldflags '-s' github.com/adriaandejonge/helloworld
RUN cp /gopath/src/github.com/adriaandejonge/helloworld/Dockerfile /gopath
CMD docker build -t adejonge/helloworld gopath
</code></pre><p>我在 <a href="https://github.com/adriaandejonge/hellobuild">一个单独的称为 adriaandejonge/hellobuild 的 GitHub 仓库</a>检查了 Dockerfile。它可以使用下面的命令构建：</p><pre><code>docker build -t adejonge/hellobuild github.com/adriaandejonge/hellobuild
</code></pre><p>提供 <code>-t</code> 参数命名 adejonge/hellobuild 镜像并且它的最新的隐式的标签。这些名字让你以后更容易去除镜像。下一步，你可以使用就像我们在这篇文章前面看到的那样提供一个参数从这个镜像中创建一个容器：</p><pre><code>docker run -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):$(which docker) -ti --name hellobuild adejonge/hellobuild
</code></pre><p>提供 <code>--name hellobuild</code> 参数使得在运行后更容易移除容器。事实上，你可以这样做，因为运行这个命令后，你已经创建了一个 adejonge/helloworld 镜像：</p><pre><code>docker rm -f hellobuild
docker rmi -f adejonge/hellobuild
</code></pre><p>现在你可以创建一个基于 adejonge/helloworld 镜像的名为 helloworld 的新容器，就像你以前做的那样：</p><pre><code>docker run -ti --name helloworld adejonge/helloworld
</code></pre><p>因为所有的这些步骤都是从相同的命令中运行，不需要在 Docker 中打开一个 bash shell 。你可以把这些步骤添加进一个 bash 脚本，自动运行它，为了使你方便，<a href="https://github.com/adriaandejonge/hellobuild/tree/master/scripts">我已经把这些脚本加入了 hellobuild GitHub 仓库</a>。</p><p>另外，如果你想尝试一个尽可能小的容器，但是又不想遵循博客中的步骤，你可以使用我检入进 <a href="https://registry.hub.docker.com/u/adejonge/helloworld/">Docker Hub repository</a> 的预先构建好的镜像。</p><pre><code>docker pull adejonge/helloworld
</code></pre><p>使用 docker images -a ，你可以看到大小是 3.6MB。当然，如果你成功创建一个比我使用 Go 编写的 web 服务还小的可执行文件，你可以使得它更小。使用 C 语言或者是汇编，你可以这样做到。尽管如此，你不可能使得它比 scratch 镜像还小</p><p><strong>扩展阅读</strong></p><ul><li><a href="http://www.centurylinklabs.com/optimizing-docker-images/">OPTIMIZING DOCKER IMAGES</a></li></ul></div><aside id="meta"><meta itemprop="wordCount" content="547"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/docker.html" rel="tag">docker</a> <a href="/tags/dockerfile.html" rel="tag">dockerfile</a> <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/golangzai-windowsping-tai-shi-yong-zmq.html">golang在windows平台使用zmq</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/go-kai-fa-zhe-dui--go-chu-xue-zhe-de-jian-yi.html">GO开发者对GO初学者的建议</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="756206fd5535aad5b9aef984f89f0342" data-title="创建尽可能小的Docker容器" data-url="https://yushuangqi.com/blog/2016/chuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，一名全栈开发工程师，#热爱编程、#工具控、#爱读书、#宅男</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="极客虞双齐">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fchuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fchuang-jian-jin-ke-neng-xiao-de--docker-rong-qi.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-爱分享的极客。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>