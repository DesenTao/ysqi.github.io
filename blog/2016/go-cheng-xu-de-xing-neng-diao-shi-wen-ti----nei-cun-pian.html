<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go程序的性能调试问题-内存篇 |极客虞双齐</title><meta name="description" content="标签（空格分隔）： Go Memory Profiler 性能调试 性能分析
 注：该文作者是 Dm"><meta name="keywords" content="性能分析, 性能调优, profiler, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="极客虞双齐"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/go-cheng-xu-de-xing-neng-diao-shi-wen-ti----nei-cun-pian.html"><meta property="og:title" content="Go程序的性能调试问题-内存篇"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:42"><meta property="article:modified_time" content="2016-12-31 11:34:42"><meta property="article:tag" content="性能分析"><meta property="article:tag" content="性能调优"><meta property="article:tag" content="profiler"><meta property="article:tag" content="golang"><meta name="og:description" content="标签（空格分隔）： Go Memory Profiler 性能调试 性能分析
 注：该文作者是 Dm"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/go-cheng-xu-de-xing-neng-diao-shi-wen-ti----nei-cun-pian.html">Go程序的性能调试问题-内存篇</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000000670041" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>标签（空格分隔）： Go Memory Profiler 性能调试 性能分析</p><hr><blockquote><p>注：该文作者是 <a href="https://software.intel.com/en-us/user/347692">Dmitry Vyukov</a>，原文地址 <a href="https://software.intel.com/en-us/blogs/2014/05/10/debugging-performance-issues-in-go-programs">Debugging performance issues in Go programs</a></p><p>这个是原文中的 Memory Profiler 段落</p></blockquote><p>内存分析器显示了函数分配堆内存的情况。你可以以 CPU profile 相似的方式收集：使用 <a href="http://golang.org/cmd/go/#hdr-Description_of_testing_flags">go test &ndash;memprofile</a>，通过 <a href="http://myserver:6060:/debug/pprof/heap">http://myserver:6060:/debug/pprof/heap</a> 使用 <a href="http://golang.org/pkg/net/http/pprof">net/http/pprof</a> 或是通过调用 <a href="http://golang.org/pkg/runtime/pprof/#WriteHeapProfile">runtime/pprof.WriteHeapProfile</a>。</p><p>你仅可以显示在概要文件收集的时间分配的内存（默认，pprof 的 &ndash;inuse_space 标志），或是从程序启动起的所有分配（pprof 的 &ndash;alloc_space 标志）。前者对对于 net/http/pprof 的现场应用的概要文件收集非常有用，后者对程序结束的时候的概要文件收集非常有用（否则你将看到空荡荡的概要文件）。</p><blockquote><p>注意：内存分析器很简单，也就是说，它收集的信息仅仅是关于内存分配的一些子集。概率抽样对象与它的大小成正比，你可以使用 <code>go test --memprofilerate</code> 标志改变抽样比率，或者是在程序启动的时候设置 <code>runtime.MemProfileRate</code> 变量。比率 1 将导致收集所有分配的信息。但是它可能导致执行很慢，默认的采样率是每 512kb 的内存分配 1个样本。</p></blockquote><p>你也可以显示分配的字节数，或者是分配的对象数量（<code>--inuse/alloc_space</code> 和 <code>--inuse/alloc_objects</code> 标志）。分析器在分析时更倾向于大样本对象。但是更重要的是要明白大对象影响内存消耗和 GC 时间，然而大量微小的分配影响执行速度（同样是某种程度的 GC 时间），所以两个都观察可能是非常有用的。</p><p>对象可以是持久的或是瞬态的。如果在程序开始的时候，你有一些大的持久化对象分配，它们将最有可能被分析器采样（因为它们足够大）。这样的对象会影响内存的消耗和 GC 时间，但是它们不影响正常的执行速度（没有内存管理操作发生在它们身上）。换句话说，如果你有大量的生命周期非常短暂的对象，在概要文件中，它们几乎可以代表（如果你使用默认的 &ndash;inuse_space 模式），但它们很明显的会影响执行速度。因为它们在不断的分配和释放。因此，再一次声明，观察两种类型的对象是非常有用的。</p><p>因此，通常如果你想降低内存消耗，在正常的程序操作期间，你需要查看 <code>--inuse_space</code> 概要文件收集。如果你想提升执行速度，查看 <code>--alloc_objects</code> 概要文件收集，在重要的运行时间或程序结束之后。</p><p>这有一些标志控制报告的粒度。<code>--functions</code> 使得 <code>pprof</code> 报告在函数级别（默认）。<code>--lines</code> 使得 <code>pprof</code> 报告在源码的行级别。这是非常有用的，如果热函数在不同的行。这里也有 <code>--addresses</code> 和 <code>--files</code> 各自对应准确的指令地址和文件级别。</p><p>对于内存概要文件来说，这是非常有用的选项 &ndash; 你可以在浏览器中查看它（提供这个功能需要你 imported net/http/pprof）。如果你打开 <a href="http://myserver:6060/debug/pprof/heap?debug=1">http://myserver:6060/debug/pprof/heap?debug=1</a>，你必须看到堆类似：</p><pre><code>heap profile: 4: 266528 [123: 11284472] @ heap/1048576
1: 262144 [4: 376832] @ 0x28d9f 0x2a201 0x2a28a 0x2624d 0x26188 0x94ca3 0x94a0b 0x17add6 0x17ae9f 0x1069d3 0xfe911 0xf0a3e 0xf0d22 0x21a70
#    0x2a201    cnew+0xc1    runtime/malloc.goc:718
#    0x2a28a    runtime.cnewarray+0x3a            runtime/malloc.goc:731
#    0x2624d    makeslice1+0x4d                runtime/slice.c:57
#    0x26188    runtime.makeslice+0x98            runtime/slice.c:38
#    0x94ca3    bytes.makeSlice+0x63            bytes/buffer.go:191
#    0x94a0b    bytes.(*Buffer).ReadFrom+0xcb        bytes/buffer.go:163
#    0x17add6    io/ioutil.readAll+0x156            io/ioutil/ioutil.go:32
#    0x17ae9f    io/ioutil.ReadAll+0x3f            io/ioutil/ioutil.go:41
#    0x1069d3    godoc/vfs.ReadFile+0x133            godoc/vfs/vfs.go:44
#    0xfe911    godoc.func·023+0x471            godoc/meta.go:80
#    0xf0a3e    godoc.(*Corpus).updateMetadata+0x9e        godoc/meta.go:101
#    0xf0d22    godoc.(*Corpus).refreshMetadataLoop+0x42    godoc/meta.go:141
2: 4096 [2: 4096] @ 0x28d9f 0x29059 0x1d252 0x1d450 0x106993 0xf1225 0xe1489 0xfbcad 0x21a70
#    0x1d252    newdefer+0x112                runtime/panic.c:49
#    0x1d450    runtime.deferproc+0x10            runtime/panic.c:132
#    0x106993    godoc/vfs.ReadFile+0xf3            godoc/vfs/vfs.go:43
#    0xf1225    godoc.(*Corpus).parseFile+0x75        godoc/parser.go:20
#    0xe1489    godoc.(*treeBuilder).newDirTree+0x8e9    godoc/dirtrees.go:108
#    0xfbcad    godoc.func·002+0x15d            godoc/dirtrees.go:100
</code></pre><p>在每个入口开始的数字 (&ldquo;1: 262144 [4: 376832]&rdquo;) 代表当前存活对象的数量，存活对象已经占用的内存，分配的总的数量和所有分配已经占用的内存。</p><p>优化通常特定于应用程序，但这里有一些常见的建议。</p><ol><li>对象合并成更大的对象。比如，使用 bytes.Buffer 代替 *bytes.Buffer 结构（后面你可以通过调用 bytes.Buffer.Grow 预先分配 buffer ）。这将降低内存的分配数量（更快），同时降低垃圾回收器的压力（更快的垃圾回收）。</li><li><p>局部变量逃离了它们声明的范围，提升到堆分配。编译器通常不能证明几个变量有相同的寿命，因此它分别分配每个这样的变量。因此你可以使用以上的建议处理局部变量，比如，把下面这个：</p><pre><code>for k, v := range m {
   k, v := k, v   // copy for capturing by the goroutine
   go func() {
       // use k and v
   }()
}
</code></pre><p>替代为：</p><pre><code>for k, v := range m {
   x := struct{ k, v string }{k, v}   // copy for capturing by the goroutine
   go func() {
       // use x.k and x.v
   }()
}
</code></pre><p>这会把两个内存分配变为一个内存分配。尽管如此，该优化会影响代码的可读性，所以请合理使用它。</p></li><li><p>分配的一个特例就是 slice 数组预分配。如果你知道一个 slice 的标准大小，你可以像下面这样预分配一个支持数组：</p><pre><code>type X struct {
    buf      []byte
    bufArray [16]byte // Buf usually does not grow beyond 16 bytes.
}

func MakeX() *X {
    x := &amp;X{}
    // Preinitialize buf with the backing array.
    x.buf = x.bufArray[:0]
    return x
}
</code></pre></li><li><p>如果可能的话，使用更小的数据类型，比如，使用 int8 代替 int。</p></li><li><p>对象不包含任何指针（注意： strings，slices， maps 和 chans 包含隐含的指针），不会被垃圾收集器扫描。比如，1GB byte 的 slice 事实上不会影响垃圾收集时间。因此如果你从已经使用的活跃的对象移除指针，肯定会影响垃圾收集时间。一些可能性：使用 indices 代替指针，把对象分割成两部分，其中一部分不包含指针。</p></li><li><p>使用 freelists 重新利用瞬时对象和分配数量。标准包包含 <a href="http://tip.golang.org/pkg/sync/#Pool">sync.Pool</a> 类型，在垃圾收集之间的几次，允许重新使用相同的对象。尽管如此，要知道，任何手动内存管理方案， 不正确的使用 sync.Pool 可能会导致 use-after-free（释放后使用的 bug） bugs。</p></li></ol><p>你可以使用垃圾收集器跟踪（见下文）来得到一些内存问题更深刻的见解。</p></div><aside id="meta"><meta itemprop="wordCount" content="351"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/go-cheng-xu-de-xing-neng-diao-shi-wen-ti----nei-cun-pian.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/profiler.html" rel="tag">profiler</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.html" rel="tag">性能分析</a> <a href="/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98.html" rel="tag">性能调优</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/golang-read-file-line-by-line.html">GolangReadFilelinebyline</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/golangde-lei-xing-zhuai-huan-de-keng-he-fen-xi.html">golang的类型转换的坑和分析</a></li></ul></div><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，一名全栈开发工程师，#热爱编程、#工具控、#爱读书、#宅男</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="极客虞双齐">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgo-cheng-xu-de-xing-neng-diao-shi-wen-ti----nei-cun-pian.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgo-cheng-xu-de-xing-neng-diao-shi-wen-ti----nei-cun-pian.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-爱分享的极客。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>