<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>用Go语言写HTTP中间件 |虞双齐Golang开发与SRE运维</title><meta name="description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通"><meta name="keywords" content="http, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html"><meta property="og:title" content="用Go语言写HTTP中间件"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:35:10"><meta property="article:modified_time" content="2016-12-31 11:35:10"><meta property="article:tag" content="http"><meta property="article:tag" content="golang"><meta name="og:description" content="在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html">用Go语言写HTTP中间件</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000000358436" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>在web开发过程中，中间件一般是指应用程序中封装原始信息，添加额外功能的组件。不知道为什么，中间件通常是一种不太受欢迎的概念。但我认为它棒极了。</p><p>其一，一个好的中间件拥有单一的功能，可插拔并且是自我约束的。这就意味着你可以在接口的层次上把它放到应用中，并能很好的工作。中间件并不影响你的代码风格，它也不是一个框架，仅仅是你处理请求流程中额外一层罢了。根本不需要重写代码：如果你想用一个中间件，就把它加上应用中；如果你改变主意了，去掉就好了。就这么简单。</p><p>来看看Go，HTTP中间件非常流行，标准库中也是这样。或许咋看上去并不明显，net/http包中的函数，如<a href="http://golang.org/pkg/net/http/#StripPrefix">StripPrefix</a> 和<a href="http://golang.org/pkg/net/http/#TimeoutHandler">TimeoutHandler</a> 正是我们上面定义的中间件：封装处理过程并在处理输入或输出时增加额外的动作。</p><p>我最近的Go包 <a href="https://github.com/justinas/nosurf">nosurf</a> 也是一个中间件。我从一开始就有意的这样设计。大多数情况下，你根本不必在应用层关心CSRF检查。nosurf，和其他中间件一样，非常独立，可以和实现标准库net/http接口的工具配合使用。</p><p>你也可以使用中间件做这些：<br>* 通过隐藏长度缓解BREACH攻击<br>* 频率限制<br>* 屏蔽恶意自动程序<br>* 提供调试信息<br>* 添加HSTS, X-Frame-Options头<br>* 从异常中优雅恢复<br>* 以及其他等等。</p><h3 id="写一个简单的中间件">写一个简单的中间件</h3><p>第一个例子中，我写了一个中间件，只允许用户从特定的域（在HTTP的Host头中有域信息）来访问服务器。这样的中间件可以保护应用程序不受“<a href="http://www.skeletonscribe.net/2013/05/practical-http-host-header-attacks.html">主机欺骗攻击</a>”</p><h3 id="定义类型">定义类型</h3><p>为了方便，让我们为这个中间件定义一种类型，叫做SingleHost。</p><pre><code>type SingleHost struct {

    handler     http.Handler

    allowedHost string

}
</code></pre><p>只包含两个字段：<br>* 封装的Handler。如果是有效的Host访问，我们就调用这个Handler。<br>* 允许的主机值。<br>由于我们把字段名小写了，使得该字段只对我们自己的包可见。我们还应该写一个初始化函数。</p><pre><code>func NewSingleHost(handler http.Handler, allowedHost string) *SingleHost {

    return &amp;SingleHost{handler: handler, allowedHost: allowedHost}

}
</code></pre><h3 id="处理请求">处理请求</h3><p>现在才是实际的逻辑。为了实现http.Handler，我们的类型秩序实现一个方法：</p><pre><code>type Handler interface {

        ServeHTTP(ResponseWriter, *Request)

}
</code></pre><p>这就是我们实现的方法：</p><pre><code>func (s *SingleHost) ServeHTTP(w http.ResponseWriter, r *http.Request) {

    host := r.Host

    if host == s.allowedHost {

        s.handler.ServeHTTP(w, r)

    } else {

        w.WriteHeader(403)

    }

}
</code></pre><p>ServeHTTP 函数仅仅检查请求中的Host头：</p><ul><li>如果Host头匹配初始化函数设置的allowedHost ，就调用封装handler的ServeHTTP方法。</li><li>如果Host头不匹配，就返回403状态码（禁止访问）。</li></ul><p>在后一种情况中，封装handler的ServeHTTP方法根本就不会被调用。因此封装的handler根本不会有任何输出，实际上它根本就不知道有这样一个请求到来。</p><p>现在我们已经完成了自己的中间件，来把它放到应用中。这次我们不把Handler直接放到net/http服务中，而是先把Handler封装到中间件中。</p><pre><code>singleHosted = NewSingleHost(myHandler, &quot;example.com&quot;)

http.ListenAndServe(&quot;:8080&quot;, singleHosted)
</code></pre><h3 id="另外一种方法">另外一种方法</h3><p>我们刚才写的中间件实在是太简单了，只有仅仅15行代码。为了写这样的中间件，引入了一个不太通用的方法。由于Go支持函数第一型和闭包，并且拥有简洁的http.HandlerFunc包装器，我们可以将其实现为一个简单的函数，而不是写一个单独的类型。下面是基于函数的中间件版本。</p><pre><code>func SingleHost(handler http.Handler, allowedHost string) http.Handler {

    ourFunc := func(w http.ResponseWriter, r *http.Request) {

        host := r.Host

        if host == allowedHost {

            handler.ServeHTTP(w, r)

        } else {

            w.WriteHeader(403)

        }

    }

    return http.HandlerFunc(ourFunc)

}
</code></pre><p>这里我们声明了一个叫做SingleHost的简单函数，接受一个Handler和允许的主机名。在函数内部，我们创建了一个类似之前版本ServeHTTP的函数。这个内部函数其实是一个闭包，所以它可以从SingleHost外部访问。最终，我们通过<a href="http://golang.org/pkg/net/http/#HandlerFunc">HandlerFunc</a>把这个函数用作http.Handler。</p><p>使用Handler还是定义一个http.Handler类型完全取决于你。对简单的情况而已，一个函数就足够了。但是随着中间件功能的复杂，你应该考虑定义自己的数据结构，把逻辑独立到多个方法中。</p><p>实际上，标准库这两种方法都用了。<a href="http://golang.org/pkg/net/http/#StripPrefix">StripPrefix</a> 是一个返回HandlerFunc的函数。虽然<a href="http://golang.org/pkg/net/http/#TimeoutHandler">TimeoutHandler</a>也是一个函数，但它返回了处理请求的自定义的类型。</p><h3 id="更复杂的情况">更复杂的情况</h3><p>我们的SingleHost中间件非常简单：先检查请求的一个属性，然后要么什么也不管，把请求直接传给封装的Handler；要么自己返回一个响应，根本不让封装的Handler处理这次请求。然而，有些情况是这样的，不但基于请求触发一些动作，还要在封装的Handler处理后做一些扫尾工作，比如修改响应内容等。</p><h3 id="添加数据比较容易">添加数据比较容易</h3><p>如果我们想在封装的handler输出的内容后添加一些数据，我们只需要在handler结束后继续调用Write()即可：</p><pre><code>type AppendMiddleware struct {
    handler http.Handler
}

func (a *AppendMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    a.handler.ServeHTTP(w, r)
    w.Write([]byte(&quot;Middleware says hello.&quot;))
}
</code></pre><p>响应内容现在就应该包含封装的handler的内容，再加上Middleware says hello.</p><h3 id="问题是">问题是</h3><p>做其他的响应内容操作比较麻烦。比如，如果我们想在响应内容前写入一些数据。如果我们在封装的handler前调用Write()，那么封装的handler就好失去对HTTP状态码和HTTP头的控制。因为第一次调用Write()会直接将头输出。</p><p>想要修改原有输出（比如，替换其中的某些字符串），改变特定的HTTP头，设置不同的状态码也都因为同样的原因而不可行：当封装的handler返回时，上述数据早已被发送给客户端了。</p><p>为了处理这样的需求，我们需要一种特殊的可以用做buffer的ResponseWriter,它能够收集、暂存输出以用于修改等操作，最后再发送给客户端。我们可以将这个带buffer的ResponseWriter传给封装的handler，而不是真实的RW，这样就避免直接发送数据给客户端。</p><p>幸运的是，在Go标准库中确实存在这样一个工具。net/http/httptest中的<a href="http://golang.org/pkg/net/http/httptest/#ResponseRecorder">ResponseRecorder</a>就是这样的：它保存状态码，一个保存响应头的字典，将输出累计在buffer中。尽管是用于测试（这个包名暗示了这一点），它还是很好的满足了我们的需求。</p><p>让我们看一个使用ResponseRecorder的例子，这里修改了响应内容的所有东西，是为了更完整的演示。</p><pre><code>type ModifierMiddleware struct {

    handler http.Handler

}

func (m *ModifierMiddleware) ServeHTTP(w http.ResponseWriter, r *http.Request) {

    rec := httptest.NewRecorder()

    // passing a ResponseRecorder instead of the original RW

    m.handler.ServeHTTP(rec, r)

    // after this finishes, we have the response recorded

    // and can modify it before copying it to the original RW

    // we copy the original headers first

    for k, v := range rec.Header() {

        w.Header()[k] = v

    }

    // and set an additional one

    w.Header().Set(&quot;X-We-Modified-This&quot;, &quot;Yup&quot;)

    // only then the status code, as this call writes out the headers 

    w.WriteHeader(418)

    // the body hasn't been written (to the real RW) yet,

    // so we can prepend some data.

    w.Write([]byte(&quot;Middleware says hello again. &quot;))

    // then write out the original body

    w.Write(rec.Body.Bytes())

}
</code></pre><p>下面是我们包装的handler的输出。如果不用我们的中间件封装，原来的handler仅仅会输出Success！。</p><pre><code>HTTP/1.1 418 I'm a teapot

X-We-Modified-This: Yup

Content-Type: text/plain; charset=utf-8

Content-Length: 37

Date: Tue, 03 Sep 2013 18:41:39 GMT

Middleware says hello again. Success!
</code></pre><p>这种方式提供了非常大的便利。被封装的handler现在完全在我们的控制之下：即使在其返回之后，我们也可以以任意方式操作输出。</p><h3 id="和其他handlers共享数据">和其他handlers共享数据</h3><p>在不同的情况下，中间件可以需要给其他的中间件或者应用程序暴露特定的信息。比如，nosurf需要给用户提供一种获取CSRF 密钥的方式以及错误原因（如果有错误的话）。</p><p>对这种需求，一个合适的模型就是使用一个隐藏的map，将http.Request指针指向需要的数据，然后暴露一个包级别（handler级别）的函数来访问这些数据。</p><p>我在nosurf中也使用了这种模型。这里，我创建了一个全局的上下文map。注意到，由于默认情况下Go的map并不是[并发访问安全](<a href="http://blog.golang.org/go-maps-in-action#TOC_6">http://blog.golang.org/go-maps-in-action#TOC_6</a>.）的，需要一个mutex。</p><pre><code>type csrfContext struct {

    token string

    reason error

}

var (

    contextMap = make(map[*http.Request]*csrfContext)

    cmMutex    = new(sync.RWMutex)

)
</code></pre><p>使用handler设置数据，然后通过暴露的函数Token()来获取数据。</p><pre><code>func Token(req *http.Request) string {

    cmMutex.RLock()

    defer cmMutex.RUnlock()

    ctx, ok := contextMap[req]

    if !ok {

            return &quot;&quot;

    }

    return ctx.token

}
</code></pre><p>你可以在nosurf的代码库<a href="https://github.com/justinas/nosurf/blob/master/context.go">context.go</a>中找到完整的实现。</p><p>虽然我选择在nosurf中自己实现这种需求，但实际上存在一个方便的 <a href="http://www.gorillatoolkit.org/pkg/context#ClearHandler">gorilla/context</a>包，它实现了一个通用的保存请求信息的map。在大多数情况下，这个包足以满足你的需求，避免你在自己实现一个共享存储时踩坑。它甚至还有一个<a href="http://www.gorillatoolkit.org/pkg/context#ClearHandler">自己的中间件</a>能在请求处理结束之后清除请求信息。</p><h3 id="总结">总结</h3><p>这篇文章的目的是吸引Go用户对中间件概念的注意以及展示使用Go写中间件的一些基本组件。尽管Go是一个相对年轻的开发语言，Go拥有非常<a href="http://justinas.org/embrace-gos-http-tools/">漂亮的标准HTTP接口</a>。这也是用Go写中间件是个非常简单甚至快乐的过程的原因之一。</p><p>然而，目前Go仍然缺乏高质量的HTTP工具。我之前提到的<a href="http://justinas.org/writing-http-middleware-in-go/#usecases">Go中间件想法</a>，大多都还没实现。现在你已经知道如何用Go写中间件了，为什么不自己做一个呢？</p><p>PS，你可以在一个<a href="https://gist.github.com/justinas/7059324">GitHub gist</a>中找到这篇文章中所有的中间件例子。</p><hr><p>原文链接： <a href="http://justinas.org/writing-http-middleware-in-go/">Writing HTTP Middleware in Go</a><br>转载自： <a href="http://blog.jobbole.com/">伯乐在线</a> - <a href="http://blog.jobbole.com/author/codefor/">Codefor</a></p></div><aside id="meta"><meta itemprop="wordCount" content="387"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/http.html" rel="tag">http</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/shen-ru--go-playground-nei-mu.html">深入GoPlayground内幕</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/golangbiao-zhun-ku-de-fen-xi-osbao-6.html">golang标准库的分析os包(6)</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="061574caa277f2dca9be539409914684" data-title="用Go语言写HTTP中间件" data-url="https://yushuangqi.com/blog/2016/yong-goyu-yan-xie-httpzhong-jian-jian.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fyong-goyu-yan-xie-httpzhong-jian-jian.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fyong-goyu-yan-xie-httpzhong-jian-jian.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Golang开发★SRE运维。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>