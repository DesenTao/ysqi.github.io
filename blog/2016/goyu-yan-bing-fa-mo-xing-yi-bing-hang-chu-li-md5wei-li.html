<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语言并发模型:以并行处理MD5为例 |极客虞双齐</title><meta name="description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data p"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="极客虞双齐"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html"><meta property="og:title" content="Go语言并发模型:以并行处理MD5为例"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:33:12"><meta property="article:modified_time" content="2016-12-31 11:33:12"><meta property="article:tag" content="golang"><meta name="og:description" content="简介 Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data p"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html">Go语言并发模型:以并行处理MD5为例</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000006670880" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="简介">简介</h2><p>Go语言的并发原语允许开发者以类似于 Unix Pipe 的方式构建数据流水线 (data pipelines)，数据流水线能够高效地利用 I/O和多核 CPU 的优势。</p><p>本文要讲的就是一些使用流水线的一些例子，流水线的错误处理也是本文的重点。</p><h2 id="阅读建议">阅读建议</h2><p>本文是<a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a><br>一文的下半部分，但重点在于实践。如果你对 channel 已经比较熟悉，则可以独立阅读。<br>如果你对 channel 和 go 两个关键字不太熟悉，建议先阅读上半部分。</p><p>本文所使用的例子是批量计算文件的MD5值，实现了 linux 下的 md5sum 命令。<br>我们首先会讲到 md5sum 的单线程版本，逐步深入到并发的初级和高级版本。</p><p>本文中绝大多数讲解都是基于代码进行的。在文章末尾&rdquo;相关链接&rdquo;中可以下载三个版本的 md5sum 的实现。</p><h2 id="单线程版的-md5sum">单线程版的 md5sum</h2><p>MD5 是一种广泛用于文件校验的 hash 算法。Linux 下的 md5sum 命令会打印一组文件的 md5值。它的使用方式如下：</p><pre><code>% md5sum *.go
c33237079343a4d567a2a29df0b8e46e  bounded.go
a7e3771f2ed58d4b34a73566d93ce63a  parallel.go
1dc687202696d650594aaac56d579179  serial.go
</code></pre><p>我们的示例程序类似于 md5sum，但是它接收文件夹作为参数，并打印出每个文件的 md5值，打印结果按照路径排序。<br>下面这个例子是 打印当前目录下所有文件的 md5 值：</p><pre><code>% go run serial.go .
c33237079343a4d567a2a29df0b8e46e  bounded.go
a7e3771f2ed58d4b34a73566d93ce63a  parallel.go
1dc687202696d650594aaac56d579179  serial.go
</code></pre><p>程序的 main 函数调用辅助函数 MD5All，它会返回路径名称到md5值的一个映射。main 函数中对结果进行排序以后，打印出来：</p><pre><code>func main() {
    // 计算特定目录下所有文件的 md5值， 
    // 然后按照路径名顺序打印结果
    m, err := MD5All(os.Args[1])
    if err != nil {
        fmt.Println(err)
        return
    }
    var paths []string
    for path := range m {
        paths = append(paths, path)
    }
    sort.Strings(paths)
    for _, path := range paths {
        fmt.Printf(&quot;%x  %s\n&quot;, m[path], path)
    }
}
</code></pre><p>本文中，函数 MD5All 是讨论的焦点。在 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a>的实现中，我们没有使用并发，而是逐个读取和计算 filepath.Walk 生成的目录和文件。代码如下：</p><pre><code>// MD5All 读取 root 目录下的所有文件，返回一个map
// 该 map 存储了 文件路径到文件内容 md5值的映射
// 如果 Walk 执行失败，或者 ioutil.ReadFile 读取失败，
// MD5All 都会返回错误
func MD5All(root string) (map[string][md5.Size]byte, error) {
    m := make(map[string][md5.Size]byte)
    err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        if !info.Mode().IsRegular() {
            return nil
        }
        data, err := ioutil.ReadFile(path)
        if err != nil {
            return err
        }
        m[path] = md5.Sum(data)
        return nil
    })
    if err != nil {
        return nil, err
    }
    return m, nil
}
</code></pre><p>上面的代码中，<a href="https://golang.org/pkg/path/filepath/#Walk">filepath.Walk</a> 接收两个参数，文件路径和函数指针。<br>只要是函数签名和返回值 满足 <code>func(string, os.FileInfo, error) error</code>，均可以作为第二参数传递给 filepath.Walk。</p><p>点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a> 下载单线程版本的 md5sum。</p><h2 id="并发版的-md5sum">并发版的 md5sum</h2><p>点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">parallel.go</a> 下载并发版 md5sum 的代码。</p><p>在这个版本的实现中，我们把 MD5All 切割成两个阶段的流水线。<br>第一阶段是 sumFiles，它遍历文件树，每个文件都在一个新的 goroutine 里计算md5值，然后将结果发送到一个result 类型的channel里。<br>result 类型的定义如下：</p><pre><code>type result struct {
    path string
    sum  [md5.Size]byte
    err  error
}
</code></pre><p>sumFiles 返回两个 channel，一个用于接收 md5计算的结果，一个用于接收 filepath.Walk 产生的错误。<br>Walk 函数为每一个文件创建一个 goroutine，然后检查 done channel。如果 done channel 被关闭，walk 函数立即停止执行。代码示例如下：</p><pre><code>func sumFiles(done &lt;-chan struct{}, root string) (&lt;-chan result, &lt;-chan error) {
    // 对于每一个普通文件，启动一个 gorotuine 计算文件 md5 值，
    // 然后 将结果发送到 c。
    // walk 的错误结果发送到 errc。
    c := make(chan result)
    errc := make(chan error, 1)
    go func() {
        var wg sync.WaitGroup
        err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            if !info.Mode().IsRegular() {
                return nil
            }
            wg.Add(1)
            go func() {
                data, err := ioutil.ReadFile(path)
                select {
                case c &lt;- result{path, md5.Sum(data), err}:
                case &lt;-done:
                }
                wg.Done()
            }()
            // done channel 关闭时，终止 walk 函数
            select {
            case &lt;-done:
                return errors.New(&quot;walk canceled&quot;)
            default:
                return nil
            }
        })
        // Walk 函数已经返回，所以 所有对 wg.Add 的调用都会结束
        // 启动一个 goroutine， 它会在所有发送都结束时，关闭 c。
        go func() {
            wg.Wait()
            close(c)
        }()
        // 这里不需要 select 语句，应为 errc 是缓冲管道
        errc &lt;- err
    }()
    return c, errc
}
</code></pre><p>MD5All 从 c 接收 md5值。 MD5All 遇到错误时会提前返回，通过 defer 语句关闭 done channel：</p><pre><code>func MD5All(root string) (map[string][md5.Size]byte, error) {
    // MD5All 在函数返回时关闭 done channel
    // 在从 c 和 errc 接收数据前，也可能关闭
    done := make(chan struct{})
    defer close(done)

    c, errc := sumFiles(done, root)

    m := make(map[string][md5.Size]byte)
    for r := range c {
        if r.err != nil {
            return nil, r.err
        }
        m[r.path] = r.sum
    }
    if err := &lt;-errc; err != nil {
        return nil, err
    }
    return m, nil
}
</code></pre><h2 id="限制并发量">限制并发量</h2><p>在 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">并发版 MD5All (parallel.go)</a> 的实现中，<br>我们为每个文件创建了一个 goroutine。如果一个目录中包含很多大文件，可能出现OOM。</p><p>我们对并发读取的文件数目稍作限制，进而限制内存的分配。点击 <a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/bounded.go">bounded.go</a><br>查看限制并发版本的 md5sum。 为了实现限制的目的，我们创建固定数量的 goroutine 用于读取文件。<br>这里的流水线包含三个阶段：遍历文件和目录、读取并计算md5值、搜集和整合计算结果。</p><p>第一阶段时 walkFiles，它生成一个目录下每个普通文件的路径。代码如下：</p><pre><code>func walkFiles(done &lt;-chan struct{}, root string) (&lt;-chan string, &lt;-chan error) {
    paths := make(chan string)
    errc := make(chan error, 1)
    go func() {
        // Walk 函数返回时，关闭 channel paths
        defer close(paths)
        // 这里不需要select，因为 errc 是缓冲 channel
        errc &lt;- filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            if !info.Mode().IsRegular() {
                return nil
            }
            select {
            case paths &lt;- path:
            case &lt;-done:
                return errors.New(&quot;walk canceled&quot;)
            }
            return nil
        })
    }()
    return paths, errc
}
</code></pre><p>第二阶段创建固定个数的goroutine digester，每个 digester 从 paths channel 读取文件名，并将结果发送给 c。代码如下：</p><pre><code>func digester(done &lt;-chan struct{}, paths &lt;-chan string, c chan&lt;- result) {
    for path := range paths {
        data, err := ioutil.ReadFile(path)
        select {
        case c &lt;- result{path, md5.Sum(data), err}:
        case &lt;-done:
            return
        }
    }
}
</code></pre><p>不像前面的例子，这里 digester 没有关闭输出 channel c，因为 多个 digester 在共享这个channel。<br>关闭操作放到 MD5All 中实现，当所有 digester 运行结束时，MD5All 关闭这个channel。代码如下：</p><pre><code>    // 启动固定数量的 goroutine 处理文件
    c := make(chan result)
    var wg sync.WaitGroup
    const numDigesters = 20
    wg.Add(numDigesters)
    for i := 0; i &lt; numDigesters; i++ {
        go func() {
            digester(done, paths, c)
            wg.Done()
        }()
    }
    go func() {
        wg.Wait()
        close(c)
    }()
</code></pre><p>我们可以让每个 digester 创建和返回自己的输出 channel。如果这样做，我们还需要额外的 goroutine 去合并结果。</p><p>第三阶段从 channel c 接收结果，并从 channel errc 读取错误信息并执行检查。<br>检查操作不能在 c 读取结束之前完成，因为 walkFiles 函数可能会被阻塞而无法向下游阶段发送数据。 代码如下：</p><pre><code>// ... 省略部分代码 ...
    m := make(map[string][md5.Size]byte)
    for r := range c {
        if r.err != nil {
            return nil, r.err
        }
        m[r.path] = r.sum
    }
    // Check whether the Walk failed.
    if err := &lt;-errc; err != nil {
        return nil, err
    }
    return m, nil
} 
</code></pre><p>关于Go语言并发模型，使用 Go内置的 channel 类型和 go 关键字实现高并发和并发控制的主题就先到这里。<br>在最近发布的 go 1.7中，在核心库中广泛加入了对 context 的支持，以便更好地控制并发和超时。但在这之前<br>golang.org/x/net/context 包就一直存在，下一期我们将对 <a href="https://blog.golang.org/context">context 包</a>及其应用场景进行讨论。</p><h2 id="相关链接">相关链接</h2><ol><li><p><a href="https://blog.golang.org/pipelines">原文链接</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/serial.go">serial.go</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/parallel.go">parallel.go</a></p></li><li><p><a href="http://oat5ddzns.bkt.clouddn.com/src/piplines/bounded.go">bounded.go</a></p></li><li><p><a href="https://blog.golang.org/context">golang.org/x/net/context</a></p></li></ol><p>扫码关注微信公众号“深入Go语言”</p></div><aside id="meta"><meta itemprop="wordCount" content="766"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-xiang-unix-pipena-yang-shi-yong-channel.html">Go语言并发模型:像UnixPipe那样使用channel</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/golang-zhi--gong-cheng-jie-gou.html">Golang之工程结构</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sourceid="5cf56f5c1a33b6d9fa1f02e79b9bdad6"></div><div id="SOHUCS" sid="5cf56f5c1a33b6d9fa1f02e79b9bdad6"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，一名全栈开发工程师，#热爱编程、#工具控、#爱读书、#宅男</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="极客虞双齐">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-bing-fa-mo-xing-yi-bing-hang-chu-li-md5wei-li.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-爱分享的极客。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>