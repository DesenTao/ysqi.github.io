<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>golang并发编程的两种限速方法 |虞双齐Golang开发与SRE运维</title><meta name="description" content="引子 golang提供了goroutine快速实现并发编程，在实际环境中，如果goroutine中的"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/golangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html"><meta property="og:title" content="golang并发编程的两种限速方法"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:33:22"><meta property="article:modified_time" content="2016-12-31 11:33:22"><meta property="article:tag" content="golang"><meta name="og:description" content="引子 golang提供了goroutine快速实现并发编程，在实际环境中，如果goroutine中的"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/golangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html">golang并发编程的两种限速方法</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000005944664" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="引子">引子</h2><p>golang提供了goroutine快速实现并发编程，在实际环境中，如果goroutine中的代码要消耗大量资源时（CPU、内存、带宽等），我们就需要对程序限速，以防止goroutine将资源耗尽。<br>以下面伪代码为例，看看goroutine如何拖垮一台DB。假设userList长度为10000，先从数据库中查询userList中的user是否在数据库中存在，存在则忽略，不存在则创建。</p><pre><code>//不使用goroutine，程序运行时间长，但数据库压力不大
for _,v:=range userList {
    user:=db.user.Get(v.ID)
    if user==nil {
        newUser:=user{ID:v.ID,UserName:v.UserName}
        db.user.Insert(newUser)
    }
}

//使用goroutine，程序运行时间短，但数据库可能被拖垮
for _,v:=range userList {
    u:=v
    go func(){
        user:=db.user.Get(u.ID)
        if user==nil {
            newUser:=user{ID:u.ID,UserName:u.UserName}
            db.user.Insert(newUser)
        }
    }()
}
select{}
</code></pre><p>在示例中，DB在1秒内接收10000次读操作，最大还会接受10000次写操作，普通的DB服务器很难支撑。针对DB，可以在连接池上做手脚，控制访问DB的速度，这里我们讨论两种通用的方法。</p><h2 id="方案一">方案一</h2><p>在限速时，一种方案是丢弃请求，即请求速度太快时，对后进入的请求直接抛弃。</p><h3 id="实现">实现</h3><p>实现逻辑如下：</p><pre><code>package main

import (
    &quot;sync&quot;
    &quot;time&quot;
)

//LimitRate 限速
type LimitRate struct {
    rate     int
    begin    time.Time
    count    int
    lock     sync.Mutex
}

//Limit Limit
func (l *LimitRate) Limit() bool {
    result := true
    l.lock.Lock()
    //达到每秒速率限制数量，检测记数时间是否大于1秒
    //大于则速率在允许范围内，开始重新记数，返回true
    //小于，则返回false，记数不变
    if l.count == l.rate {
        if time.Now().Sub(l.begin) &gt;= time.Second {
            //速度允许范围内，开始重新记数
            l.begin = time.Now()
            l.count = 0
        } else {
            result = false
        }
    } else {
        //没有达到速率限制数量，记数加1
        l.count++
    }
    l.lock.Unlock()

    return result
}

//SetRate 设置每秒允许的请求数
func (l *LimitRate) SetRate(r int) {
    l.rate = r
    l.begin = time.Now()
}

//GetRate 获取每秒允许的请求数
func (l *LimitRate) GetRate() int {
    return l.rate
}
</code></pre><h3 id="测试">测试</h3><p>下面是测试代码：</p><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    var wg sync.WaitGroup
    var lr LimitRate
    lr.SetRate(3)

    for i:=0;i&lt;10;i++{
        wg.Add(1)
            go func(){
                if lr.Limit() {
                    fmt.Println(&quot;Got it!&quot;)//显示3次Got it!
                }            
                wg.Done()
            }()
    }
    wg.Wait()
}
</code></pre><p>运行结果</p><pre><code>Got it!
Got it!
Got it!
</code></pre><p>只显示3次Got it!，说明另外7次Limit返回的结果为false。限速成功。</p><h2 id="方案二">方案二</h2><p>在限速时，另一种方案是等待，即请求速度太快时，后到达的请求等待前面的请求完成后才能运行。这种方案类似一个队列。</p><h3 id="实现-1">实现</h3><pre><code>//LimitRate 限速
type LimitRate struct {
    rate       int
    interval   time.Duration
    lastAction time.Time
    lock       sync.Mutex
}

//Limit 限速
package main

import (
    &quot;sync&quot;
    &quot;time&quot;
)

func (l *LimitRate) Limit() bool {
    result := false
    for {
        l.lock.Lock()
        //判断最后一次执行的时间与当前的时间间隔是否大于限速速率
        if time.Now().Sub(l.lastAction) &gt; l.interval {
            l.lastAction = time.Now()
                result = true
            }
        l.lock.Unlock()
        if result {
            return result
        }
        time.Sleep(l.interval)
    }
}

//SetRate 设置Rate
func (l *LimitRate) SetRate(r int) {
    l.rate = r
    l.interval = time.Microsecond * time.Duration(1000*1000/l.Rate)
}

//GetRate 获取Rate
func (l *LimitRate) GetRate() int {
    return l.rate 
}
</code></pre><h3 id="测试-1">测试</h3><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func main() {
    var wg sync.WaitGroup
    var lr LimitRate
    lr.SetRate(3)

    b:=time.Now()
    for i := 0; i &lt; 10; i++ {
        wg.Add(1)
        go func() {
            if lr.Limit() {
                fmt.Println(&quot;Got it!&quot;)
            }
            wg.Done()
        }()
    }
    wg.Wait()
    fmt.Println(time.Since(b))
}
</code></pre><p>运行结果</p><pre><code>Got it!
Got it!
Got it!
Got it!
Got it!
Got it!
Got it!
Got it!
Got it!
Got it!
3.004961704s
</code></pre><p>与方案一不同，显示了10次Got it!但是运行时间是3.00496秒，同样每秒没有超过3次。限速成功。</p><h2 id="改造">改造</h2><p>回到最初的例子中，我们将限速功能加进去。这里需要注意，我们的例子中，请求是不能被丢弃的，只能排队等待，所以我们使用方案二的限速方法。</p><pre><code>var lr LimitRate//方案二
//限制每秒运行20次，可以根据实际环境调整限速设置，或者由程序动态调整。
lr.SetRate(20)

//使用goroutine，程序运行时间短，但数据库可能被拖垮
for _,v:=range userList {
    u:=v
    go func(){
        lr.Limit()
        user:=db.user.Get(u.ID)
        if user==nil {
            newUser:=user{ID:u.ID,UserName:u.UserName}
            db.user.Insert(newUser)
        }
    }()
}
select{}
</code></pre><p>如果您有更好的方案欢迎交流与分享。</p><p><strong>内容为作者原创，未经允许请勿转载，谢谢合作。</strong></p><hr><p>关于作者：<br>Jesse，目前在Joygenio工作，从事golang语言开发与架构设计。<br>正在开发维护的产品：<a href="http://www.botposter.com">www.botposter.com</a></p></div><aside id="meta"><meta itemprop="wordCount" content="370"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/golangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/glideshi-yong.html">glide使用</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/goyu-yan-xue-xi-bi-ji-yi-.html">Go语言学习笔记(一)</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="aca457c7f411e35450658e6ef0c4d39c" data-title="golang并发编程的两种限速方法" data-url="https://yushuangqi.com/blog/2016/golangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgolangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgolangbing-fa-bian-cheng-de-liang-chong-xian-su-fang-fa.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-#Golang开发 #SRE运维。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>