<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>【翻译】go是面向对象语言吗？ |极客虞双齐</title><meta name="description" content="原文：http://spf13.com/post/is-go-object-oriented
前言 "><meta name="keywords" content="翻译, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="极客虞双齐"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/fan-yi-goshi-mian-xiang-dui-xiang-yu-yan-ma-.html"><meta property="og:title" content="【翻译】go是面向对象语言吗？"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:39"><meta property="article:modified_time" content="2016-12-31 11:34:39"><meta property="article:tag" content="翻译"><meta property="article:tag" content="golang"><meta name="og:description" content="原文：http://spf13.com/post/is-go-object-oriented
前言 "><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/fan-yi-goshi-mian-xiang-dui-xiang-yu-yan-ma-.html">【翻译】go是面向对象语言吗？</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000001832282" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>原文：<a href="http://spf13.com/post/is-go-object-oriented">http://spf13.com/post/is-go-object-oriented</a></p><h2 id="前言">前言</h2><p>为了真正理解面向对象的含义，我们需要回顾一下这个概念的起源。第一个面向对象语言-simula问世于19世纪60年代。它引入了对象（object)、类（class）、继承（inheritance）、子类（subclass）、虚方法（virtual method）、协程（coroutine）等概念。然而simula最重要的贡献可能是它引入颠覆性的思想——将数据和逻辑完全分离。</p><p>你可能不熟悉simula语言，但你肯定熟悉Java, C++, C# &amp; Smalltalk中的一种，这些语言深受simula的影响，当然这些语言又同时影响着现今几乎所有的高级语言如：Objective C, Python, Ruby, Javascript, Scala, PHP, Perl… 大部分程序员都遵循着将数据和逻辑完全分离的原则。</p><p>由于面向对象没有标准的定义，为了讨论的方便，接下来我们将提供一个标准的定义。</p><blockquote><p>面向对象系统将数据和代码通过“对象”集成到一起，而不是将程序看成由分离的数据和代码组成。对象是数据类型的抽象，它有状态（数据）和行为（代码）</p></blockquote><p>面向对象包括继承、多态、虚派生等特性，接下来我们将看看go语言是怎样处理对象、多态、继承，相信读完接下来的介绍，您会对go是如何处理面向对象有自己的见解。</p><h2 id="go中的对象">go中的对象</h2><p>go语言中没有对象(object)这个关键词。对象（object）仅仅是一个单词，重要的是它所表示的含义。尽管go中没有object这种类型，但是go中的struct有着跟object相同的特性。</p><blockquote><p>struct是一种包含了命名域和方法的类型</p></blockquote><p>让我们从一个例子中来理解它：</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">type</span> rect <span style="color:#007020;font-weight:700">struct</span> {
        width <span style="color:#902000">int</span>
        height <span style="color:#902000">int</span>
    }

    <span style="color:#007020;font-weight:700">func</span> (r <span style="color:#666">*</span>rect) area() <span style="color:#902000">int</span> {
        <span style="color:#007020;font-weight:700">return</span> r.width <span style="color:#666">*</span> r.height
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        r <span style="color:#666">:=</span> rect{width: <span style="color:#40a070">10</span>, height: <span style="color:#40a070">5</span>}
        fmt.Println(<span style="color:#4070a0">&quot;area: &quot;</span>, r.area())
    }
</pre></div><p>我们一行行来解释一下上面的代码。代码的第一块定义了一个叫做rect的struct类型，该struct含有两个int类型的域；接下来定义了一个绑定在rect struct类型上的area方法。严格来说，area方法是绑定在指向rectct struct的指针上。如果方法绑定在rect type而非指针上，则在调用方法的时候需要使用该类型的值来调用，即使该值是空值，本例的空值实际是一个nil值；代码的最后一块是main函数，main函数第一行创建了一个rect类型的值,当然也有其他的方法来创建一个类型的值，这里给出的是一个地道的方法。main函数的最后一行是打印作用在r值上的area方法的返回结果。</p><p>通过上面的描述，可以看出这很像对象的行为，我们可以创建一个结构化的数据类型，然后定义方法和这些数据进行交互。上述的简单例子并没有完成展示面向对象的所有特性，比如继承和多态。需要说明的是go不仅可以在struct上定义方法，在任何命名的类型上同样也可以。比如，可以定义一个名为Counter的新类型，该类型是int型的别名，然后在Counter类型上定义方法。例子详见：<a href="http://play.golang.org/p/LGB-2j707c">http://play.golang.org/p/LGB-2j707c</a></p><h2 id="继承和多态">继承和多态</h2><p>定义对象间的关系的方法有如下几种，它们之间都有一些差别，但目的都是一样的：复用代码。</p><ul><li>单继承（Inheritance）</li><li>多继承（Multiple Inheritance）</li><li>多态（Subtyping/Polymorphism）</li><li>对象组合（Object composition）</li></ul><p>继承：一个对象基于另外一个对象，使用其实现。有两种不同的继承实现：单继承和多继承。它们的不同在于对象是继承自一个对象还是多个对象。单继承关系是一棵树，而多继承关系是一个格状结构。单继承语言包括PHP、C#、Java、Ruby等，多继承语言包括Perl、Python、C++等</p><h2 id="多态">多态</h2><p>多态是is-a的关系，继承是实现的复用。多态定义了两个对象的语义关系，继承定义两个对象的语法关系。</p><h2 id="对象组合">对象组合</h2><p>对象组合是一个对象包含了其他对象，而非继承，它是has-a的关系，而非is-a。</p><h2 id="go语言的继承">go语言的继承</h2><p>go有意得被设计为没有继承语法。但这并不意味go中的对象（struct value)之间没有关系，只不过go的作者选择了另外一种机制来暗含这种特性。实际上go的这种设计是一种非常好的解决方法，它解决了围绕着继承的数十年的老问题和争论。</p><h2 id="最好不要继承">最好不要继承</h2><p>下面引用的一段来自javaworld的一篇名为《<a href="http://www.javaworld.com/article/2073649/core-java/why-extends-is-evil.html">why extends is evil</a>》的文章说明了这一点。</p><blockquote><p>The Gang of Four Design Patterns book discusses at length replacing implementation inheritance (extends) with interface inheritance (implements).</p><p>I once attended a Java user group meeting where James Gosling (Java’s inventor) was the featured speaker. During the memorable Q&amp;A session, someone asked him: “If you could do Java over again, what would you change?” “I’d leave out classes,” he replied. After the laughter died down, he explained that the real problem wasn’t classes per se, but rather implementation inheritance (the extends relationship). Interface inheritance (the implements relationship) is preferable. You should avoid implementation inheritance whenever possible.</p></blockquote><h2 id="go语言中的多态和组合">go语言中的多态和组合</h2><p>go语言严格遵守<a href="http://en.wikipedia.org/wiki/Composition_over_inheritance">composition over inheritance principle</a>的原则。go通过在struct和interface上使用组合和多态来实现继承关系。<br>Person和Address之间的关系是这种实现的一个很好的例子：<a href="http://play.golang.org/p/LigPIVT2mf">http://play.golang.org/p/LigPIVT2mf</a>。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">type</span> Person <span style="color:#007020;font-weight:700">struct</span> {
       Name <span style="color:#902000">string</span>
       Address Address
    }

    <span style="color:#007020;font-weight:700">type</span> Address <span style="color:#007020;font-weight:700">struct</span> {
       Number <span style="color:#902000">string</span>
       Street <span style="color:#902000">string</span>
       City   <span style="color:#902000">string</span>
       State  <span style="color:#902000">string</span>
       Zip    <span style="color:#902000">string</span>
    }

    <span style="color:#007020;font-weight:700">func</span> (p <span style="color:#666">*</span>Person) Talk() {
        fmt.Println(<span style="color:#4070a0">&quot;Hi, my name is&quot;</span>, p.Name)
    }

    <span style="color:#007020;font-weight:700">func</span> (p <span style="color:#666">*</span>Person) Location() {
        fmt.Println(<span style="color:#4070a0">&quot;I’m at&quot;</span>, p.Address.Number, p.Address.Street, p.Address.City, p.Address.State, p.Address.Zip)
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        p <span style="color:#666">:=</span> Person{
            Name: <span style="color:#4070a0">&quot;Steve&quot;</span>,
            Address: Address{
                Number: <span style="color:#4070a0">&quot;13&quot;</span>,
                Street: <span style="color:#4070a0">&quot;Main&quot;</span>,
                City:   <span style="color:#4070a0">&quot;Gotham&quot;</span>,
                State:  <span style="color:#4070a0">&quot;NY&quot;</span>,
                Zip:    <span style="color:#4070a0">&quot;01313&quot;</span>,
            },
        }

        p.Talk()
        p.Location()
    }
</pre></div><p><strong>Output</strong></p><blockquote><p>Hi, my name is Steve<br>I’m at 13 Main Gotham NY 01313</p></blockquote><p>上面的例子需要注意的是， Address仍然是一个不同的对象，只不过存在于Person中。</p><h2 id="go中的伪多态">go中的伪多态</h2><blockquote><p>AUTHORS NOTE:<br>In the first version of this post it made the incorrect claim that Go supports the is-a relationship via Anonymous fields. In reality Anonymous fields appear to be an is-a relationship by exposing embedded methods and properties as if they existed on the outer struct. This falls short of being an is-a relationship for reasons now provided below. Go does have support for is-a relationships via interfaces, covered below. The current version of this post refers to Anonymous fields as a pseudo is-a relationship because it looks and behaves in some ways like subtyping, but isn’t.</p></blockquote><p>我们通过扩展上面的例子来说明go中的伪多态。注意这里“伪”字说明实际上go是没有多态的概念的，只不过伪多态表现得像多态一样。下面的例子中，Person可以说话(Talk），一个Citizen也同时是一个Person，因此他也能说话(Talk）。在上面的例子中加入如下内容，完整代码见：<a href="http://play.golang.org/p/eCEpLkQPR3">http://play.golang.org/p/eCEpLkQPR3</a>。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">type</span> Citizen <span style="color:#007020;font-weight:700">struct</span> {
       Country <span style="color:#902000">string</span>
       Person
    }

    <span style="color:#007020;font-weight:700">func</span> (c <span style="color:#666">*</span>Citizen) Nationality() {
        fmt.Println(c.Name, <span style="color:#4070a0">&quot;is a citizen of&quot;</span>, c.Country)
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        c <span style="color:#666">:=</span> Citizen{}
        c.Name = <span style="color:#4070a0">&quot;Steve&quot;</span>
        c.Country = <span style="color:#4070a0">&quot;America&quot;</span>
        c.Talk()
        c.Nationality()
    }
</pre></div><p>上面的例子通过引入匿名域（Person）实现了is-a关系。Person是Citizen的一个匿名域（anonymous field），匿名域只给出了对象类型，而不给出类型的名字。通过匿名域，Citizen可以访问Person中的所有属性（域）和方法。</p><h2 id="匿名域方法提升">匿名域方法提升</h2><p>上述例子，Citizen可以和Person执行一样的Talk()方法。但如果想要Citizen的Talk()表现出不同的行为该怎么做呢？我们只需要在Citizen上定义方法Talk()即可。当调用c.Talk()的时候，调用的则是Citizen的Talk()方法而非Person的Talk()方法，<a href="http://play.golang.org/p/jafbVPv5H9">http://play.golang.org/p/jafbVPv5H9</a>。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">func</span> (c <span style="color:#666">*</span>Citizen) Talk() {
        fmt.Println(<span style="color:#4070a0">&quot;Hello, my name is&quot;</span>, c.Name, <span style="color:#4070a0">&quot;and I&#39;m from&quot;</span>, c.Country)
    }
</pre></div><p><strong>Output</strong></p><blockquote><p>Hello, my name is Steve and I&rsquo;m from America<br>Steve is a citizen of America</p></blockquote><h2 id="为何匿名域不是合适的多态实现">为何匿名域不是合适的多态实现</h2><p>有两个原因：<br>1. 匿名域仍然能被访问，就好像它们是被嵌入的对象一样。<br>这并不是一件坏事，多继承存在的一个问题就是当多个父类具有相同的方法的时候，会产生歧义。然而go语言可以通过访问跟匿名类型同名的属性来访问嵌入的匿名对象。实际上当使用匿名域的时候，go会创建一个跟匿名类型同名的对象。上面的例子中，修改main方法如下，我们能很清楚得看出这一点：</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">func</span> main() {
    <span style="color:#60a0b0;font-style:italic">//    c := Citizen{}</span>
        c.Name = <span style="color:#4070a0">&quot;Steve&quot;</span>
        c.Country = <span style="color:#4070a0">&quot;America&quot;</span>
        c.Talk()         <span style="color:#60a0b0;font-style:italic">// &lt;- Notice both are accessible</span>
        c.Person.Talk()  <span style="color:#60a0b0;font-style:italic">// &lt;- Notice both are accessible</span>
        c.Nationality()
    }
</pre></div><p><strong>Output</strong></p><blockquote><p>Hello, my name is Steve and I&rsquo;m from America<br>Hi, my name is Steve<br>Steve is a citizen of America</p></blockquote><ol><li>真正的多态，派生对象就是父对象<br>如果匿名对象能实现多态，则外层对象应该等同于嵌入的对象，而实际上并非如此，它们仍然是不同的存在。下面的例子印证了这一点：</li></ol><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">package</span> main

    <span style="color:#007020;font-weight:700">type</span> A <span style="color:#007020;font-weight:700">struct</span>{
    }

    <span style="color:#007020;font-weight:700">type</span> B <span style="color:#007020;font-weight:700">struct</span> {
        A  <span style="color:#60a0b0;font-style:italic">//B is-a A</span>
    }

    <span style="color:#007020;font-weight:700">func</span> save(A) {
        <span style="color:#60a0b0;font-style:italic">//do something</span>
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        b <span style="color:#666">:=</span> B
        save(<span style="color:#666">&amp;</span>b);  <span style="color:#60a0b0;font-style:italic">//OOOPS! b IS NOT A</span>
    }
</pre></div><p><strong>Output:</strong></p><blockquote><p>prog.go:17: cannot use b (type *B) as type A in function argument<br>[process exited with non-zero status]</p></blockquote><h2 id="go中的真正的多态实现">go中的真正的多态实现</h2><blockquote><p>Go interfaces are pretty unique in how they work. This section focuses only on how they pertain to subtyping which will not do them proper justice. See the further reading section at the end of the post to learn more.</p></blockquote><p>正如我们上面提到的，多态是一种is-a的关系。在go语言中，每种类型(type)都是不同的，一种类型不能完全等同于另外一种类型，但它们可以绑定到同一个接口（interface）上。接口能用于函数（方法）的输入输出中，因而可以在类型之间建立起is-a的关系。</p><p>go语言定义一个接口并不是使用using关键字，而是通过在对象上定义方法来实现。在<a href="http://golang.org/doc/effective_go.html#interfaces_and_types">Effective Go</a>中指出，这种关系就像“如果某个东西能做这件事，那么就把它应用到这里”（不管黑猫白猫，只要能抓到老鼠，我就养这只猫）。这一点很重要，因为这允许一个定义在package外的类型也能实现该接口。</p><p>我们接着上面的例子，增加一个新函数SpeakTo，然后修改main函数，将该方法应用到Citizen和Person上,<a href="http://play.golang.org/p/lvEjaMQ25D">http://play.golang.org/p/lvEjaMQ25D</a>。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">func</span> SpeakTo(p <span style="color:#666">*</span>Person) {
        p.Talk()
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        p <span style="color:#666">:=</span> Person{Name: <span style="color:#4070a0">&quot;Dave&quot;</span>}
        c <span style="color:#666">:=</span> Citizen{Person: Person{Name: <span style="color:#4070a0">&quot;Steve&quot;</span>}, Country: <span style="color:#4070a0">&quot;America&quot;</span>}

        SpeakTo(<span style="color:#666">&amp;</span>p)
        SpeakTo(<span style="color:#666">&amp;</span>c)
    }
</pre></div><p><strong>Output</strong></p><blockquote><p>Running it will result in<br>prog.go:48: cannot use c (type *Citizen) as type *Person in function argument<br>[process exited with non-zero status]</p></blockquote><p>跟预期的结果一样，编译失败。Citizen并不是Person类型，尽管他们拥有同样的属性。然而我们定义一个接口（interface）Human，然后将这个接口作为SpeakTo函数的输入参数，上面的例子就可以正常运行了，<a href="http://play.golang.org/p/ifcP2mAOnf">http://play.golang.org/p/ifcP2mAOnf</a>。</p><div class="highlight" style="background:#f0f0f0"><pre style="line-height:125%"><span></span>    <span style="color:#007020;font-weight:700">type</span> Human <span style="color:#007020;font-weight:700">interface</span> {
        Talk()
    }

    <span style="color:#007020;font-weight:700">func</span> SpeakTo(h Human) {
        h.Talk()
    }

    <span style="color:#007020;font-weight:700">func</span> main() {
        p <span style="color:#666">:=</span> Person{Name: <span style="color:#4070a0">&quot;Dave&quot;</span>}
        c <span style="color:#666">:=</span> Citizen{Person: Person{Name: <span style="color:#4070a0">&quot;Steve&quot;</span>}, Country: <span style="color:#4070a0">&quot;America&quot;</span>}

        SpeakTo(<span style="color:#666">&amp;</span>p)
        SpeakTo(<span style="color:#666">&amp;</span>c)
    }
</pre></div><p><strong>Output</strong></p><blockquote><p>Hi, my name is Dave<br>Hi, my name is Steve</p></blockquote><p>关于go语言中的多态，有如下两点需要注意。<br>1. 可以把匿名域绑定到一个接口，也能绑定到多个接口。接口和匿名域一起使用，可以起到和多态同样的效果。<br>2. go提供了多态的能力。接口的使用能使得实现了该接口的不同对象都能作为函数的输入参数，甚至作为返回结果，但它们仍然保持了它们自己的类型。这点从上面的例子能看出来，我们不能直接在初始化Citizen对象的时候设置Name值，因为Name不是Citizen的属性，而是Person的属性，因而不能再初始化Citizen的时候设置Name值。</p><h2 id="go-一个没有object和inheritance的面向对象的语言">go，一个没有object和inheritance的面向对象的语言</h2><p>如上所述，面向对象的基本概念在go中被很好的实现了，虽然术语上存在差别。go把struct作为数据和逻辑的结合。通过组合(composition)，has-a关系来最小化代码重用，并且避免了继承的缺陷。go使用接口(interface)来建立类型（type）之间的is-a关系。</p><p>欢迎进入无对象的OO编程模型世界！</p><h2 id="讨论">讨论</h2><p>Join the discussion on <a href="https://news.ycombinator.com/item?id=7868485">hacker news</a> and <a href="http://www.reddit.com/r/golang/comments/27p2bc/is_go_an_object_oriented_language_spf13com/">Reddit - Golang</a></p><h2 id="深入阅读">深入阅读</h2><p><a href="http://nathany.com/good/">http://nathany.com/good/</a><br><a href="http://www.artima.com/lejava/articles/designprinciples.html">http://www.artima.com/lejava/articles/designprinciples.html</a><br><a href="http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html">http://www.goinggo.net/2014/05/methods-interfaces-and-embedded-types.html</a></p></div><aside id="meta"><meta itemprop="wordCount" content="707"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/fan-yi-goshi-mian-xiang-dui-xiang-yu-yan-ma-.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/%E7%BF%BB%E8%AF%91.html" rel="tag">翻译</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/leetcode-find-minimum-in-rotated-sorted-array-ii.html">[leetcode]FindMinimuminRotatedSortedArrayII</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/shi-yong--etcd-he--haproxy-zuo--docker-fu-wu-fa-xian.html">使用Etcd和Haproxy做Docker服务发现</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sourceid="6ef4ae1dea70461bc94fb4e5c9323229"></div><div id="SOHUCS" sid="6ef4ae1dea70461bc94fb4e5c9323229"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，一名全栈开发工程师，#热爱编程、#工具控、#爱读书、#宅男</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="极客虞双齐">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ffan-yi-goshi-mian-xiang-dui-xiang-yu-yan-ma-.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ffan-yi-goshi-mian-xiang-dui-xiang-yu-yan-ma-.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-爱分享的极客。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>