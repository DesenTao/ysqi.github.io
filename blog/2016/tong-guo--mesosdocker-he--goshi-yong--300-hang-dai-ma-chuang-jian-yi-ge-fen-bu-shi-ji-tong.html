<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>通过Mesos、Docker和Go使用300行代码创建一个分布式系统 |极客虞双齐</title><meta name="description" content="【摘要】虽然 Docker 和 Mesos 已成为不折不扣的 Buzzwords ，但是对于大部分人"><meta name="keywords" content="golang, mesos, docker, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="极客虞双齐"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/tong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html"><meta property="og:title" content="通过Mesos、Docker和Go使用300行代码创建一个分布式系统"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:23"><meta property="article:modified_time" content="2016-12-31 11:34:23"><meta property="article:tag" content="golang"><meta property="article:tag" content="mesos"><meta property="article:tag" content="docker"><meta name="og:description" content="【摘要】虽然 Docker 和 Mesos 已成为不折不扣的 Buzzwords ，但是对于大部分人"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/tong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html">通过Mesos、Docker和Go使用300行代码创建一个分布式系统</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000003048009" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p><strong>【摘要】虽然 Docker 和 Mesos 已成为不折不扣的 Buzzwords ，但是对于大部分人来说它们仍然是陌生的，下面我们就一起领略 Mesos 、Docker 和 Go 配合带来的强大破坏力，如何通过 300 行代码打造一个比特币开采系统。</strong></p><p>时下，对于大部分 IT 玩家来说， <a href="http://news.oneapm.com/tag/docker/">Docker</a> 和 Mesos 都是熟悉和陌生的：熟悉在于这两个词无疑已成为大家讨论的焦点，而陌生在于这两个技术并未在生产环境得到广泛使用，因此很多人仍然不知道它们究竟有什么优势，或者能干什么。近日， John Walter 在 Dzone 上撰文 <a href="https://dzone.com/articles/creating-a-distributed-system-in-300-lines-with-me">Creating a Distributed System in 300 Lines With Mesos, Docker, and Go</a>，讲述了 Mesos、Docker 和 Go 配合带来的强大破坏力，本文由 <a href="http://www.oneapm.com/index.html?utm_source=Common&amp;utm_medium=Articles&amp;utm_campaign=TechnicalArticles&amp;from=matefiseco">OneAPM</a> 工程师编译整理。</p><p>诚然，构建一个分布式系统是很困难的，它需要可扩展性、容错性、高可用性、一致性、可伸缩以及高效。为了达到这些目的，分布式系统需要很多复杂的组件以一种复杂的方式协同工作。例如，Apache Hadoop 在大型集群上并行处理 TB 级别的数据集时，需要依赖有着高容错的文件系统（ HDFS ）来达到高吞吐量。</p><p>在之前，每一个新的分布式系统，例如 Hadoop 和 Cassandra ，都需要构建自己的底层架构，包括消息处理、存储、网络、容错性和可伸缩性。庆幸的是，像 Apache Mesos 这样的系统，通过给分布式系统的关键构建模块提供类似操作系统的管理服务，简化了构建和管理分布式系统的任务。Mesos 抽离了 CPU 、存储和其它计算资源，因此开发者开发分布式应用程序时能够将整个数据中心集群当做一台巨型机对待。</p><p>构建在 Mesos 上的应用程序被称为框架，它们能解决很多问题： Apache Spark，一种流行的集群式数据分析工具；Chronos ，一个类似 cron 的具有容错性的分布式 scheduler ，这是两个构建在 Mesos 上的框架的例子。构建框架可以使用多种语言，包括 C++，Go，Python，Java，Haskell 和 Scala。</p><p>在分布式系统用例上，比特币开采就是一个很好的例子。比特币将为生成 acceptable hash 的挑战转为验证一块事务的可靠性。可能需要几十年，单台笔记本电脑挖一块可能需要花费超过 150 年。结果是，有许多的“采矿池”允许采矿者将他们的计算资源联合起来以加快挖矿速度。Mesosphere 的一个实习生， Derek ，写了一个比特币开采框架（<a href="https://github.com/derekchiang/Mesos-Bitcoin-Miner">https://github.com/derekchiang/Mesos-Bitcoin-Miner</a>），利用集群资源的优势来做同样的事情。在接下来的内容中，会以他的代码为例。</p><p>1 个 Mesos 框架有 1 个 scheduler 和 1 个 executor 组成。scheduler 和 Mesos master 通信并决定运行什么任务，而 executor 运行在 slaves 上面，执行实际任务。大多数的框架实现了自己的 scheduler，并使用 1 个由 Mesos 提供的标准 executors 。当然，框架也可以自己定制 executor 。在这个例子中即会编写定制的 scheduler，并使用标准命令执行器（ executor ）运行包含我们比特币服务的 Docker 镜像。</p><p>对这里的 scheduler 来说，需要运行的有两种任务—— one miner server task and multiple miner worker tasks。 server 会和一个比特币采矿池通信，并给每个 worker 分配 blocks 。Worker 会努力工作，即开采比特币。</p><p>任务实际上被封装在 executor 框架中，因此任务运行意味着告诉 Mesos master 在其中一个 slave 上面启动一个 executor 。由于这里使用的是标准命令执行器（executor），因此可以指定任务是二进制可执行文件、bash 脚本或者其他命令。由于 Mesos 支持 Docker，因此在本例中将使用可执行的 Docker 镜像。Docker 是这样一种技术，它允许你将应用程序和它运行时需要的依赖一起打包。</p><p>为了在 Mesos 中使用 Docker 镜像，这里需要在 Docker registry 中注册它们的名称：</p><pre><code>const (
    MinerServerDockerImage = &quot;derekchiang/p2pool&quot;
    MinerDaemonDockerImage = &quot;derekchiang/cpuminer&quot;
)
</code></pre><p>然后定义一个常量，指定每个任务所需资源：</p><pre><code>const (
    MemPerDaemonTask = 128  // mining shouldn't be    memory-intensive
    MemPerServerTask = 256
    CPUPerServerTask = 1    // a miner server does not use much     CPU
)
</code></pre><p>现在定义一个真正的 scheduler ，对其跟踪，并确保其正确运行需要的状态：</p><pre><code>type MinerScheduler struct { 
    // bitcoind RPC credentials
    bitcoindAddr string
    rpcUser      string
    rpcPass      string
    // mutable state
    minerServerRunning  bool
    minerServerHostname string 
    minerServerPort     int    // the port that miner daemons 
                               // connect to
    // unique task ids
    tasksLaunched        int
    currentDaemonTaskIDs []*mesos.TaskID
}
</code></pre><p>这个 scheduler 必须实现下面的接口：</p><pre><code>type Scheduler interface {
    Registered(SchedulerDriver, *mesos.FrameworkID,     *mesos.MasterInfo)
    Reregistered(SchedulerDriver, *mesos.MasterInfo)
    Disconnected(SchedulerDriver)
    ResourceOffers(SchedulerDriver, []*mesos.Offer)
    OfferRescinded(SchedulerDriver, *mesos.OfferID)
    StatusUpdate(SchedulerDriver, *mesos.TaskStatus)
    FrameworkMessage(SchedulerDriver, *mesos.ExecutorID, 
                     *mesos.SlaveID, string)
    SlaveLost(SchedulerDriver, *mesos.SlaveID)
    ExecutorLost(SchedulerDriver, *mesos.ExecutorID,   *mesos.SlaveID, 
                 int)
    Error(SchedulerDriver, string)
}
</code></pre><p>现在一起看一个回调函数：</p><pre><code>func (s *MinerScheduler) Registered(_ sched.SchedulerDriver, 
      frameworkId *mesos.FrameworkID, masterInfo *mesos.MasterInfo) {
    log.Infoln(&quot;Framework registered with Master &quot;, masterInfo)
}
func (s *MinerScheduler) Reregistered(_ sched.SchedulerDriver, 
      masterInfo *mesos.MasterInfo) {
    log.Infoln(&quot;Framework Re-Registered with Master &quot;,  masterInfo)
}
func (s *MinerScheduler) Disconnected(sched.SchedulerDriver) {
    log.Infoln(&quot;Framework disconnected with Master&quot;)
}
</code></pre><p><strong>Registered</strong> 在 scheduler 成功向 Mesos master 注册之后被调用。</p><p><strong>Reregistered</strong> 在 scheduler 与 Mesos master 断开连接并且再次注册时被调用，例如，在 master 重启的时候。</p><p><strong>Disconnected</strong> 在 scheduler 与 Mesos master 断开连接时被调用。这个在 master 挂了的时候会发生。</p><p>目前为止，这里仅仅在回调函数中打印了日志信息，因为对于一个像这样的简单框架，大多数回调函数可以空在那里。然而，下一个回调函数就是每一个框架的核心，必须要认真的编写。</p><p><strong>ResourceOffers</strong> 在 scheduler 从 master 那里得到一个 offer 的时候被调用。每一个 offer 包含一个集群上可以给框架使用的资源列表。资源通常包括 CPU 、内存、端口和磁盘。一个框架可以使用它提供的一些资源、所有资源或者一点资源都不给用。</p><p>针对每一个 offer ，现在期望聚集所有的提供的资源并决定是否需要发布一个新的 server 任务或者一个新的 worker 任务。这里可以向每个 offer 发送尽可能多的任务以测试最大容量，但是由于开采比特币是依赖 CPU 的，所以这里每个 offer 运行一个开采者任务并使用所有可用的 CPU 资源。</p><pre><code>for i, offer := range offers {
    // … Gather resource being offered and do setup
    if !s.minerServerRunning &amp;&amp; mems &gt;= MemPerServerTask &amp;&amp;
            cpus &gt;= CPUPerServerTask &amp;&amp; ports &gt;= 2 {
        // … Launch a server task since no server is running and     we 
        // have resources to launch it.
    } else if s.minerServerRunning &amp;&amp; mems &gt;= MemPerDaemonTask {
        // … Launch a miner since a server is running and we have     mem 
        // to launch one.
    }
}
</code></pre><p>针对每个任务都需要创建一个对应的 TaskInfo message ，它包含了运行这个任务需要的信息。</p><pre><code>s.tasksLaunched++
taskID = &amp;mesos.TaskID {
    Value: proto.String(&quot;miner-server-&quot; + 
                        strconv.Itoa(s.tasksLaunched)),
}
</code></pre><p>Task IDs 由框架决定，并且每个框架必须是唯一的。</p><pre><code>containerType := mesos.ContainerInfo_DOCKER
task = &amp;mesos.TaskInfo {
    Name: proto.String(&quot;task-&quot; + taskID.GetValue()),
    TaskId: taskID,
    SlaveId: offer.SlaveId,
    Container: &amp;mesos.ContainerInfo {
        Type: &amp;containerType,
        Docker: &amp;mesos.ContainerInfo_DockerInfo {
            Image: proto.String(MinerServerDockerImage),
        },
    },
    Command: &amp;mesos.CommandInfo {
        Shell: proto.Bool(false),
        Arguments: []string {
            // these arguments will be passed to run_p2pool.py
            &quot;--bitcoind-address&quot;, s.bitcoindAddr,
            &quot;--p2pool-port&quot;, strconv.Itoa(int(p2poolPort)),
            &quot;-w&quot;, strconv.Itoa(int(workerPort)),
            s.rpcUser, s.rpcPass,
        },
    },
    Resources: []*mesos.Resource {
        util.NewScalarResource(&quot;cpus&quot;, CPUPerServerTask),
        util.NewScalarResource(&quot;mem&quot;, MemPerServerTask),
    },
}
</code></pre><p>TaskInfo message 指定了一些关于任务的重要元数据信息，它允许 Mesos 节点运行 Docker 容器，特别会指定 name、task ID、container information 以及一些需要给容器传递的参数。这里也会指定任务需要的资源。</p><p>现在 TaskInfo 已经被构建好，因此任务可以这样运行：</p><pre><code>driver.LaunchTasks([]*mesos.OfferID{offer.Id}, tasks,     &amp;mesos.Filters{RefuseSeconds: proto.Float64(1)})
</code></pre><p>在框架中，需要处理的最后一件事情是当开采者 server 关闭时会发生什么。这里可以利用 StatusUpdate 函数来处理。</p><p>在一个任务的生命周期中，针对不同的阶段有不同类型的状态更新。对这个框架来说，想要确保的是如果开采者 server 由于某种原因失败，系统会 Kill 所有开采者 worker 以避免浪费资源。这里是相关的代码：</p><pre><code>if strings.Contains(status.GetTaskId().GetValue(), &quot;server&quot;) &amp;&amp;
    (status.GetState() == mesos.TaskState_TASK_LOST ||
        status.GetState() == mesos.TaskState_TASK_KILLED ||
        status.GetState() == mesos.TaskState_TASK_FINISHED ||
        status.GetState() == mesos.TaskState_TASK_ERROR ||
        status.GetState() == mesos.TaskState_TASK_FAILED) {
    s.minerServerRunning = false
    // kill all tasks
    for _, taskID := range s.currentDaemonTaskIDs {
        _, err := driver.KillTask(taskID)
        if err != nil {
            log.Errorf(&quot;Failed to kill task %s&quot;, taskID)
        }
    }
    s.currentDaemonTaskIDs = make([]*mesos.TaskID, 0)
}
</code></pre><p>万事大吉！通过努力，这里在 Apache Mesos 上建立一个正常工作的分布式比特币开采框架，它只用了大约 300 行 GO 代码。这证明了使用 Mesos 框架的 API 编写分布式系统是多么快速和简单。</p><p>原文链接：<a href="https://dzone.com/articles/creating-a-distributed-system-in-300-lines-with-me">Creating a Distributed System in 300 Lines With Mesos, Docker, and Go</a></p><p><strong>本文由<a href="http://www.oneapm.com/?hmsr=media&amp;hmmd=&amp;hmpl=&amp;hmkw=&amp;hmci=">OneAPM</a>工程师编译 ，想阅读更多技术文章，请访问<a href="http://code.oneapm.com/?hmsr=media&amp;hmmd=&amp;hmpl=&amp;hmkw=&amp;hmci=">OneAPM官方技术博客</a>。</strong></p></div><aside id="meta"><meta itemprop="wordCount" content="646"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/tong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/docker.html" rel="tag">docker</a> <a href="/tags/golang.html" rel="tag">golang</a> <a href="/tags/mesos.html" rel="tag">mesos</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/guan-yu-golangzhong-database_sqlbao-de-xue-xi-bi-ji.html">关于Golang中database_sql包的学习笔记</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/shi-yong-goyu-yan-kuang-jia-jin-hang-webkai-fa-bi-ji.html">使用Go语言框架进行web开发笔记</a></li></ul></div><aside id="comments"><div><div id="SOHUCS" sid="73ecdc5a7cbccf954607638aefcd7d69"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，一名全栈开发工程师，#热爱编程、#工具控、#爱读书、#宅男</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="极客虞双齐">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ftong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2ftong-guo--mesosdocker-he--goshi-yong--300-hang-dai-ma-chuang-jian-yi-ge-fen-bu-shi-ji-tong.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-爱分享的极客。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>