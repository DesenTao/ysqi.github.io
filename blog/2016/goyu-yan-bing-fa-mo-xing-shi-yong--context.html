<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语言并发模型:使用context |虞双齐Golang开发与SRE运维</title><meta name="description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。"><meta name="keywords" content="context, golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html"><meta property="og:title" content="Go语言并发模型:使用context"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:33:10"><meta property="article:modified_time" content="2016-12-31 11:33:10"><meta property="article:tag" content="context"><meta property="article:tag" content="golang"><meta name="og:description" content="简介 在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html">Go语言并发模型:使用context</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000006744213" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="简介">简介</h2><p>在 Go http包的Server中，每一个请求在都有一个对应的 goroutine 去处理。请求处理函数通常会启动额外的 goroutine 用来访问后端服务，比如数据库和RPC服务。用来处理一个请求的 goroutine 通常需要访问一些与请求特定的数据，比如终端用户的身份认证信息、验证相关的token、请求的截止时间。 当一个请求被取消或超时时，所有用来处理该请求的 goroutine 都应该迅速退出，然后系统才能释放这些 goroutine 占用的资源。</p><p>在Google 内部，我们开发了 <code>Context</code> 包，专门用来简化 对于处理单个请求的多个 goroutine 之间与请求域的数据、取消信号、截止时间等相关操作，这些操作可能涉及多个 API 调用。你可以通过 <code>go get golang.org/x/net/context</code> 命令获取这个包。本文要讲的就是如果使用这个包，同时也会提供一个完整的例子。</p><h2 id="阅读建议">阅读建议</h2><p>本文内容涉及到了 done channel，如果你不了解这个概念，那么请先阅读 <a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a>。</p><p>由于访问 <code>golang.org/x/net/context</code> 需要梯子，你可以访问它在 github 上的 <a href="https://github.com/golang/net">mirror</a>。<br>如果要下载本文中的代码，可以查看文章末尾的“相关链接”环节。</p><h2 id="package-context">package context</h2><p>context 包的核心是 struct Context，声明如下：</p><pre><code>// A Context carries a deadline, cancelation signal, and request-scoped values
// across API boundaries. Its methods are safe for simultaneous use by multiple
// goroutines.
type Context interface {
    // Done returns a channel that is closed when this `Context` is canceled
    // or times out.
    Done() &lt;-chan struct{}

    // Err indicates why this Context was canceled, after the Done channel
    // is closed.
    Err() error

    // Deadline returns the time when this Context will be canceled, if any.
    Deadline() (deadline time.Time, ok bool)

    // Value returns the value associated with key or nil if none.
    Value(key interface{}) interface{}
}
</code></pre><p>注意: 这里我们对描述进行了简化，更详细的描述查看 <a href="http://godoc.org/golang.org/x/net/context">godoc:context</a></p><p><code>Done</code> 方法返回一个 channel，这个 channel 对于以 <code>Context</code> 方式运行的函数而言，是一个取消信号。当这个 channel 关闭时，上面提到的这些函数应该终止手头的工作并立即返回。 之后，<code>Err</code> 方法会返回一个错误，告知为什么 <code>Context</code> 被取消。关于 <code>Done</code> channel 的更多细节查看上一篇文章 <a href="https://segmentfault.com/a/1190000006261218">&ldquo;Go语言并发模型：像Unix Pipe那样使用channel&rdquo;</a>。</p><p>一个 <code>Context</code> 不能拥有 <code>Cancel</code> 方法，同时我们也只能 <code>Done</code> channel 接收数据。背后的原因是一致的：接收取消信号的函数和发送信号的函数通常不是一个。 一个典型的场景是：父操作为子操作操作启动 goroutine，子操作也就不能取消父操作。 作为一个折中，<code>WithCancel</code> 函数 (后面会细说) 提供了一种取消新的 <code>Context</code> 的方法。</p><p><code>Context</code> 对象是线程安全的，你可以把一个 <code>Context</code> 对象传递给任意个数的 gorotuine，<br>对它执行 取消 操作时，所有 goroutine 都会接收到取消信号。</p><p><code>Deadline</code> 方法允许函数确定它们是否应该开始工作。如果剩下的时间太少，也许这些函数就不值得启动。代码中，我们也可以使用 <code>Deadline</code> 对象为 I/O 操作设置截止时间。</p><p><code>Value</code> 方法允许 <code>Context</code> 对象携带request作用域的数据，该数据必须是线程安全的。</p><h2 id="继承-context">继承 context</h2><p>context 包提供了一些函数，协助用户从现有的 <code>Context</code> 对象创建新的 <code>Context</code> 对象。<br>这些 <code>Context</code> 对象形成一棵树：当一个 <code>Context</code> 对象被取消时，继承自它的所有 <code>Context</code> 都会被取消。</p><p><code>Background</code> 是所有 <code>Context</code> 对象树的根，它不能被取消。它的声明如下：</p><pre><code>// Background returns an empty Context. It is never canceled, has no deadline,
// and has no values. Background is typically used in main, init, and tests,
// and as the top-level `Context` for incoming requests.
func Background() Context
</code></pre><p><code>WithCancel</code> 和 <code>WithTimeout</code> 函数 会返回继承的 <code>Context</code> 对象， 这些对象可以比它们的父 <code>Context</code> 更早地取消。</p><p>当请求处理函数返回时，与该请求关联的 <code>Context</code> 会被取消。 当使用多个副本发送请求时，可以使用 <code>WithCancel</code>取消多余的请求。 <code>WithTimeout</code> 在设置对后端服务器请求截止时间时非常有用。 下面是这三个函数的声明：</p><pre><code>// WithCancel returns a copy of parent whose Done channel is closed as soon as
// parent.Done is closed or cancel is called.
func WithCancel(parent Context) (ctx Context, cancel CancelFunc)

// A CancelFunc cancels a Context.
type CancelFunc func()

// WithTimeout returns a copy of parent whose Done channel is closed as soon as
// parent.Done is closed, cancel is called, or timeout elapses. The new
// Context's Deadline is the sooner of now+timeout and the parent's deadline, if
// any. If the timer is still running, the cancel function releases its
// resources.
func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)
</code></pre><p><code>WithValue</code> 函数能够将请求作用域的数据与 <code>Context</code> 对象建立关系。声明如下：</p><pre><code>// WithValue returns a copy of parent whose Value method returns val for key.
func WithValue(parent Context, key interface{}, val interface{}) Context
</code></pre><p>当然，想要知道 <code>Context</code> 包是如何工作的，最好的方法是看一个栗子。</p><h2 id="一个栗子-google-web-search">一个栗子：Google Web Search</h2><p>我们的例子是一个 HTTP 服务，它能够将类似于 <code>/search?q=golang&amp;timeout=1s</code> 的请求 转发给<br><a href="https://developers.google.com/web-search/docs/">Google Web Search API</a>，然后渲染返回的结果。<code>timeout</code> 参数用来告诉 server 时间到时取消请求。</p><p>这个例子的代码存放在三个包里：</p><ol><li><p><a href="https://blog.golang.org/context/server/server.go">server</a>：它提供 main 函数和 处理 <code>/search</code> 的 http handler</p></li><li><p><a href="https://blog.golang.org/context/userip/userip.go">userip</a>：它能够从 请求解析用户的IP，并将请求绑定到一个 <code>Context</code> 对象。</p></li><li><p><a href="https://blog.golang.org/context/google/google.go">google</a>：它包含了 Search 函数，用来向 Google 发送请求。</p></li></ol><h3 id="深入-server-程序">深入 server 程序</h3><p><a href="https://blog.golang.org/context/server/server.go">server</a> 程序处理类似于 <code>/search?q=golang</code> 的请求，返回 Google API 的搜索结果。它将 <code>handleSearch</code> 函数注册到 <code>/search</code> 路由。处理函数创建一个 <code>Context</code> ctx，并对其进行初始化，以保证 <code>Context</code> 取消时，处理函数返回。如果请求的 URL 参数中包含 <code>timeout</code>，那么当 <code>timeout</code> 到期时， <code>Context</code> 会被自动取消。<br>handleSearch 的代码如下：</p><pre><code>func handleSearch(w http.ResponseWriter, req *http.Request) {
    // ctx is the `Context` for this handler. Calling cancel closes the
    // ctx.Done channel, which is the cancellation signal for requests
    // started by this handler.
    var (
        ctx    context.Context
        cancel context.CancelFunc
    )
    timeout, err := time.ParseDuration(req.FormValue(&quot;timeout&quot;))
    if err == nil {
        // The request has a timeout, so create a `Context` that is
        // canceled automatically when the timeout expires.
        ctx, cancel = context.WithTimeout(context.Background(), timeout)
    } else {
        ctx, cancel = context.WithCancel(context.Background())
    }
    defer cancel() // Cancel ctx as soon as handleSearch returns.
</code></pre><p>处理函数 (handleSearch) 将query 参数从请求中解析出来，然后通过 userip 包将client IP解析出来。这里 Client IP 在后端发送请求时要用到，所以 handleSearch 函数将它 attach 到 <code>Context</code> 对象 ctx 上。代码如下：</p><pre><code>// Check the search query.
query := req.FormValue(&quot;q&quot;)
if query == &quot;&quot; {
    http.Error(w, &quot;no query&quot;, http.StatusBadRequest)
    return
}

// Store the user IP in ctx for use by code in other packages.
userIP, err := userip.FromRequest(req)
if err != nil {
    http.Error(w, err.Error(), http.StatusBadRequest)
    return
}
ctx = userip.NewContext(ctx, userIP)
</code></pre><p>处理函数带着 <code>Context</code> 对象 <code>ctx</code> 和 <code>query</code> 调用 <code>google.Search</code>，代码如下：</p><pre><code>// Run the Google search and print the results.
start := time.Now()
results, err := google.Search(ctx, query)
elapsed := time.Since(start)
</code></pre><p>如果搜索成功，处理函数会渲染搜索结果，代码如下：</p><pre><code>if err := resultsTemplate.Execute(w, struct {
    Results          google.Results
    Timeout, Elapsed time.Duration
}{
    Results: results,
    Timeout: timeout,
    Elapsed: elapsed,
}); err != nil {
    log.Print(err)
    return
}
</code></pre><h3 id="深入-userip-包">深入 userip 包</h3><p><a href="https://blog.golang.org/context/userip/userip.go">userip</a> 包提供了两个功能：</p><ol><li><p>从请求解析出Client IP；</p></li><li><p>将 Client IP 关联到一个 <code>Context</code> 对象。</p></li></ol><p>一个 <code>Context</code> 对象提供一个 key-value 映射，key 和 value的类型都是 interface{}，但是 key 必须满足等价性（可以比较），value 必须是线程安全的。类似于 <code>userip</code> 的包隐藏了映射的细节，提供的是对特定 <code>Context</code> 类型值得强类型访问。</p><p>为了避免 key 冲突，<code>userip</code> 定义了一个非输出类型 <code>key</code>，并使用该类型的值作为 <code>Context</code> 的key。代码如下：</p><pre><code>// 为了避免与其他包中的 `Context` key 冲突
// 这里不输出 key 类型 (首字母小写)
type key int

// userIPKey 是 user IP 的 `Context` key
// 它的值是随意写的。如果这个包中定义了其他
// `Context` key，这些 key 必须不同
const userIPKey key = 0
</code></pre><p>函数 <code>FromRequest</code> 用来从一个 http.Request 对象中解析出 userIP：</p><pre><code>func FromRequest(req *http.Request) (net.IP, error) {
    ip, _, err := net.SplitHostPort(req.RemoteAddr)
    if err != nil {
        return nil, fmt.Errorf(&quot;userip: %q is not IP:port&quot;, req.RemoteAddr)
    }
</code></pre><p>函数 <code>NewContext</code> 返回一个新的 <code>Context</code> 对象，它携带者 userIP：</p><pre><code>func NewContext(ctx context.Context, userIP net.IP) context.Context {
    return context.WithValue(ctx, userIPKey, userIP)
}
</code></pre><p>函数 <code>FromContext</code> 从一个 <code>Context</code> 对象中解析 userIP：</p><pre><code>func FromContext(ctx context.Context) (net.IP, bool) {
    // ctx.Value returns nil if ctx has no value for the key;
    // the net.IP type assertion returns ok=false for nil.
    userIP, ok := ctx.Value(userIPKey).(net.IP)
    return userIP, ok
}
</code></pre><h3 id="深入-google-包">深入 google 包</h3><p>函数 <code>google.Search</code> 想 Google Web Search API 发送一个 HTTP 请求，并解析返回的 JSON 数据。该函数接收一个 <code>Context</code> 对象 ctx 作为第一参数，在请求还没有返回时，一旦 <code>ctx.Done</code> 关闭，该函数也会立即返回。</p><p>Google Web Search API 请求包含 query 关键字和 user IP 两个参数。具体实现如下：</p><pre><code>func Search(ctx context.Context, query string) (Results, error) {
    // Prepare the Google Search API request.
    req, err := http.NewRequest(&quot;GET&quot;, &quot;https://ajax.googleapis.com/ajax/services/search/web?v=1.0&quot;, nil)
    if err != nil {
        return nil, err
    }
    q := req.URL.Query()
    q.Set(&quot;q&quot;, query)

    // If ctx is carrying the user IP address, forward it to the server.
    // Google APIs use the user IP to distinguish server-initiated requests
    // from end-user requests.
    if userIP, ok := userip.FromContext(ctx); ok {
        q.Set(&quot;userip&quot;, userIP.String())
    }
    req.URL.RawQuery = q.Encode()
</code></pre><p>函数 <code>Search</code> 使用一个辅助函数 <code>httpDo</code> 发送 HTTP 请求，并在 <code>ctx.Done</code> 关闭时取消请求 (如果还在处理请求或返回)。函数 <code>Search</code> 传递给 <code>httpDo</code> 一个闭包处理 HTTP 结果。下面是具体实现：</p><pre><code>var results Results
err = httpDo(ctx, req, func(resp *http.Response, err error) error {
    if err != nil {
        return err
    }
    defer resp.Body.Close()

    // Parse the JSON search result.
    // https://developers.google.com/web-search/docs/#fonje
    var data struct {
        ResponseData struct {
            Results []struct {
                TitleNoFormatting string
                URL               string
            }
        }
    }
    if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {
        return err
    }
    for _, res := range data.ResponseData.Results {
        results = append(results, Result{Title: res.TitleNoFormatting, URL: res.URL})
    }
    return nil
})
// httpDo waits for the closure we provided to return, so it's safe to
// read results here.
return results, err
</code></pre><p>函数 <code>httpDo</code> 在一个新的 goroutine 中发送 HTTP 请求和处理结果。如果 <code>ctx.Done</code> 已经关闭，而处理请求的 goroutine 还存在，那么取消请求。下面是具体实现：</p><pre><code>func httpDo(ctx context.Context, req *http.Request, f func(*http.Response, error) error) error {
    // Run the HTTP request in a goroutine and pass the response to f.
    tr := &amp;http.Transport{}
    client := &amp;http.Client{Transport: tr}
    c := make(chan error, 1)
    go func() { c &lt;- f(client.Do(req)) }()
    select {
    case &lt;-ctx.Done():
        tr.CancelRequest(req)
        &lt;-c // Wait for f to return.
        return ctx.Err()
    case err := &lt;-c:
        return err
    }
}
</code></pre><h2 id="在自己的代码中使用-context">在自己的代码中使用 <code>Context</code></h2><p>许多服务器框架都提供了管理请求作用域数据的包和类型。我们可以定义一个 <code>Context</code> 接口的实现，<br>将已有代码和期望 <code>Context</code> 参数的代码粘合起来。</p><p>举个栗子，Gorilla 框架的 <a href="http://www.gorillatoolkit.org/pkg/context">github.com/gorilla/context</a> 包允许处理函数 (handlers) 将数据和请求结合起来，他通过 HTTP 请求 到 key-value对 的映射来实现。在 <a href="https://blog.golang.org/context/gorilla/gorilla.go">gorilla.go</a> 中，我们提供了一个 <code>Context</code> 的具体实现，这个实现的 Value 方法返回的值已经与 gorilla 包中特定的 HTTP 请求关联起来。</p><p>还有一些包实现了类似于 <code>Context</code> 的取消机制。比如 <a href="http://godoc.org/gopkg.in/tomb.v2">Tomb</a> 中有一个 Kill 方法，该方法通过关闭 名为<code>Dying</code> 的 channel 发送取消信号。<code>Tomb</code> 也提供了等待 goroutine 退出的方法，类似于 <code>sync.WaitGroup</code>。在 <a href="https://blog.golang.org/context/tomb/tomb.go">tomb.go</a> 中，我们提供了一个 <code>Context</code> 的实现，当它的父 <code>Context</code> 被取消<br>或 一个 <code>Tomb</code> 对象被 kill 时，该 <code>Context</code> 对象也会被取消。</p><h2 id="结论">结论</h2><p>在 Google， 我们要求 Go 程序员把 <code>Context</code> 作为第一个参数传递给 入口请求和出口请求链路上的每一个函数。这种机制一方面保证了多个团队开发的 Go 项目能够良好地协作，另一方面它是一种简单的超时和取消机制，保证了临界区数据 (比如安全凭证) 在不同的 Go 项目中顺利传递。</p><p>如果你要在 <code>Context</code> 之上构建服务器框架，需要一个自己的 <code>Context</code> 实现，在框架与期望 <code>Context</code> 参数的代码之间建立一座桥梁。<br>当然，Client 库也需要接收一个 <code>Context</code> 对象。在请求作用域数据与取消之间建立了通用的接口以后，开发者使用 Context<br>分享代码、创建可扩展的服务都会非常方便。</p><p>原作者：Sameer Ajmani 翻译：Oscar</p><p>下期预告：Go语言并发模型：使用 select (<a href="https://talks.golang.org/2012/concurrency.slide#31">原文链接</a>)。</p><h2 id="相关链接">相关链接</h2><ol><li><p><a href="https://blog.golang.org/context">原文链接</a></p></li><li><p><a href="https://blog.golang.org/context/">代码位置</a></p></li><li><p><a href="https://github.com/oscarzhao/golang/tree/master/go_blog">代码位置(mirror)</a></p></li><li><p><a href="https://github.com/golang/net">mirror of package net</a></p></li><li><p><a href="https://developers.google.com/web-search/docs/">Google Web Search API</a></p></li></ol><hr><p>扫码关注微信公众号“深入Go语言”</p></div><aside id="meta"><meta itemprop="wordCount" content="1249"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/context.html" rel="tag">context</a> <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/golang-xian-su-qi.html">Golang限速器</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/golangxue-xi-bi-ji----biao-zhun-ku-ampquotnet_httpampquotde-jian-xi-ji-zi-zhi-jian-chan-lu-you-kuang-j.html">Golang学习笔记-标准库&amp;amp;quot;net_http&amp;amp;quot;的简析及自制简单路由框架</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="10c509d15fa0a6a6ca2aeda1b1eb108a" data-title="Go语言并发模型:使用context" data-url="https://yushuangqi.com/blog/2016/goyu-yan-bing-fa-mo-xing-shi-yong--context.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-bing-fa-mo-xing-shi-yong--context.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-bing-fa-mo-xing-shi-yong--context.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-#Golang开发 #SRE运维。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>