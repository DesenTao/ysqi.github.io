<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Go语言单元测试 |虞双齐Golang开发</title><meta name="description" content="简介 Go 语言在设计之初就考虑到了代码的可测试性。一方面 Go 本身提供了 testing 库，使"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/goyu-yan-chan-yuan-ce-shi.html"><meta property="og:title" content="Go语言单元测试"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:32:38"><meta property="article:modified_time" content="2016-12-31 11:32:38"><meta property="article:tag" content="golang"><meta name="og:description" content="简介 Go 语言在设计之初就考虑到了代码的可测试性。一方面 Go 本身提供了 testing 库，使"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/goyu-yan-chan-yuan-ce-shi.html">Go语言单元测试</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000007951944" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="简介">简介</h2><p>Go 语言在设计之初就考虑到了代码的可测试性。一方面 Go 本身提供了 <a href="https://golang.org/pkg/testing/">testing</a> 库，使用方法很简单;<br>另一方面 go 的 package 提供了很多编译选项，代码和业务逻辑代码很容易解耦，可读性比较强（不妨对比一下C++测试框架）。 本文中，我们讨论的重点是 Go 语言中<br>的单元测试，而且只讨论一些基本的测试方法，包括下面几个方面：</p><ol><li><p>写一个简单的测试用例</p></li><li><p>Table driven test</p></li><li><p>使用辅助测试函数（test helper）</p></li><li><p>临时文件</p></li></ol><p>这里我们只涉及到一些通用的测试方法。关于 HTTP server/client 测试，这里不做深入讨论。</p><h2 id="阅读建议">阅读建议</h2><p><strong>Testing shows the presence, not the absence of bugs</strong> &ndash; <a href="https://en.wikiquote.org/wiki/Edsger_W._Dijkstra">Edsger W. Dijkstra</a></p><p>在阅读本文之前，建议您对 Go 语言的 package 有一定的了解，并在实际项目中使用过，下面是一些基本的要求：</p><ol><li><p>了解如何在项目中 import 一个外部的package</p></li><li><p>了解如何将自己的项目按照功能模块划分 package</p></li><li><p>了解 struct、struct字段、函数、变量名字首字母大小写的含义（非必需）</p></li><li><p>了解一些 Go语言的编译选项，比如 +build !windows（非必需）</p></li></ol><p>如果你对 1、2都不太了解，建议阅读一下这篇文章<a href="https://golang.org/doc/code.html,">How to Write Go Code</a>，动手实践一下。</p><h2 id="写一个简单的测试用例">写一个简单的测试用例</h2><p>为了便于理解，我们首先给出一个代码片段（如果你已经使用过go 的单元测试，可以跳过这个环节）：</p><pre><code>// demo/equal.go
package demo

// a function to check if two numbers equals to each other.
func equal(a, b int) bool {
  return a == b
}

// demo/equal_test.go
package demo
import (
  &quot;testing&quot;
)

func TestEqual(t *testing.T) {
  a := 1
  b := 1
  shouldBe := true
  if real := equal(a, b); real == shouldBe {
    t.Errorf(&quot;equal(%d, %d) should be %v, but is:%v\n&quot;, a, b, shouldBe, real)
  }
}
</code></pre><p>上面这个例子中，如果你从来没有使用过单元测试，建议在本地开发环境中运行一次。这里有几点需要注意一下：</p><ol><li><p>这两个文件的父目录必须与包名一致（这里是 demo），且包名必须是在 \$GOPATH 下</p></li><li><p>测试用例的函数命名必须符合 TestXXX 格式，并且参数是 t *testing.T</p></li><li><p>了解一下 t.Errorf 与 t.Fatalf 的行为差异</p></li></ol><h2 id="table-driven-test">Table Driven Test</h2><p>上面的测试用例中，我们一次只能测试一种情况，如果我们希望在一个 TestXXX 函数中进行很多项测试，Table Driven Test 就派上了用场。<br>举个例子，假设我们实现了自己的 <a href="https://golang.org/pkg/math/#Sqrt">Sqrt</a> 函数 mymath.Sqrt，我们需要对其进行测试：</p><p>首先，我们需要考虑一些特殊情况：</p><ol><li><p>Sqrt(+Inf) = +Inf</p></li><li><p>Sqrt(±0) = ±0</p></li><li><p>Sqrt(x &lt; 0) = NaN</p></li><li><p>Sqrt(NaN) = NaN</p></li></ol><p>然后，我们需要考虑一般情况：</p><ol><li><p>Sqrt(1.0) = 1.0</p></li><li><p>Sqrt(4.0) = 2.0</p></li><li><p>&hellip;</p></li></ol><p>注意：在一般情况中，我们对结果进行验证时，需要考虑小数点精确位数的问题。由于文章篇幅限制，这里不做额外的处理。</p><p>有了思路以后，我们可以基于 Table Driven Test 实现测试用例：</p><pre><code>func TestSqrt(t *testing.T) {
  var shouldSuccess = []struct {
    input    float64 // input
    expected float64 // expected result
  }{
    {math.Inf(1), math.Inf(1)}, // positive infinity
    {math.Inf(-1), math.NaN()}, // negative infinity
    {-1.0, math.NaN()},
    {0.0, 0.0},
    {-0.0, -0.0},
    {1.0, 1.0},
    {4.0, 2.0},
  }
  for _, ts := range shouldSuccess {
    if actual := Sqrt(t.input); actual != ts.expected {
      t.Fatalf(&quot;Sqrt(%f) should be %v, but is:%v\n&quot;, ts.input, ts.expected, actual)
    }
  }
}
</code></pre><h2 id="辅助函数-test-helper">辅助函数 (test helper)</h2><p>在写测试的过程中，我们可能遇到下面几个场景：</p><ol><li><p>待测试的功能需要一些前提条件，比如初始化数据库连接、打开文件、创建资源</p></li><li><p>核心功能测试结束后，需要一些清理工作，比如关闭文件、销毁资源</p></li><li><p>待测试的功能错误分类比较多，考虑到table driven test，写到一个测试函数里可读性比较差</p></li></ol><p>这时候，我们需要定义一些辅助函数，以协助核心功能的测试。下面我们以用户登录校验为例，来看如何使用辅助函数。<br>我们要测试的函数是 login，为了保证本次单元测试不会污染数据库，我们采取的流程是：</p><ol><li><p>初始化数据库连接（类似于 Junit 中的 @Before)</p></li><li><p>创建一个用户 （类似于 Junit 中的 @Before）</p></li><li><p>测试 login</p></li><li><p>删除该用户（类似于 Junit 中的 @After)</p></li></ol><p>确定了测试的逻辑以后，我们看下代码：</p><pre><code>// file name: user_test.go
// source code: https://github.com/oscarzhao/blogger-server/blob/master/controllers/user_test.go

// package level initialization of database connections
func init() {
  // init database connections
}

// testCreateUser 创建一个临时用户（test helper）
// 具体流程：
// 1. mocks a http server
// 2. send create user request to the server
func testCreateUser(t *testing, userSpec map[string]string) (int, []byte) {
  // mock a http server
  router := denco.New()
  router.Build([]denco.Record{
    {&quot;/api/v1/users/:user_id&quot;, &amp;route{}},
  })

  testURL := &quot;/api/v1/users/&quot; + userID
  _, params, found := router.Lookup(testURL)
  if !found {
    t.Fatalf(&quot;fails to look up the route, url:%s\n&quot;, testURL)
  }

  handler := func(w http.ResponseWriter, r *http.Request) {
    CreateUser(w, r, params)
  }

  marshaled, _ := json.Marshal(userSpec)
  // create request
  req, err := http.NewRequest(&quot;POST&quot;, &quot;http://anything.com&quot;, bytes.NewBuffer(marshaled))
  if err != nil {
    t.Fatalf(&quot;should create user success, but fails to send request, error:%s\n&quot;, err)
  }

  // mock ResponseWriter
  w := httptest.NewRecorder()
  // call create operation
  handler(w, req)
  return w.Code, w.Body.Bytes()
}

// testDeleteUser 根据 userID 删除一个用户（test helper）
func testDeleteUser(t *testing.T, userID string) (int, []byte) {
  ...
}

// TestVerifyLogin 创建用户、测试登录，然后删除该用户
// 该函数由 go 语言的 test 框架调用
func TestVerifyLogin(t *testing.T) {
  userID := uuid.NewV4().String()
  data := map[string]string{
    &quot;username&quot;: &quot;simple_yyxxzz&quot;,
    &quot;password&quot;: &quot;simple_password&quot;,
    &quot;email&quot;:    &quot;not@changed.com&quot;,
    &quot;phone&quot;:    &quot;1234567890&quot;,
  }
  statusCode, msg := testCreateUser(t, userID, data)
  if statusCode &gt;= http.StatusBadRequest {
    t.Fatalf(&quot;should succeeed, create user (%s), but fails, error:%s\n&quot;, userID, msg)
  }
  // 测试结束时，清理数据
  defer func(userID string) {
    statusCode, msg := testDeleteUser(t, userID)
    if statusCode &gt;= http.StatusBadRequest {
      t.Errorf(&quot;should delete user(%s) successfully, but fails, status code:%d, error:%s\n&quot;, userID, statusCode, msg)
    }
  }(userID)

  // 测试登录功能
  shouldSuccess := xxx
  for _, ts := range shouldSuccess {
    statusCode, msg = testVerifyPassword(t, ts)
    if statusCode != http.StatusOK {
      // if use fatal, user will not be cleaned up
      t.Errorf(&quot;should verify with %v successfully, but failed, status code:%d, error:%s\n&quot;, ts, statusCode, msg)
      return
    }
  }
}
</code></pre><p>在测试代码中，我们推荐使用 t.Fatalf ， 而不是 t.Errorf，一方面测试代码不需要做太多容错，另一方面增加了测试代码的可读性。</p><h2 id="临时文件">临时文件</h2><p>如果待测试的功能模块涉及到文件操作，临时文件是一个不错的解决方案。go语言的 ioutil 包提供了 TempDir 和<br>TempFile 方法，供我们使用。</p><p>我们以 etcd 创建 wal 文件为例，来看一下 TempDir 的用法：</p><pre><code>// github.com/coreos/etcd/wal/wal_test.go

func TestNew(t *testing.T) {
  p, err := ioutil.TempDir(os.TempDir(), &quot;waltest&quot;)
  if err != nil {
    t.Fatal(err)
  }
  defer os.RemoveAll(p)  // 千万不要忘记删除目录

  w, err := Create(p, []byte(&quot;somedata&quot;))
  if err != nil {
    t.Fatalf(&quot;err = %v, want nil&quot;, err)
  }
  if g := path.Base(w.tail().Name()); g != walName(0, 0) {
    t.Errorf(&quot;name = %+v, want %+v&quot;, g, walName(0, 0))
  }
  defer w.Close()

  // 将文件 waltest 中的数据读取到变量 gb []byte 中 
  // ...

  // 根据 &quot;somedata&quot; 生成数据，存储在变量 wb byte.Buffer 中
  // ...

  // 临时文件中的数据（gb）与 生成的数据（wb）进行对比
  if !bytes.Equal(gd, wb.Bytes()) {
    t.Errorf(&quot;data = %v, want %v&quot;, gd, wb.Bytes())
  }
}
</code></pre><p>上面这段代码是从 etcd 中摘取出来的，源码查看 <a href="https://github.com/coreos/etcd/blob/2353cbca719f6661c8642d666dd8e16591f5ebb5/wal/wal_test.go">coreos/etcd - Github</a>。<br>需要注意的是，使用 <a href="https://golang.org/pkg/io/ioutil/#TempDir">TempDir</a> 和 <a href="https://golang.org/pkg/io/ioutil/#TempFile">TempFile</a> 创建文件以后，需要自己去删除。</p><h2 id="关于-package">关于 package</h2><p>在写单元测试时，一般情况下，我们将功能代码和测试代码放到同一个目录下，仅以后缀 _test 进行区分。</p><p>对于复杂的大型项目，功能依赖比较多时，通常在跟目录下再增加一个 test 文件夹，不同的测试<br>放到不同的子目录下面，如下图所示：</p><p>针对自己的项目进行测试时，可以结合这两种方式实现测试用例，提高代码的可读性和可维护性。</p><h3 id="相关链接">相关链接：</h3><ol><li><p><a href="https://golang.org/pkg/testing/">golang.org/pkg/testing</a></p></li><li><p><a href="https://talks.golang.org/2014/testing.slide">Testing Techniques</a></p></li><li><p><a href="https://github.com/golang/go/wiki/TableDrivenTests">Table Driven Test</a></p></li><li><p><a href="https://github.com/golang/go/wiki/LearnTesting">Learn Testing</a></p></li></ol><p>扫码关注微信公众号“深入Go语言”</p></div><aside id="meta"><meta itemprop="wordCount" content="720"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/goyu-yan-chan-yuan-ce-shi.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/yi--xian-dai-la-ji-hui-shou.html">[译]现代垃圾回收</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/fen-bu-shi-ji-tong-ce-shi-na-xie-shi-er--cuo-wu-zhu-ru.html">分布式系统测试那些事儿-错误注入</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="28534cca0428a79b8acdeb464b65562f" data-title="Go语言单元测试" data-url="https://yushuangqi.com/blog/2016/goyu-yan-chan-yuan-ce-shi.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，Golang开发独立咨询顾问。为国内客户提供Golang开发、技术实战、架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-chan-yuan-ce-shi.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgoyu-yan-chan-yuan-ce-shi.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Golang开发独立开发专家。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>