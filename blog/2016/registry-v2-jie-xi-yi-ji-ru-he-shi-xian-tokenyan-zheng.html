<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>registryv2解析以及如何实现token验证 |虞双齐Golang开发</title><meta name="description" content="提到registry v2，主要改进是支持并行pull镜像，镜像层id变成唯一的，解决同一个tag可"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/registry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html"><meta property="og:title" content="registryv2解析以及如何实现token验证"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:34:10"><meta property="article:modified_time" content="2016-12-31 11:34:10"><meta property="article:tag" content="golang"><meta name="og:description" content="提到registry v2，主要改进是支持并行pull镜像，镜像层id变成唯一的，解决同一个tag可"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20161122"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/registry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html">registryv2解析以及如何实现token验证</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000003963021" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><p>提到registry v2，主要改进是支持并行pull镜像，镜像层id变成唯一的，解决同一个tag可能对应多个镜像的问题等等。如果还不太了解，可以且听我细细道来。</p><h2 id="首先不得不说的是v2-新加了一个概念digest">首先不得不说的是v2 新加了一个概念Digest</h2><p>他是基于内容进行寻址（Content-addressable)算法算出来的一串hash值。简单的说就是内容不同，得出了的digest值是不同的，但是内容相同的话，得出的digest值是一定相同的。我们的每个镜像层id就是根据每个镜像层的内容得出来的digest的。</p><p>所以你在改动镜像层以后生成的digest就不同了，而不动的话，这个digest还是不变的，那么这个digest id是什么时候生成的呢？我们在本地构建镜像时生成的镜像层id每次都是不一样的，这个digest是我们在push镜像时生成的。</p><p>为了验证内容相同，push到registry得到的digest相同，我做了个小实验，用如下Dockerfile 注释掉第三行和不注释构建了两次镜像，再push到registry</p><p>如果是v1的话，push上去得到的层id肯定是不一样的，但是v2里面，注释第三行得到了5个镜像层，不注释掉第三行得到了6个镜像层，并且第一次的5个层都包含在第二次6个里面。所以得出结论这个digest确实是根据内容生成的。</p><h2 id="接下来说一下镜像的id">接下来说一下镜像的id</h2><p>镜像id也是生成了一个digest值，镜像id是根据_manifest这个文件，也就是镜像层id和镜像名字等一些其他信息生成的digest。我们在每次向v2 push镜像时候，最后都会返回给docker client一个digest值，这个值就代表了镜像的digest id。这个id的作用就是可以指定唯一的镜像了。类似tag使用。</p><p>因为我们知道v1时候用tag有个弊病就是多次构建的镜像可以使用同一个tag，导致我们用tag标识镜像的时候可能并不是我们想要的，而用了digest就不会出现这种问题。</p><p>我们在写Dockerfile的时候引用镜像就可以这么用：</p><p>FROM localhost:5000/test@sha256:ac81211548c0d228e10daaf76f6e0024e5f91879c8a7e105e777d6f964270449</p><p>像使用tag一样，用本地docker查看镜像digests时候可以使用：docker images &ndash;digests，</p><p>当然，目前来说你看到的都是&lt;none&gt;，我们需要从registry上pull下来，使用<br>docker pull localhost:5000/test@sha256:ac81211548c0d228e10daaf76f6e0024e5f91879c8a7e105e777d6f964270449</p><h2 id="了解了digest-我们来看一看registry的存储结构">了解了digest，我们来看一看registry的存储结构</h2><p>这部分最好可以对着registry的文件夹结构来看。简单的画了个草图。</p><p>是v2的文件夹层级关系</p><p>这个是目录下具体的样子，可以先看一会儿，可以看到registry 下面有两个文件夹blobs和repositories，</p><p>blobs下面存储了registry的所有基本信息元素，包括镜像层digest和镜像digest，之后在通过某种方式将调用这里的信息。</p><p>blobs文件夹下面先分了一个等级，是digest的前两位字符组成的文件夹为了筛选digest，避免了这个文件夹太大，查看时都难。这样方便定位。每个blob里都有一个data文件，存储相关信息。</p><p>repositories下面存储的是各个镜像名字命名的文件夹，进入一个镜像文件夹后，可以看到三个子文件夹，_layers, _manifests, _uploads，_layers这个文件夹是跟这个镜像有关的所有镜像层，进入其中一个镜像层文件夹，下面只有一个文件&ndash;link命名的文件，里面的内容就是一个digest。</p><p>这就跟blobs下面的镜像层建立起了联系，在repositories这个文件夹下，都是通过link文件与blobs文件夹下的文件建立的联系。</p><p>_upload这个文件夹，平时点进去是空的，这个文件夹主要作用是上传用的。我们上传镜像层的时候，先上传到这个文件夹下，等完成传输以后，在将这个文件夹下的内容移动到blobs下面，然后将原来的文件删除。</p><p>_manifest这个文件夹非常重要，是镜像的相关信息。他下面有两个子文件夹，revisions和tags，revisions这个文件夹下是这个镜像的所有可用的镜像digest，里面的link文件指向了镜像的digest。我们去blobs里面找相应的id对应的文件，查看文件下面的data，我们发现这个data文件里面存储的信息，和我们通过registry v2 rest api请求manifest信息相同~在看_manifest/tags/。下面就是这个镜像的不同tag了。又分了current和index分别表示当前tag对应的digest和此tag下的所有镜像digest。</p><h2 id="下面来介绍一下如何搭建token验证的registry">下面来介绍一下如何搭建token验证的registry</h2><p>先看一下官方给的图</p><p>可以看到，v2和v1相比，访问形式完全变了，去掉了index server，加上了一个auth server。</p><p>访问顺序是这样的</p><ol><li><p>我们通过docker client让docker deamon先访问registry，registry如果不需要身份验证，则直接返回结果，若需要验证，返回401并在header附带一些信息，</p></li><li><p>daemon根据信息访问auth server。auth server判断通过了验证，并返回给daemon一串token。</p></li><li><p>daemon带着这串token再去访问registry则可以获得到信息，pull ，push，api都走的这套流程。</p></li></ol><p>接下来贴下我的配置文件config.yml，配置了选项auth/token表示要token验证。这个流程确实需要好好读一下，跟她的加密方式有很大关系</p><p>version: 0.1<br>log:<br>fields:<br>service: registry<br>storage:<br>cache:<br>blobdescriptor: redis<br>filesystem:<br>rootdirectory: /var/lib/registry<br>http:<br>addr: :5000<br>secret: randomstringsecret<br>tls:<br>certificate: /root/sslkeys/domain.crt<br>key: /root/sslkeys/domain.key<br>auth:<br>token:<br>realm: <a href="https://registry.tenxcloud.com">https://registry.tenxcloud.com</a>:5001/auth<br>service: test123.tenxcloud.com:5000<br>issuer: qwertyui<br>rootcertbundle: /root/sslkeys/domain.crt<br>当然，我是通过容器启动的v2，把这个config volume进去的</p><p>我的启动命令：docker run -d -p 5000:5000 &ndash;restart=always &ndash;name registry -v <code>pwd</code>/sslkeys:/root/sslkeys -v <code>pwd</code>/config.yml:/etc/docker/registry/config.yml -v <code>pwd</code>/data:/var/lib/registry registry:2.1.1</p><p>auth/token下的4个子选项都是必须配置的，realm表示我的auth server地址，service表示的registry的地址，issuer是一串标示符，随便写一下，auth server加密的时候也需要配置同样的字符串。rootcertbundle配置一个秘钥，对token进行加密。（我这里复用了我的tls token）</p><p>当我们第一次未带token访问registry时会返回401并附带如下信息：Www-Authenticate: Bearer realm=&ldquo;test123.tenxcloud.com:5000 &ldquo;,service=&ldquo;test123.tenxcloud.com:5000 &ldquo;scope=&ldquo;repository:husseingalal/hello:push&rdquo;，realm和service就是前面说的，scope表示的是我要做的操作，repository代表镜像，接着是镜像名字，然后是pull或者是push或者二者都有</p><p>知道了各个参数的功能，就可以搭建我们的auth server了，我从github下找到了一个项目：<a href="https://github.com/cesanta/docker_auth">https://github.com/cesanta/docker_auth</a></p><p>用go语言写的，其中的账号密码存储方式有：写入文件，ldap和google账号的。这个server实现了动态加载配置文件，配置文件有变化这个server会进行安全的重启，所以可以对文件动态添加账号密码。当然也可以自己写身份验证，添加数据库等方式的，只需要继承Authenticator这个interface就可以。添加起来很容易。身份验证后有权限控制acl，并且我们也可以自定义权限控制，继承Authorizer这个interface即可。</p><p>前两项通过后就是生成token（这一部分这个项目已经封装好了，不用改动），<br>v2的token采用的JWT加密方式，JWT分了三个部分，header，payload,signature，header里面带的信息是token加密方式，一般都是base64， payload里带的都是需要的基本信息，user,权限，过期时间，还有前面说的issure 等等，<br>signature是header+payload后用秘钥进行加密，这个秘钥就是配置在registry里的rootcertbundle对应的秘钥。</p><p>三部分通过 . 连接, 因为有秘钥加密，保证了token信息不会被窜改，这种加密方式保证了将权限验证和registry分离也 是安全的, 将token发送回daemon后daemon就可以带着token去正常访问registry了，如果是rest api，直接将其写成Bearer token就可以请求了。</p><p>本文作者:时速云工程师丁麒伟 原文链接：<a href="http://blog.tenxcloud.com/?p=951">registry v2 解析以及如何实现token验证</a></p></div><aside id="meta"><meta itemprop="wordCount" content="136"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/registry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/goyu-yan-xiang-mu-kingshardxing-neng-you-hua-shi-li-pou-xi.html">Go语言项目(kingshard)性能优化实例剖析</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/tong-yi-pei-zhi-guan-li-gong-ju-confd.html">统一配置管理工具confd</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="94c1763aeefb921e1a87e4f6c5cb3cc5" data-title="registryv2解析以及如何实现token验证" data-url="https://yushuangqi.com/blog/2016/registry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，开源爱好者，Golang开发独立咨询顾问。为国内客户提供Golang开发、技术实战、架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="/"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about/"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fregistry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fregistry-v2-jie-xi-yi-ji-ru-he-shi-xian-tokenyan-zheng.html" rel="nofollow" target="blank"><img src="http://static.yushuangqi.com/assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-Golang开发独立开发专家。欢迎<a href="/about/" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>