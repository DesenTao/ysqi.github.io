<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>golang笔记 |虞双齐Golang开发与SRE运维</title><meta name="description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode"><meta name="keywords" content="golang, emacs, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2016/golang-bi-ji.html"><meta property="og:title" content="golang笔记"><meta property="og:type" content="article"><meta property="article:published_time" content="2016-12-31 11:32:28"><meta property="article:modified_time" content="2016-12-31 11:32:28"><meta property="article:tag" content="golang"><meta property="article:tag" content="emacs"><meta name="og:description" content="emacs 开发环境 spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要gocode"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2016/golang-bi-ji.html">golang笔记</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://segmentfault.com/a/1190000008156232" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2016-12-31">2016年12月31日</time></span></p></header><div itemprop="articleBody"><h2 id="emacs-开发环境">emacs 开发环境</h2><p>spacemacs已经集成了不少功能，但是缺少代码提示。因此还需要<a href="https://github.com/nsf/gocode">gocode</a>来辅助。</p><ol><li><p>安装所需的命令</p><p>go get -u -v github.com/nsf/gocode<br>go get -u -v github.com/rogpeppe/godef go get -u -v<br>golang.org/x/tools/cmd/guru go get -u -v<br>golang.org/x/tools/cmd/gorename go get -u -v<br>golang.org/x/tools/cmd/goimports</p></li><li><p>配置文件</p><p>将gocode中的<code>go-autocomplete.el</code>拷贝至<code>elpa/go-mode</code>下<br>向space macs手动添加包：<code>dotspacemacs-additional-packages '(go-autocomplete)</code><br>在<code>dotspacemace/user-config</code>中添加以下内容</p><pre><code>(require 'go-autocomplete)
(require 'auto-complete-config)
(ac-config-default)
</code></pre></li></ol><hr><h1 id="go">GO</h1><p><a href="http://docs.studygolang.com/pkg/">package 手册</a> 、<a href="https://github.com/gopl-zh/gopl-zh.github.com">go语言圣经</a></p><h2 id="语法">语法</h2><ol><li><p>声明 ：<code>var|const|type|func name (类型) (值)</code></p><p><code>var</code> 显式声明一个变元。<code>var name Type</code><br><code>:=</code> 语法可以隐式地声明一个变元。<code>name := f() | a</code><br>隐式声明的变元的作用域是可以被覆盖的，但显式的不能。</p><pre><code>var a int //1.会导致3出错
a := 1    //2.不会导致3处出错
{
a:= 2     //3.
}
</code></pre><p><code>const a=2</code>, <code>const a float64=2</code></p><p><code>type name define</code>，<code>define= Type | struct{..}|interface{}</code></p><p><code>func (name Type)* name (arg...) {...}</code><br>打*号的部分是 接收器(receiver)，用于扩展指定<code>Type</code>（必须是自定义类型）。</p><pre><code>type Point struct{ X, Y float64 }
// traditional function
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
type Float64 float64 //
func (p Float64) Distance(q Float64) float64 {
    return math.Abs(float64(p - q))
}
var x, y Float64 = 1.0, 2
x.Distance(y)
</code></pre><p>匿名函数：<code>func(r rune) rune { return r + 1 }</code><br>便捷操作</p><pre><code>import (
    &quot;C&quot;
    &quot;fmt&quot;
    &quot;math&quot;
)
const | var (
    AbsoluteZeroC Celsius = -273.15 // 绝对零度
    FreezingC     Celsius = 0       // 结冰点温度
    BoilingC      Celsius = 100     // 沸水温度
)
var a,b,c Type
</code></pre></li><li><p>控制结构<br><strong>if</strong>语句</p><pre><code>if a, b := 21, 3; a &gt; b {
    fmt.Println(&quot;a&gt;b ? true&quot;)
}else {
}

for i, j := 1, 10; i &lt; j; i,j=i+1,j+1 {  //死循环
    fmt.Println(i)
}
</code></pre><p><strong>switch</strong>语句</p><pre><code>switch ch {
case '0': 
    fallthrough   //必须是最后一个语句
case '1':
    cl = &quot;Int&quot;
case 'A': 
case 'a':
    fallthrough
    cl = &quot;ABC&quot;    //error
default:
    cl = &quot;Other Char&quot;
}
</code></pre></li><li><p>类型转换<br>语法：</p><pre><code>&lt;目标类型&gt; ( &lt;表达式&gt; )
&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言
&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　//非安全类型断言

var3 := int64(var1)
var i interface{} = &quot;TT&quot;
j, b := i.(int)
if b {
    fmt.Printf(&quot;%T-&gt;%d\n&quot;, j, j)
} else {
    fmt.Println(&quot;类型不匹配&quot;)
}
</code></pre></li></ol><h2 id="基本类型">基本类型</h2><ol><li><p>数组</p><pre><code>q := [...]int{1, 2, 3}
q := [3]int{1, 2, 3} //等价
fmt.Printf(&quot;%T\n&quot;, q) // &quot;[3]int&quot;

r := [...]int{99: -1}// {下表：值}，填充默认值
</code></pre></li><li><p>Slice<br>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作<code>[]T</code>，其中T代表slice中元素的类型；数组和slice之间有着紧密的联系。一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。一个slice由三个部分构成：指针、长度和容量。<br><code>array[i:j]</code>来创建一个Slice，0 ≤ i≤ j≤ cap(s)</p><pre><code>array := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}
front := array[0:5]
mid := array[3:8]
tail := array[4:9]
front[4] = 555 //3个数都被修改
array[5] = 605 //会导致 mid,tail 修改
</code></pre><p><strong>注意</strong></p><pre><code>    array := [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9}
    front := array[0:5]
    mid := array[3:8]
    tail := array[4:9]
    nf := append(tail, 66) //1.
    nf := append(mid, 66) //2.
    nf[0] = 5555
    fmt.Println(front, mid, tail, nf)
    //1. [1 2 3 4 601] [4 601 6 7 8] [601 6 7 8 9] [5555 6 7 8 9 66]
    //2. [1 2 3 5555 5] [5555 5 6 7 8] [5 6 7 8 66] [5555 5 6 7 8 66]
</code></pre><p>当原数组够用时，append会直接使用原来的空间。不够时另开一片。</p><p><code>[]T</code>是切片类型 <code>[n]T</code>是数组类型</p></li><li><p>Map<br>我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value：</p><pre><code>ages := make(map[string]int) // mapping from strings to ints
ages := map[string]int{
    &quot;alice&quot;:   31,
    &quot;charlie&quot;: 34,
}
</code></pre></li><li><p>结构体</p><pre><code>type Employee struct {
    ID        int
    Name      string
    Address   string
    DoB       time.Time
    Position  string
    Salary    int
    ManagerID int
}

var dilbert Employee
</code></pre></li><li><p>接口<br>一类有相同方法的对象。</p><pre><code>package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}

var w io.Writer
w = os.Stdout //使用接口
</code></pre></li></ol><h2 id="符号">符号</h2><pre><code>关键字：
        break      default       func     interface   select
        case       defer         go       map         struct
        chan       else          goto     package     switch
        const      fallthrough   if       range       type
        continue   for           import   return      var

内建常量: true false iota nil

内建类型: int int8 int16 int32 int64
          uint uint8 uint16 uint32 uint64 uintptr
          float32 float64 complex128 complex64
          bool byte rune string error

内建函数: make len cap new append copy close delete
          complex real imag
          panic recover
</code></pre><ol><li><p>defer ：延迟执行</p><pre><code>    defer println(&quot;p1&quot;) //后被打印
    defer println(&quot;p2&quot;) //先被打印
</code></pre><p>假设defer处声明了一个变量，那么在析构的时候执行内容。</p></li><li><p>range ：配合for使用</p><pre><code>for index, value := range mySlice {
    fmt.Println(&quot;index: &quot; + index)
    fmt.Println(&quot;value: &quot; + value)
}
</code></pre><ul><li><p>for index,char := range string {}</p></li><li><p>for index,value := range array {}</p></li><li><p>for index,value := range slice {}</p></li><li><p>for key,value := range map {}</p></li></ul></li></ol><h2 id="抽象">抽象</h2><p>不同于面向对象的语言先定义一个对象具有哪些抽象行为再实现的思路。<br>GO是先实现一个对象，再检查这个对象是否符合接口规范。</p><ol><li><p>方法<br>扩展某一个类型</p><pre><code>type Point struct{ X, Y float64 }

// traditional function
func Distance(p, q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}

// same thing, but as a method of the Point type
func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
}
</code></pre></li><li><p>接口<br>一类有相同方法的对象。</p><pre><code>package io
type Reader interface {
    Read(p []byte) (n int, err error)
}
type Closer interface {
    Close() error
}
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Writer
}
</code></pre></li></ol><h2 id="并行">并行</h2><ol><li><p>goroutine<br>使用go关键字go</p><pre><code>f()    // call f(); wait for it to return
go f() // create a new goroutine that calls f(); don't wait
</code></pre></li><li><p>channel</p><pre><code>var ch chan int
ch = make(chan int)    // unbuffered channel
ch = make(chan int, 0) // unbuffered channel
ch = make(chan int, 3) // buffered channel with capacity 3

ch &lt;- 2 //send
a := ch //receive
</code></pre><p><code>chan&lt;- int</code>表示一个只发送int的channel，只能发送不能接收。<br><code>&lt;-chan int</code>表示一个只接收int的channel，只能接收不能发送。<br>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。</p></li><li><p>select</p><pre><code>select {
case &lt;-ch1:
    // ...
case x := &lt;-ch2:
    // ...use x...
case ch3 &lt;- y:
    // ...
case &lt;-time.After(10 * time.Second):
    //超时机制，不能与default一起
default:
    // ...
}
</code></pre></li></ol><h2 id="调用c库">调用C库</h2><p><a href="https://golang.org/cmd/cgo/">cgo</a></p><pre><code>/*
#cgo CFLAGS: -I/usr/include
#cgo LDFLAGS: -L/usr/lib -lbz2
#include &lt;bzlib.h&gt;
#include &lt;stdlib.h&gt;
bz_stream* bz2alloc() { return calloc(1, sizeof(bz_stream)); }
int bz2compress(bz_stream *s, int action,
                char *in, unsigned *inlen, char *out, unsigned *outlen);
void bz2free(bz_stream* s) { free(s); }
*/
import &quot;C&quot;
</code></pre><p>可以添加一下编译选项：</p><blockquote><p>CFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS , LDFLAGS</p></blockquote><p>c代码必须加以注释且后面紧跟<code>import &quot;C&quot;</code></p><p>在Go中使用C的类型</p><blockquote><p>C.char C.schar (signed char) C.uchar (unsigned char) C.short C.ushort (unsigned short) C.int C.uint (unsigned int) C.long C.ulong (unsigned long) C.longlong (long long) C.ulonglong (unsigned long long) C.float C.double C.complexfloat (complex float) C.complexdouble (complex double)</p></blockquote><p>如果是 <code>struct, union, or enum</code> 类型的，会添加前缀 <code>struct_, union_, or enum_</code>。<br>如<code>struct。a{...};</code>在go中变为<code>C.struct_a</code>。<br><code>C.sizeof_T</code> 表示C中某种类型的长度</p><pre><code>package main

// typedef int (*intFunc) ();
//
// int
// bridge_int_func(intFunc f)
// {
//        return f();
// }
//
// int fortytwo()
// {
//        return 42;
// }
import &quot;C&quot;
import &quot;fmt&quot;

func main() {
    f := C.intFunc(C.fortytwo)
    fmt.Println(int(C.bridge_int_func(f)))
    // Output: 42
}
</code></pre><p>在go中不能调用c中<strong>可变参数的函数</strong>。</p></div><aside id="meta"><meta itemprop="wordCount" content="955"><meta itemprop="url" content="https://yushuangqi.com/blog/2016/golang-bi-ji.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/emacs.html" rel="tag">emacs</a> <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2016/nian-du-yu-yan--golang-shi-yong-gan-shou.html">年度语言golang使用感受</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2016/ji-shi-tong-xin-zui-jia-shi-jian.html">及时通信最佳实践</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="3b6262458f5775dee18cb694f8022922" data-title="golang笔记" data-url="https://yushuangqi.com/blog/2016/golang-bi-ji.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgolang-bi-ji.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2016%2fgolang-bi-ji.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-#Golang开发 #SRE运维。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>