<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Golang学习摘录六:接口 |虞双齐Golang开发与SRE运维</title><meta name="description" content="Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集"><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="192x192" href="/img/app-icon64x64@2x.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="Ysqi"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64@2x.png"><meta name="msapplication-TileImage" content="/img/app-icon64x64@2x.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐Golang开发与SRE运维"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html"><meta property="og:title" content="Golang学习摘录六:接口"><meta property="og:type" content="article"><meta property="article:published_time" content="2017-02-24 08:31:54"><meta property="article:modified_time" content="2017-02-24 08:31:54"><meta property="article:tag" content="golang"><meta name="og:description" content="Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集"><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=20170207"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html">Golang学习摘录六:接口</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="http://www.jianshu.com/p/996e840629e7" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2017-02-24">2017年02月24日</time></span></p></header><div itemprop="articleBody"><p>Go中关键字interface被赋予了很多不同的含义。每个类型都有接口，意味着对那个类型定义了方法集合。</p><pre><code>// 这段代码定义了具有一个字段和两个方法的结构类型s。
type S struct { i int }
func (p *S) Get() int { return p.i }
func (p *S) Put(v int) { p.i = v }
// 定义接口
type I interface {
  Get() int
  Put(int)
}
// 对于接口I，S是合法的实现，因为它定义了 I 所需的两个方法。注意：即便是没有明 确定义 S 实现了 I，这也是正确的。
// Go 程序的特性接口值：
func f(p I) {// 定义一个函数接受一个接口类型作为参数
  fmt.Println(p.Get()) // p实现了接口I，必须有Get()方法
  p.Put(1) // Put()方法是类似的
  // 这里的变量p保存了接口类型的值。 
}
// 调用
var s S
f(&amp;s) // 因为S实现了I，可以调用f向其传递S类型的值的指针
// 获取 s 的地址,而不是 S 的值的原因,是因为在 s 的指针上定义了方法,参阅上面的 代码 5.1。这并不是必须的——可以定义让方法接受值——但是这样的话 Put 方法就不 会像期望的那样工作了。

// 定义另外一个类型同样实现接口I：
type R struct { i int }
func (p *R) Get() int { return p.i } 
func (p *R) Put(v int) { p.i=v }

// 函数f现在可以接受类型为R或S的变量。
// 假设需要在函数f中知道实际的类型。在Go中可以使用type switch得到。
func f(p I) {
  switch t : p.(type) { // 类型判断；在switch语句中使用(type)。保存类型到变量t中。在switch之外使用(type)是非法的。
    case *S:
    case *R:
    case S:
    case R:
    defaut:
  }
}
// 类型判断不是唯一的运行时得到类型的方法。 为了在运行时得到类型,同样可以使用 “comma, ok” 来判断一个接口类型是否实现了 某个特定接口:
    if t, ok := p.(*S); ok {
        fmt.Printf(&quot;%d\n&quot;, t.Get())
    }
// 确定一个变量实现了某个接口，可以使用：
t := p.(*S)
</code></pre><h4 id="空接口">空接口</h4><pre><code>interface{} // 每个类型都能匹配到空接口
func g(something interface{}) int { // 用空接口作为参数的函数
  return something.(I).Get() // 值 something 具有 类型 interface{},这意味着方法没有任何约束:它能包含任何类型。.(I) 是 类型 断言,用于转换 something 到 I 类型的接口。
// 如果有这个类型,则可以调用 Get() 函 数。因此,如果创建一个 *S 类型的新变量,也可以调用 g(),因为 *S 同样实现了空 接口。
}
s = new(S)
fmt.Println(g(s)) // 打印0
// 如果调用g()的参数没有实现I，会在运行时得到警告，如
i:=5 
fmt.Println(g(i)) // 在运行时警告：panic: interface conversion: int is not main.I: missing method Get，这是没有问题的，因为内建类型int没有Get()方法。
</code></pre><h2 id="方法">方法</h2><p>方法就是有接受者的函数，可以在任意类型上定义方法（除了非本地类型，包括内建类型：int类型不能有方法）。但是可以新建一个拥有方法的整数类型。</p><pre><code>type Foo int
func (f Foo) Emit(){
  fmt.Printf(&quot;%v&quot;,f)
}
type Emitter interface{
  Emit()
}
func (i int) Emit() {....}  // ❎不能直接扩展内建类型
func (a *net.AddrError) Emit(){...}// ❎不能直接扩展非本地类型
// 可以通过新建类型的方式处理
type newError net.AddrError
func (a *newError) Emit(){...}// ✅
</code></pre><p>接口定义为一个方法的集合。方法包含实际的代码。换句话说，一个接口就是定义，而方法就是实现。因此，接受者不定定义为接口类型，这样做会引起invalid receiver type编译错误</p><blockquote><p>接收者类型必须是 T 或 *T,这里的 T 是类型名。T 叫做接收者基础类型或 简称基础类型。基础类型一定不能使指针或接口类型,并且定义在与方法 相同的包中。</p><p>在Go中创建指向接口的指针是无意义的。实际上创建接口值的指针也是非法的。</p></blockquote><h2 id="接口名字">接口名字</h2><p>根据规则,单方法接口命名为方法名加上 -er 后缀:Reader,Writer,Formatter 等。<br>有一堆这样的命名,高效的反映了它们职责和包含的函数名。Read,Write,Close, Flush,String 等等有着规范的声明和含义。为了避免混淆,除非有类似的声明和含 义,否则不要让方法与这些重名。相反的,如果类型实现了与众所周知的类型相同的方 法,那么就用相同的名字和声明;将字符串转换方法命名为 String 而不是 ToString。<br>冒泡排序整型数据</p><pre><code>func bubblesort(n []int) {
  for i:=0; i&lt; len(n)-1; i++ {
      for j:=i+1; j&lt; len(n); j++ {
         if n[j]&lt;n[i] {
            n[i], n[j] = n[j], n[i]
        } 
    }
  }
}
</code></pre><p>类似的排序字符串<br>func bubblesortString(n []string){ /<em>&hellip;.</em>/ }<br>基于此，可能需要两个函数，每个类型一个。而通过使用接口可以让这个变得更加通用。<br>下面的方法不能用❎</p><pre><code>func sort(i []interface{}) { // 函数将接受一个空接口的slice
  switch i.(type) {// 使用type switch找到输入参数实际的类型
    case string: // 排序
        // ....
    case int:
        // ...
  }
  return /*....*/    //返回排序后的slice
}
</code></pre><p>但是如果用sort([]int{1,4,5})调用这个函数，会失败：cannot use i (type []int) as type []interface in function argment<br>这是因为Go不能（隐式）转换为slice。<br>所以需要通过接口的方式创建Go形式的“通用”函数。<br>步骤：<br>1.定义一个有着若干排序相关方法的接口函数（这里叫做Sorter）。至少需要获取slice长度的函数，比较两个值的函数和交换函数；</p><pre><code>type Sorter interface {
  Len() int // len()作为方法
  Less(i,j int) bool // p[j]&lt;p[i]作为方法
  Swap(i,j int)  // p[i],p[i] = p[j],p[i]作为方法
}
</code></pre><p>2.定义用于排序slice的新类型。注意定义的是slice类型；</p><pre><code>type Xi []int
type Xs []string
</code></pre><p>3.实现Sorter接口的方法。</p><pre><code>//整数为：
func (p Xi) Len() int { return len(p) }
func (p Xi) Less(i int, j int) bool { return p[j]&lt;p[i] }
func (p Xi) Swap(i int, j int) { p[i],p[j]=p[j],p[i] }
// 字符串的：
func (p Xs) Len() int { return len(p) }
 func (p Xs) Less(i int, j int) bool { return p[j] &lt; p[i] }
 func (p Xs) Swap(i int, j int) { p[i], p[j] = p[j], p[i]
</code></pre><p>4.编写作用于Sorter接口的通用排序函数。</p><pre><code>func Sort(x Sorter) {// x现在是Sorter类型;
   for i:=0; i&lt;x.Len()-1; i++ {
    for j:=i+1; j&lt;x.Len(); j++ {
       if x.Less(i, j) {
          x.Swap(i, j)
       }
    }
  }
}
// 现在可以像下面这样使用通用的 Sort 函数:
ints := Xi{44, 67, 3, 17, 89, 10, 73, 9, 14, 8}
strings := Xs{&quot;nut&quot;, &quot;ape&quot;, &quot;elephant&quot;, &quot;zoo&quot;, &quot;go&quot;}

Sort(ints)
fmt.Printf(&quot;%v\n&quot;, ints)
Sort(strings)
fmt.Printf(&quot;%v\n&quot;, strings)
</code></pre></div><aside id="meta"><meta itemprop="wordCount" content="514"><meta itemprop="url" content="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-wu-jin-jie.html">Golang学习摘录五:进阶</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html">Golang学习摘录四:包</a></li></ul></div><aside id="comments"><div><div class="ds-thread" data-thread-key="4c6d2a31f1c040a883b05fb3ded66651" data-title="Golang学习摘录六:接口" data-url="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-liu-jie-kou.html"></div></div></aside><div><section id="author"><h4>About author</h4><p><strong>虞双齐</strong>，全栈开发工程师，Google SRE实践者。提供Golang开发、技术实践与架构等咨询服务。</p><p>动态分享到微博<a href="http://weibo.com/234665601" rel="nofollow">@虞双齐</a>，代码存放在 <a href="http://github.com/ysqi" rel="nofollow">Github</a>，博文分享在 <a href="https://yushuangqi.com" title="虞双齐Golang开发与SRE运维">个人博客</a>上。</p></section></div></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow"><span class="footeractionWeibo">Follow on Weibo</span></a></li><li><a href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2017%2fgolangxue-xi-zhai-lu-liu-jie-kou.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-html401.png" alt="Valid XHTMl 4.0"></a></li><li><a href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2017%2fgolangxue-xi-zhai-lu-liu-jie-kou.html" rel="nofollow" target="blank"><img src="https://static.yushuangqi.com//assets/valid-css2.png" alt="Valid XHTMl 4.0"></a></li></ul><p>©2015-2016 虞双齐-#Golang开发 #SRE运维。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script type="text/javascript">var duoshuoQuery = {short_name:"ysqi"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-44627932-2', 'auto');
  ga('send', 'pageview');</script></body></html>