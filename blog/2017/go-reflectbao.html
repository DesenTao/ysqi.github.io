<!DOCTYPE html><html xmlns="https://www.w3.org/1999/xhtml" xmlns:og="https://ogp.me/ns#" lang="zh" id="doc" class="no-js"><head><title>Goreflect包 |虞双齐的博客</title><meta name="description" content="Go reflect包
反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type "><meta name="keywords" content="golang, "><meta name="author" content="虞双齐"><meta name="generator" content="Hugo 0.17"><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="renderer" content="webkit"><meta name="applicable-device" content="pc,mobile"><meta name="MobileOptimized" content="width"><meta name="HandheldFriendly" content="true"><meta name="mobile-web-app-capable" content="yes"><link rel="icon" sizes="32x32" href="/img/favicon.ico"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="apple-mobile-web-app-title" content="虞双齐"><link rel="apple-touch-icon-precomposed" href="/img/app-icon64x64.png"><meta name="msapplication-TileImage" content="/img/app-icon128x128.png"><meta name="msapplication-TileColor" content="#0e90d2"><meta property="og:site_name" content="虞双齐的博客"><meta property="og:locale" content="zh"><meta property="og:url" content="https://yushuangqi.com/blog/2017/go-reflectbao.html"><meta property="og:title" content="Goreflect包"><meta property="og:type" content="article"><meta property="article:published_time" content="2017-02-24 08:31:53"><meta property="article:modified_time" content="2017-02-24 08:31:53"><meta property="article:tag" content="golang"><meta name="og:description" content="Go reflect包
反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type "><link rel="stylesheet" type="text/css" href="/css/jiandan.css?v=201709"><script type="text/javascript">var doc = document.getElementById('doc');
	doc.removeAttribute('class', 'no-js');
	doc.setAttribute('class', 'js');</script><script type="text/javascript">var changeActive = function() {
		var page = document.getElementById("page");		
		if (page.getAttribute("class") === "not-active") {
			page.setAttribute("class", "active-sidebar");		
		} else if (page.getAttribute("class") === "active-sidebar") {
			page.setAttribute("class", "not-active");
		}		
	}
	
	window.onload = function() {
		if(document.getElementById("sidebar-button")) {
			var sidebar_button = document.getElementById("sidebar-button");
			sidebar_button.onclick = function(event) {
				changeActive();
				event.preventDefault();
			}
		}
		
	}
	
	window.onresize = function() {
		var page = document.getElementById("page");	
		page.setAttribute("class", "not-active");	
	}</script></head><body id="page" class="not-active"><div class="container"><header class="header writingsheader"><nav class="off-canvas-nav-links"><ul><li class="menuli"><a class="menubutton" href="#menu">Menu</a></li><li id="site-title"><a class="menulogo" id="sidebar-button" href="#sidebar">附件信息</a></li></ul></nav></header><section role="main"><article class="entry writingsentry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 itemprop="headline"><a rel="bookmark" href="https://yushuangqi.com/blog/2017/go-reflectbao.html">Goreflect包</a></h1><p class="attribution"><span itemprop="author"><span itemscope itemtype="http://schema.org/Person">文/ <a href="https://my.oschina.net/xinxingegeya/blog/844412" rel="nofollow" target="_blank">属转载,查看原文 <span itemprop="name" style="display:none">虞双齐</span></a></span> </span><span class="right"><time itemprop="datePublished" datetime="2017-02-24">2017年02月24日</time></span></p></header><div itemprop="articleBody"><p>Go reflect包</p><p>反射是由 reflect 包提供支持. 它定义了两个重要的类型, Type 和 Value. 一个 Type 表示一个Go类型. 函数 reflect.TypeOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Type.</p><p>reflect 包中另一个重要的类型是 Value. 一个 reflect.Value 可以持有一个任意类型的值. 函数 reflect.ValueOf 接受任意的 interface{} 类型, 并返回对应动态类型的reflect.Value. 和 reflect.TypeOf 类似, reflect.ValueOf 返回的结果也是对于具体的类型, 但是 reflect.Value 也可以持有一个接口值.</p><h1 id="reflect-type-类型">reflect.Type 类型</h1><p>代码，</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;unsafe&quot;
)

// 嵌套结构体
type ss struct {
    a struct {
        int
        string
    }
    int
    string
    bool
    float64
}

func (s ss) Method1(i int) string  { return &quot;结构体方法1&quot; }
func (s *ss) Method2(i int) string { return &quot;结构体方法2&quot; }

var (
    intValue   = int(0)
    int8Value  = int8(8)
    int16Value = int16(16)
    int32Value = int32(32)
    int64Value = int64(64)

    uIntValue   = uint(0)
    uInt8Value  = uint8(8)
    uInt16Value = uint16(16)
    uInt32Value = uint32(32)
    uInt64Value = uint64(64)

    byteValue    = byte(0)
    runeValue    = rune(0)
    uintptrValue = uintptr(0)

    boolValue   = false
    stringValue = &quot;&quot;

    float32Value = float32(32)
    float64Value = float64(64)

    complex64Value  = complex64(64)
    complex128Value = complex128(128)

    arrayValue  = [5]string{}           // 数组
    sliceValue  = []byte{0, 0, 0, 0, 0} // 切片
    mapValue    = map[string]int{}      // 映射
    chanValue   = make(chan int, 2)     // 通道
    structValue = ss{ // 结构体
            struct {
            int
            string
        }{10, &quot;子结构体&quot;},
        20,
        &quot;结构体&quot;,
        false,
        64.0,
    }

    func1Value = func(a, b, c int) string { // 函数（固定参数）
        return fmt.Sprintf(&quot;固定参数：%v %v %v&quot;, a, b, c)
    }

    func2Value = func(a, b int, c ...int) string { // 函数（动态参数）
        return fmt.Sprintf(&quot;动态参数：%v %v %v&quot;, a, b, c)
    }

    unsafePointer     = unsafe.Pointer(&amp;structValue)            // 通用指针
    reflectType       = reflect.TypeOf(0)                       // 反射类型
    reflectValue      = reflect.ValueOf(0)                      // 反射值
    reflectArrayValue = reflect.ValueOf([]int{1, 2, 3})         // 切片反射值
    interfaceType     = reflect.TypeOf(new(interface{})).Elem() // 反射接口类型
)

// 简单类型
var simpleTypes = []interface{}{
    intValue, &amp;intValue,               // int
    int8Value, &amp;int8Value,             // int8
    int16Value, &amp;int16Value,           // int16
    int32Value, &amp;int32Value,           // int32
    int64Value, &amp;int64Value,           // int64
    uIntValue, &amp;uIntValue,             // uint
    uInt8Value, &amp;uInt8Value,           // uint8
    uInt16Value, &amp;uInt16Value,         // uint16
    uInt32Value, &amp;uInt32Value,         // uint32
    uInt64Value, &amp;uInt64Value,         // uint64
    byteValue, &amp;byteValue,             // byte
    runeValue, &amp;runeValue,             // rune
    uintptrValue, &amp;uintptrValue,       // uintptr
    boolValue, &amp;boolValue,             // bool
    stringValue, &amp;stringValue,         // string
    float32Value, &amp;float32Value,       // float32
    float64Value, &amp;float64Value,       // float64
    complex64Value, &amp;complex64Value,   // complex64
    complex128Value, &amp;complex128Value, // complex128
}

// 复杂类型
var complexTypes = []interface{}{
    arrayValue, &amp;arrayValue,                  // 数组
    sliceValue, &amp;sliceValue,                  // 切片
    mapValue, &amp;mapValue,                      // 映射
    chanValue, &amp;chanValue,                    // 通道
    structValue, &amp;structValue,                // 结构体
    func1Value, &amp;func1Value,                  // 定参函数
    func2Value, &amp;func2Value,                  // 动参函数
    structValue.Method1, structValue.Method2, // 方法
    unsafePointer, &amp;unsafePointer,            // 指针
    reflectType, &amp;reflectType,                // 反射类型
    reflectValue, &amp;reflectValue,              // 反射值
    interfaceType, &amp;interfaceType,            // 接口反射类型
}

// 空值
var unsafeP unsafe.Pointer

// 空接口
var nilInterfece interface{}

func main() {
    // 测试简单类型
    for i := 0; i &lt; len(simpleTypes); i++ {
        PrintInfo(simpleTypes[i])
    }
    // 测试复杂类型
    for i := 0; i &lt; len(complexTypes); i++ {
        PrintInfo(complexTypes[i])
    }
    // 测试单个对象
    PrintInfo(unsafeP)
    PrintInfo(&amp;unsafeP)
    PrintInfo(nilInterfece)
    PrintInfo(&amp;nilInterfece)

}

func PrintInfo(i interface{}) {
    if i == nil {
        fmt.Println(&quot;--------------------&quot;)
        fmt.Printf(&quot;无效接口值：%v\n&quot;, i)
        return
    }
    t := reflect.TypeOf(i)
    PrintType(t)
}

func PrintType(t reflect.Type) {
    fmt.Println(&quot;--------------------&quot;)
    // ----- 通用方法 -----
    fmt.Println(&quot;String             :&quot;, t.String())     // 类型字符串
    fmt.Println(&quot;Name               :&quot;, t.Name())       // 类型名称
    fmt.Println(&quot;PkgPath            :&quot;, t.PkgPath())    // 所在包名称
    fmt.Println(&quot;Kind               :&quot;, t.Kind())       // 所属分类
    fmt.Println(&quot;Size               :&quot;, t.Size())       // 内存大小
    fmt.Println(&quot;Align              :&quot;, t.Align())      // 字节对齐
    fmt.Println(&quot;FieldAlign         :&quot;, t.FieldAlign()) // 字段对齐
    fmt.Println(&quot;NumMethod          :&quot;, t.NumMethod())  // 方法数量
    if t.NumMethod() &gt; 0 {
        i := 0
        for ; i &lt; t.NumMethod()-1; i++ {
            fmt.Println(&quot;    ┣&quot;, t.Method(i).Name) // 通过索引定位方法
        }
        fmt.Println(&quot;    ┗&quot;, t.Method(i).Name) // 通过索引定位方法
    }
    if sm, ok := t.MethodByName(&quot;String&quot;); ok { // 通过名称定位方法
        fmt.Println(&quot;MethodByName       :&quot;, sm.Index, sm.Name)
    }
    fmt.Println(&quot;Implements(i{})    :&quot;, t.Implements(interfaceType))  // 是否实现了指定接口
    fmt.Println(&quot;ConvertibleTo(int) :&quot;, t.ConvertibleTo(reflectType)) // 是否可转换为指定类型
    fmt.Println(&quot;AssignableTo(int)  :&quot;, t.AssignableTo(reflectType))  // 是否可赋值给指定类型的变量
    fmt.Println(&quot;Comparable         :&quot;, t.Comparable())               // 是否可进行比较操作
    // ----- 特殊类型 -----
    switch t.Kind() {
    // 指针型：
    case reflect.Ptr:
        fmt.Println(&quot;=== 指针型 ===&quot;)
        // 获取指针所指对象
        t = t.Elem()
        fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, t.String())
        // 递归处理指针所指对象
        PrintType(t)
        return
    // 自由指针型：
    case reflect.UnsafePointer:
        fmt.Println(&quot;=== 自由指针 ===&quot;)
    // ...
    // 接口型：
    case reflect.Interface:
        fmt.Println(&quot;=== 接口型 ===&quot;)
    // ...
    }
    // ----- 简单类型 -----
    // 数值型：
    if reflect.Int &lt;= t.Kind() &amp;&amp; t.Kind() &lt;= reflect.Complex128 {
        fmt.Println(&quot;=== 数值型 ===&quot;)
        fmt.Println(&quot;Bits               :&quot;, t.Bits()) // 位宽
    }
    // ----- 复杂类型 -----
    switch t.Kind() {
    // 数组型：
    case reflect.Array:
        fmt.Println(&quot;=== 数组型 ===&quot;)
        fmt.Println(&quot;Len                :&quot;, t.Len())  // 数组长度
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 数组元素类型
    // 切片型：
    case reflect.Slice:
        fmt.Println(&quot;=== 切片型 ===&quot;)
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 切片元素类型
    // 映射型：
    case reflect.Map:
        fmt.Println(&quot;=== 映射型 ===&quot;)
        fmt.Println(&quot;Key                :&quot;, t.Key())  // 映射键
        fmt.Println(&quot;Elem               :&quot;, t.Elem()) // 映射值类型
    // 通道型：
    case reflect.Chan:
        fmt.Println(&quot;=== 通道型 ===&quot;)
        fmt.Println(&quot;ChanDir            :&quot;, t.ChanDir()) // 通道方向
        fmt.Println(&quot;Elem               :&quot;, t.Elem())    // 通道元素类型
    // 结构体：
    case reflect.Struct:
        fmt.Println(&quot;=== 结构体 ===&quot;)
        fmt.Println(&quot;NumField           :&quot;, t.NumField()) // 字段数量
        if t.NumField() &gt; 0 {
            var i, j int
            // 遍历结构体字段
            for i = 0; i &lt; t.NumField()-1; i++ {
                field := t.Field(i) // 获取结构体字段
                fmt.Printf(&quot;    ├ %v\n&quot;, field.Name)
                // 遍历嵌套结构体字段
                if field.Type.Kind() == reflect.Struct &amp;&amp; field.Type.NumField() &gt; 0 {
                    for j = 0; j &lt; field.Type.NumField()-1; j++ {
                        subfield := t.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                        fmt.Printf(&quot;    │    ├ %v\n&quot;, subfield.Name)
                    }
                    subfield := t.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                    fmt.Printf(&quot;    │    └ %%v\n&quot;, subfield.Name)
                }
            }
            field := t.Field(i) // 获取结构体字段
            fmt.Printf(&quot;    └ %v\n&quot;, field.Name)
            // 通过名称查找字段
            if field, ok := t.FieldByName(&quot;ptr&quot;); ok {
                fmt.Println(&quot;FieldByName(ptr)   :&quot;, field.Name)
            }
            // 通过函数查找字段
            if field, ok := t.FieldByNameFunc(func(s string) bool { return len(s) &gt; 3 }); ok {
                fmt.Println(&quot;FieldByNameFunc    :&quot;, field.Name)
            }
        }
    // 函数型：
    case reflect.Func:
        fmt.Println(&quot;=== 函数型 ===&quot;)
        fmt.Println(&quot;IsVariadic         :&quot;, t.IsVariadic()) // 是否具有变长参数
        fmt.Println(&quot;NumIn              :&quot;, t.NumIn())      // 参数数量
        if t.NumIn() &gt; 0 {
            i := 0
            for ; i &lt; t.NumIn()-1; i++ {
                fmt.Println(&quot;    ┣&quot;, t.In(i)) // 获取参数类型
            }
            fmt.Println(&quot;    ┗&quot;, t.In(i)) // 获取参数类型
        }
        fmt.Println(&quot;NumOut             :&quot;, t.NumOut()) // 返回值数量
        if t.NumOut() &gt; 0 {
            i := 0
            for ; i &lt; t.NumOut()-1; i++ {
                fmt.Println(&quot;    ┣&quot;, t.Out(i)) // 获取返回值类型
            }
            fmt.Println(&quot;    ┗&quot;, t.Out(i)) // 获取返回值类型
        }
    }
}
</code></pre><p> </p><h1 id="reflect-value-类型">reflect.Value 类型</h1><p>代码，</p><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;reflect&quot;
    &quot;unsafe&quot;
)

// 嵌套结构体
type ss struct {
    a struct {
        int
        string
    }
    int
    string
    bool
    float64
}

func (s ss) Method1(i int) string  { return &quot;结构体方法1&quot; }
func (s *ss) Method2(i int) string { return &quot;结构体方法2&quot; }

var (
    intValue   = int(0)
    int8Value  = int8(8)
    int16Value = int16(16)
    int32Value = int32(32)
    int64Value = int64(64)

    uIntValue   = uint(0)
    uInt8Value  = uint8(8)
    uInt16Value = uint16(16)
    uInt32Value = uint32(32)
    uInt64Value = uint64(64)

    byteValue    = byte(0)
    runeValue    = rune(0)
    uintptrValue = uintptr(0)

    boolValue   = false
    stringValue = &quot;stringValue&quot;

    float32Value = float32(32)
    float64Value = float64(64)

    complex64Value  = complex64(64)
    complex128Value = complex128(128)

    arrayValue  = [5]string{}           // 数组
    sliceValue  = []byte{0, 0, 0, 0, 0} // 切片
    mapValue    = map[string]int{}      // 映射
    chanValue   = make(chan int, 2)     // 通道
    structValue = ss{ // 结构体
            struct {
            int
            string
        }{10, &quot;子结构体&quot;},
        20,
        &quot;结构体&quot;,
        false,
        64.0,
    }

    func1Value = func(i int) string { // 函数（固定参数）
        return fmt.Sprintf(&quot;固定参数：%v&quot;, i)
    }

    func2Value = func(i ...int) string { // 函数（动态参数）
        return fmt.Sprintf(&quot;动态参数：%v&quot;, i)
    }

    unsafePointer     = unsafe.Pointer(&amp;structValue)    // 通用指针
    reflectType       = reflect.TypeOf(0)               // 反射类型
    reflectValue      = reflect.ValueOf(0)              // 反射值
    reflectArrayValue = reflect.ValueOf([]int{1, 2, 3}) // 切片反射值
    // 反射接口类型
    interfaceType = reflect.TypeOf(new(interface{})).Elem()
)

// 简单类型
var simpleTypes = []interface{}{
    intValue, &amp;intValue,               // int
    int8Value, &amp;int8Value,             // int8
    int16Value, &amp;int16Value,           // int16
    int32Value, &amp;int32Value,           // int32
    int64Value, &amp;int64Value,           // int64
    uIntValue, &amp;uIntValue,             // uint
    uInt8Value, &amp;uInt8Value,           // uint8
    uInt16Value, &amp;uInt16Value,         // uint16
    uInt32Value, &amp;uInt32Value,         // uint32
    uInt64Value, &amp;uInt64Value,         // uint64
    byteValue, &amp;byteValue,             // byte
    runeValue, &amp;runeValue,             // rune
    uintptrValue, &amp;uintptrValue,       // uintptr
    boolValue, &amp;boolValue,             // bool
    stringValue, &amp;stringValue,         // string
    float32Value, &amp;float32Value,       // float32
    float64Value, &amp;float64Value,       // float64
    complex64Value, &amp;complex64Value,   // complex64
    complex128Value, &amp;complex128Value, // complex128
}

// 复杂类型
var complexTypes = []interface{}{
    arrayValue, &amp;arrayValue,                  // 数组
    sliceValue, &amp;sliceValue,                  // 切片
    mapValue, &amp;mapValue,                      // 映射
    chanValue, &amp;chanValue,                    // 通道
    structValue, &amp;structValue,                // 结构体
    func1Value, &amp;func1Value,                  // 定参函数
    func2Value, &amp;func2Value,                  // 动参函数
    structValue.Method1, structValue.Method2, // 方法
    unsafePointer, &amp;unsafePointer,            // 指针
    reflectType, &amp;reflectType,                // 反射类型
    reflectValue, &amp;reflectValue,              // 反射值
    interfaceType, &amp;interfaceType,            // 接口反射类型
}

// 空值
var unsafeP unsafe.Pointer

// 空接口
var nilInterfece interface{}

func main() {
    // 测试简单类型
    for i := 0; i &lt; len(simpleTypes); i++ {
        PrintInfo(simpleTypes[i])
    }
    // 测试复杂类型
    for i := 0; i &lt; len(complexTypes); i++ {
        PrintInfo(complexTypes[i])
    }
    // 测试单个对象
    PrintInfo(&amp;unsafeP)
    PrintInfo(nilInterfece)
    // PrintInfo(&amp;nilInterfece) // 会引发 panic
}

func PrintInfo(i interface{}) {
    if i == nil {
        fmt.Println(&quot;--------------------&quot;)
        fmt.Printf(&quot;无效接口值：%v\n&quot;, i)
        fmt.Println(&quot;--------------------&quot;)
        return
    }
    v := reflect.ValueOf(i)
    PrintValue(v)
}

func PrintValue(v reflect.Value) {
    fmt.Println(&quot;--------------------&quot;)
    // ----- 通用方法 -----
    fmt.Println(&quot;String             :&quot;, v.String())  // 反射值的字符串形式
    fmt.Println(&quot;Type               :&quot;, v.Type())    // 反射值的类型
    fmt.Println(&quot;Kind               :&quot;, v.Kind())    // 反射值的类别
    fmt.Println(&quot;CanAddr            :&quot;, v.CanAddr()) // 是否可以获取地址
    fmt.Println(&quot;CanSet             :&quot;, v.CanSet())  // 是否可以修改
    if v.CanAddr() {
        fmt.Println(&quot;Addr               :&quot;, v.Addr())       // 获取地址
        fmt.Println(&quot;UnsafeAddr         :&quot;, v.UnsafeAddr()) // 获取自由地址
    }
    // 是否可转换为接口对象
    fmt.Println(&quot;CanInterface       :&quot;, v.CanInterface())
    if v.CanInterface() {
        fmt.Println(&quot;Interface          :&quot;, v.Interface()) // 转换为接口对象
    }
    // 获取方法数量
    fmt.Println(&quot;NumMethod          :&quot;, v.NumMethod())
    if v.NumMethod() &gt; 0 {
        // 遍历方法
        i := 0
        for ; i &lt; v.NumMethod()-1; i++ {
            fmt.Printf(&quot;    ┣ %v\n&quot;, v.Method(i).String())
            //          if i &gt;= 4 { // 只列举 5 个
            //              fmt.Println(&quot;    ┗ ...&quot;)
            //              break
            //          }
        }
        fmt.Printf(&quot;    ┗ %v\n&quot;, v.Method(i).String())
        // 通过名称获取方法
        fmt.Println(&quot;MethodByName       :&quot;, v.MethodByName(&quot;String&quot;).String())
    }
    // ----- 可获取指针的类型 -----
    switch v.Kind() {
    case reflect.Slice, reflect.Map, reflect.Chan, reflect.Func,
        reflect.Ptr, reflect.UnsafePointer:
        fmt.Println(&quot;Pointer            :&quot;, v.Pointer())
    }
    // ----- 特殊类型 -----
    switch v.Kind() {
    // 指针：
    case reflect.Ptr:
        fmt.Println(&quot;=== 指针 ===&quot;)
        // 获取指针地址
        if !v.IsNil() {
            // 获取指针所指对象
            v = v.Elem() // 只有指针和接口类型可以使用 Elem()
            fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, v.Type())
            // 递归处理指针所指对象
            PrintValue(v)
            return
        }
    // 自由指针：
    case reflect.UnsafePointer:
        fmt.Println(&quot;=== 自由指针 ===&quot;)
        if v.Pointer() == 0 {
            v.SetPointer(unsafePointer)
            fmt.Println(&quot;重新指向新对象     :&quot;, v.Pointer())
        }
        // 将自由指针转换为 *ss 指针（因为定义 unsafePointer 时已经确定了类型）
        s := (*ss)(v.Interface().(unsafe.Pointer))
        // 获取反射值
        v = reflect.ValueOf(s)
        if !v.IsNil() {
            // 获取指针所指对象
            v = v.Elem() // 只有指针和接口类型可以使用 Elem()
            fmt.Printf(&quot;转换到指针所指对象 : %v\n&quot;, v.Type())
            // 递归处理指针所指对象
            PrintValue(v)
            return
        }
    // 接口：
    case reflect.Interface:
        fmt.Println(&quot;=== 接口 ===&quot;)
        // 获取接口数据
        fmt.Println(&quot;InterfaceData      :&quot;, v.InterfaceData())
        // 获取接口所包含的对象
        v = v.Elem() // 只有指针和接口类型可以使用 Elem()
        fmt.Printf(&quot;转换到接口所含对象 : %v\n&quot;, v.Type())
        // 递归处理接口的动态对象
        PrintValue(v)
        return
    }
    // ----- 简单类型 -----
    // 有符号整型：
    if reflect.Int &lt;= v.Kind() &amp;&amp; v.Kind() &lt;= reflect.Int64 {
        fmt.Println(&quot;=== 有符号整型 ===&quot;)
        fmt.Println(&quot;Int                :&quot;, v.Int()) // 获取值
        if v.CanSet() {
            v.SetInt(10)                                 // 设置值
            fmt.Println(&quot;Int                :&quot;, v.Int()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type())) // 设置值
        }
        fmt.Println(&quot;Int                :&quot;, v.Int())           // 获取值
        fmt.Println(&quot;OverflowInt        :&quot;, v.OverflowInt(10)) // 是否溢出
    }
    // 无符号整型：
    if reflect.Uint &lt;= v.Kind() &amp;&amp; v.Kind() &lt;= reflect.Uint64 {
        fmt.Println(&quot;=== 无符号整型 ===&quot;)
        fmt.Println(&quot;Uint               :&quot;, v.Uint()) // 获取值
        if v.CanSet() {
            v.SetUint(10)                                 // 设置值
            fmt.Println(&quot;Uint               :&quot;, v.Uint()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type()))  // 设置值
        }
        fmt.Println(&quot;Uint               :&quot;, v.Uint())           // 获取值
        fmt.Println(&quot;OverflowUint       :&quot;, v.OverflowUint(10)) // 是否溢出
    }
    switch v.Kind() {
    // 浮点数：
    case reflect.Float32, reflect.Float64:
        fmt.Println(&quot;=== 浮点数 ===&quot;)
        fmt.Println(&quot;Float              :&quot;, v.Float()) // 获取值
        if v.CanSet() {
            v.SetFloat(10)                                 // 设置值
            fmt.Println(&quot;Float              :&quot;, v.Float()) // 获取值
            v.Set(reflect.ValueOf(20).Convert(v.Type()))   // 设置值
        }
        fmt.Println(&quot;Float              :&quot;, v.Float())           // 获取值
        fmt.Println(&quot;OverflowFloat      :&quot;, v.OverflowFloat(10)) // 是否溢出
    // 复数：
    case reflect.Complex64, reflect.Complex128:
        fmt.Println(&quot;=== 复数 ===&quot;)
        fmt.Println(&quot;Complex            :&quot;, v.Complex()) // 获取值
        if v.CanSet() {
            v.SetComplex(10)                                   // 设置值
            fmt.Println(&quot;Complex            :&quot;, v.Complex())   // 获取值
            v.Set(reflect.ValueOf(20 + 20i).Convert(v.Type())) // 设置值
        }
        fmt.Println(&quot;Complex            :&quot;, v.Complex())           // 获取值
        fmt.Println(&quot;OverflowComplex    :&quot;, v.OverflowComplex(10)) // 是否溢出
    // 布尔型：
    case reflect.Bool:
        fmt.Println(&quot;=== 布尔型 ===&quot;)
        fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
        if v.CanSet() {
            v.SetBool(true)                               // 设置值
            fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
            v.Set(reflect.ValueOf(false))                 // 设置值
        }
        fmt.Println(&quot;Bool               :&quot;, v.Bool()) // 获取值
    // 字符串：
    case reflect.String:
        fmt.Println(&quot;=== 字符串 ===&quot;)
        fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
        if v.CanSet() {
            v.SetString(&quot;abc&quot;)                              // 设置值
            fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
            v.Set(reflect.ValueOf(&quot;def&quot;))                   // 设置值
        }
        fmt.Println(&quot;String             :&quot;, v.String()) // 获取值
    // ----- 复杂类型 -----
    // 切片型：
    case reflect.Slice:
        fmt.Println(&quot;=== 切片型 ===&quot;)
        fmt.Println(&quot;Len                :&quot;, v.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, v.Cap()) // 获取容量
        if v.CanSet() {
            v.SetLen(4) // 不能大于 cap
            v.SetCap(4) // 不能小于 len，只能缩，不能扩
            fmt.Println(&quot;SetLen, SetCap     :&quot;, v.Len(), v.Cap())
            // 重新指定字节内容
            if v.Type().Elem().Kind() == reflect.Uint8 {
                v.SetBytes([]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0})
            }
            fmt.Println(&quot;SetByte            :&quot;, []byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 0})
        }
        // 获取字节内容
        if v.Type().Elem().Kind() == reflect.Uint8 {
            fmt.Println(&quot;Bytes              :&quot;, v.Bytes())
        }
        // 根据索引获取元素
        if v.Len() &gt; 0 {
            for i := 0; i &lt; v.Len(); i++ {
                fmt.Println(&quot;Index              :&quot;, v.Index(i))
            }
        }
        // 获取一个指定范围的切片
        // 参数：起始下标，结束下标
        // 长度 = 结束下标 - 起始下标
        s1 := v.Slice(1, 2)
        fmt.Println(&quot;Slice              :&quot;, s1)
        fmt.Println(&quot;Len                :&quot;, s1.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, s1.Cap()) // 获取容量
        // 获取一个指定范围和容量的切片
        // 参数：起始下标，结束下标，容量下标
        // 长度 = 结束下标 - 起始下标
        // 容量 = 容量下标 - 起始下标
        s2 := v.Slice3(1, 2, 4)
        fmt.Println(&quot;Slice              :&quot;, s2)
        fmt.Println(&quot;Len                :&quot;, s2.Len()) // 获取长度
        fmt.Println(&quot;Cap                :&quot;, s2.Cap()) // 获取容量
    // 映射型：
    case reflect.Map:
        fmt.Println(&quot;=== 映射型 ===&quot;)
        // 设置键值，不需要检测 CanSet
        v.SetMapIndex(reflect.ValueOf(&quot;a&quot;), reflect.ValueOf(1))
        v.SetMapIndex(reflect.ValueOf(&quot;b&quot;), reflect.ValueOf(2))
        v.SetMapIndex(reflect.ValueOf(&quot;c&quot;), reflect.ValueOf(3))
        // 获取键列表
        fmt.Println(&quot;MapKeys            :&quot;, v.MapKeys())
        for _, idx := range v.MapKeys() {
            // 根据键获取值
            fmt.Println(&quot;MapIndex           :&quot;, v.MapIndex(idx))
        }
    // 结构体：
    case reflect.Struct:
        fmt.Println(&quot;=== 结构体 ===&quot;)
        // 获取字段个数
        fmt.Println(&quot;NumField           :&quot;, v.NumField())
        if v.NumField() &gt; 0 {
            var i, j int
            // 遍历结构体字段
            for i = 0; i &lt; v.NumField()-1; i++ {
                field := v.Field(i) // 获取结构体字段
                fmt.Printf(&quot;    ├ %-8v %v\n&quot;, field.Type(), field.String())
                // 遍历嵌套结构体字段
                if field.Kind() == reflect.Struct &amp;&amp; field.NumField() &gt; 0 {
                    for j = 0; j &lt; field.NumField()-1; j++ {
                        subfield := v.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                        fmt.Printf(&quot;    │    ├ %-8v %v\n&quot;, subfield.Type(), subfield.String())
                        // if i &gt;= 4 { // 只列举 5 个
                        //  fmt.Println(&quot;        ┗ ...&quot;)
                        //  break
                        // }
                    }
                    subfield := v.FieldByIndex([]int{i, j}) // 获取嵌套结构体字段
                    fmt.Printf(&quot;    │    └ %-8v %v\n&quot;, subfield.Type(), subfield.String())
                }
                // if i &gt;= 4 { // 只列举 5 个
                //  fmt.Println(&quot;    ┗ ...&quot;)
                //  break
                // }
            }
            field := v.Field(i) // 获取结构体字段
            fmt.Printf(&quot;    └ %-8v %v\n&quot;, field.Type(), field.String())
            // 通过名称查找字段
            if v := v.FieldByName(&quot;ptr&quot;); v.IsValid() {
                fmt.Println(&quot;FieldByName(ptr)   :&quot;, v.Type().Name())
            }
            // 通过函数查找字段
            v := v.FieldByNameFunc(func(s string) bool { return len(s) &gt; 3 })
            if v.IsValid() {
                fmt.Println(&quot;FieldByNameFunc    :&quot;, v.Type().Name())
            }
        }
    // 通道型：
    case reflect.Chan:
        fmt.Println(&quot;=== 通道型 ===&quot;)
        // 发送数据（会阻塞）
        v.Send(reflectValue)
        // 尝试发送数据（不会阻塞）
        fmt.Println(&quot;TrySend            :&quot;, v.TrySend(reflectValue))
        // 接收数据（会阻塞）
        if x, ok := v.Recv(); ok {
            fmt.Println(&quot;Recv               :&quot;, x) //
        }
        // 尝试接收数据（不会阻塞）
        if x, ok := v.TryRecv(); ok {
            fmt.Println(&quot;TryRecv            :&quot;, x) //
        }
    // 因为要执行两次，通道和通道指针各执行一次，关闭后第二次就无法执行了。
    // v.Close()
    // 函数型：
    case reflect.Func:
        fmt.Println(&quot;=== 函数型 ===&quot;)
        // 判断函数是否具有变长参数
        if v.Type().IsVariadic() {
            // 与可变参数对应的实参必须是切片类型的反射值（reflectArrayValue）。
            fmt.Println(&quot;CallSlice          :&quot;, v.CallSlice([]reflect.Value{reflectArrayValue})) //
            // 也可以用 v.Call 调用变长参数的函数，只需传入 reflectValue 即可。
        } else {
            // 根据函数定义的参数数量，传入相应数量的反射值（reflectValue）。
            fmt.Println(&quot;Call               :&quot;, v.Call([]reflect.Value{reflectValue})) //
        }
    }
}
</code></pre><p>====END====</p></div><aside id="meta"><meta itemprop="wordCount" content="2262"><meta itemprop="url" content="https://yushuangqi.com/blog/2017/go-reflectbao.html"></aside></article><div><div class="attribution"><div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_youdao" data-cmd="youdao" title="分享到有道云笔记"></a><a href="#" class="bds_mshare" data-cmd="mshare" title="分享到一键分享"></a></div><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","qzone","tsina","bdysc","weixin","tqq","tieba","douban","sqq","youdao","qingbiji","mail","evernotecn","copy","print"],"bdPic":"","bdStyle":"0","bdSize":"32"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></div><div><ul class="rel_links"><li class="rel_linksli"><span id="topics">分类: <a href="/topics/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%BC%80%E5%8F%91.html" rel="category">编程语言与开发</a> </span><span id="tags">标签: <a href="/tags/golang.html" rel="tag">golang</a></span></li><li class="rel_linksli rel_prev"><a href="https://yushuangqi.com/blog/2017/golangxue-xi-zhai-lu-si-bao.html">Golang学习摘录四:包</a></li><li class="rel_linksli rel_next"><a href="https://yushuangqi.com/blog/2017/ming-ling--go-build.html">Gobuild命令说明</a></li></ul></div><aside id="comments"><div><div id="cyEmoji" role="cylabs" data-use="emoji" sid="76b32eede2ea873b203b7e2eda42cd4d"></div><div id="cyReward" role="cylabs" data-use="reward" sid="76b32eede2ea873b203b7e2eda42cd4d" style="text-align:center"></div><div id="SOHUCS" sid="76b32eede2ea873b203b7e2eda42cd4d"></div><script type="text/javascript">(function(){ 
var appid = 'cyt7HM6Iq'; 
var conf = 'prod_90e85fc8b207249a2493340f99075c94'; 
var width = window.innerWidth || document.documentElement.clientWidth; 
if (width < 960) { 
window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); 
}else{ 
  var loadJs=function(d,a){
    var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");
    b.setAttribute("type","text/javascript");
    b.setAttribute("charset","UTF-8");
    b.setAttribute("src",d);
    if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};
   loadJs("https://changyan.sohu.com/upload/changyan.js",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();</script><script type="text/javascript" charset="utf-8" src="https://changyan.itc.cn/js/lib/jquery.js"></script><script type="text/javascript" charset="utf-8" src="https://changyan.sohu.com/js/changyan.labs.https.js?appid=cyt7HM6Iq"></script></div></aside></div></section><section id="sidebar" role="complementary"><aside class="writings"><a href="/" class="sideimg sideimgwritings">Home</a> <q class="dquote">读书之法，莫贵于循序而致精。<cite>—宋·朱熹《性理精义》</cite></q><ul class="rel_links"><li class="rel_linksli"><a href="http://weibo.com/234665601" title="关注虞双齐的微博" rel="nofollow">我的微博</a></li><li class="rel_linksli"><a href="https://github.com/ysqi" title="访问虞双齐的Github" rel="nofollow">我的 Github</a></li><li class="rel_linksli"><a href="https://www.zhihu.com/people/_ysqi" title="访问虞双齐的知乎" rel="nofollow">我的 知乎</a></li></ul></aside><aside><div class="ds-recent-comments" data-num-items="5" data-show-avatars="1" data-show-time="1" data-show-title="1" data-show-admin="1" data-excerpt-length="70"></div></aside></section><nav id="menu" role="navigation"><ul id="nav" class="navlist"><li class="navtop"><a class="navtoplink" href="#page"><span>Top</span></a></li><li><a class="navabout" href="https://yushuangqi.com"><span>首页</span></a></li><li><a class="navwritings" href="/topics/"><span>博文</span></a></li><li><a class="navpresos" href="/book.html"><span>电子书</span></a></li><li><a class="navabout" href="/about.html"><span>关于我</span></a></li></ul></nav></div><footer class="site-footer"><ul class="footeractions"><li><a class="footeraction" href="http://weibo.com/234665601" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionWeibo">Weibo</span></a></li><li><a class="footeraction" href="https://www.zhihu.com/people/_ysqi" rel="nofollow" title="在微博关注 虞双齐"><span class="footeractionZhiHu">知乎</span></a></li><li><a class="footeraction" href="/index.xml" title="RSS订阅 虞双齐"><span class="footeractionRSS">Feed</span></a></li><li><a class="footeraction" href="http://validator.w3.org/check?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2017%2fgo-reflectbao.html" rel="nofollow" target="blank"><span class="footeractionW3CHTML">Valid XHTMl 4.0</span></a></li><li><a class="footeraction" href="http://jigsaw.w3.org/css-validator/validator?uri=https%3a%2f%2fyushuangqi.com%2fblog%2f2017%2fgo-reflectbao.html" rel="nofollow" target="blank"><span class="footeractionW3CCSS">Valid CSS Leval2</span></a></li></ul><p>©2015-2016 虞双齐-全栈开发。欢迎<a href="/about.html" rel="nofollow">联系我</a>，<a href="http://www.miitbeian.gov.cn/" target="bank" rel="nofollow" style="color:#c9c9c9">粤ICP备14032560号-4</a></p></footer><script>var _hmt = _hmt || [];
  (function() {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?a16b3275b071ec0efc507a05422a7156";
    var s = document.getElementsByTagName("script")[0]; 
    s.parentNode.insertBefore(hm, s);
  })();</script></body></html>